<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Генерация и визуализация JI ладов</title>
  <style>
    /* Основные переменные */
    :root {
      --bg-primary: #121212;
      --bg-surface: rgba(255, 255, 255, 0.05);
      --bg-elevated: rgba(255, 255, 255, 0.08);
      --bg-hover: rgba(255, 255, 255, 0.12);
      --text-primary: rgba(255, 255, 255, 0.87);
      --text-secondary: rgba(255, 255, 255, 0.6);
      --primary: #bb86fc;
      --primary-variant: #3700b3;
      --secondary: #03dac6;
      --border-color: rgba(60,60,60,0.8);
    }
    
    *, *:before, *:after {
      box-sizing: border-box;
    }
    
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: 'Roboto', sans-serif;
      background-color: var(--bg-primary);
      color: var(--text-primary);
    }
    
    /* Контейнер приложения */
    #app {
      display: flex;
      flex-direction: column;
      height: 100%;
    }
    
    /* Панель визуализации */
    #visualization-panel {
      flex: 1;
      position: relative;
      background-color: var(--bg-primary);
    }
    #visualization-panel canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    
    /* Панель контролов */
    #control-panel {
      background-color: var(--bg-surface);
      overflow: auto;
      padding: 16px;
      transition: transform 0.3s ease;
    }
    
    /* Внутренняя структура панели контролов – таблица и блок генерации */
    .controls-container {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    
    /* Стилизация таблицы ладов */
    .scales-table-container {
      overflow-x: auto;
    }
    .scales-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9em;
    }
    .scales-table th, .scales-table td {
      padding: 8px 12px;
      text-align: left;
      border-bottom: 1px solid var(--border-color);
    }
    .scales-table th {
      background-color: var(--bg-elevated);
      cursor: pointer;
      position: sticky;
      top: 0;
      color: var(--text-secondary);
    }
    .scales-table tr {
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .scales-table tr:hover {
      background-color: var(--bg-hover);
    }
    .scales-table tr.selected {
      background-color: rgba(187,134,252,0.2);
    }
    .scales-table td.consonance {
      color: var(--secondary);
    }
    .scales-table td.scale {
      font-family: monospace;
    }
    
    /* Блок параметров генерации */
    #generation-parameters {
      background-color: var(--bg-elevated);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    #generation-parameters h3 {
      margin: 0 0 16px;
      font-size: 1.25em;
      color: var(--text-primary);
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 8px;
    }
    #generation-parameters .param-row {
      display: flex;
      align-items: baseline;
      justify-content: flex-end;
      gap: 8px;
      margin-bottom: 12px;
    }
    #generation-parameters label {
      margin: 0;
      text-align: right;
      color: var(--text-secondary);
      font-size: 0.9em;
    }
    #generation-parameters input {
      width: auto;
      min-width: 50px;
      padding: 4px 6px;
      text-align: right;
      background-color: var(--bg-surface);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 4px;
      color: var(--text-primary);
    }
    #generation-parameters button {
      padding: 12px 24px;
      background-color: var(--primary);
      color: #000;
      font-weight: 500;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      max-width: 250px;
      width: auto;
      display: block;
      margin: 20px auto 0;
    }
    #generation-parameters button:hover {
      background-color: var(--primary-variant);
      color: #fff;
    }
    
    /* Кнопка для показа/скрытия панели контролов (для портретной ориентации) */
    #toggle-controls {
      display: none;
      position: fixed;
      bottom: 16px;
      right: 16px;
      padding: 12px;
      background-color: var(--primary);
      color: #000;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      z-index: 1000;
    }
    
    /* Горизонтальная ориентация – панель контролов занимает 50% высоты */
    @media (orientation: landscape) {
      #control-panel {
        max-height: 50vh;
      }
    }
    
    /* Портретная ориентация – панель контролов скрыта по умолчанию и расположена в column-reverse */
    @media (orientation: portrait) {
      #app {
        flex-direction: column-reverse;
      }
      #control-panel {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        max-height: 70vh;
        transform: translateY(-100%);
        z-index: 999;
      }
      #control-panel.visible {
        transform: translateY(0);
      }
      #toggle-controls {
        display: block;
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="control-panel">
      <div class="controls-container">
        <!-- Таблица ладов -->
        <div class="scales-table-container">
          <table class="scales-table">
            <thead>
              <tr>
                <th data-sort="N">N</th>
                <th data-sort="consonance">Consonance</th>
                <th data-sort="scalename">Scale Name</th>
                <th data-sort="scale">Scale</th>
              </tr>
            </thead>
            <tbody id="scales-table-body"></tbody>
          </table>
        </div>
        <!-- Параметры генерации -->
        <div id="generation-parameters">
          <h3>Параметры генерации</h3>
          <div class="param-row">
            <label for="maxNotes">Макс. число нот:</label>
            <input type="number" id="maxNotes" value="8" min="3" max="12">
          </div>
          <div class="param-row">
            <label for="searchLimit">Отсечка:</label>
            <input type="number" id="searchLimit" value="32" min="1" max="100">
          </div>
          <div class="param-row">
            <label for="minConsonance">Мин. конс.:</label>
            <input type="number" id="minConsonance" step="0.01" value="0.2" min="0" max="1">
          </div>
          <button id="genScalesBtn">Сгенерировать лады</button>
        </div>
      </div>
    </div>
    <div id="visualization-panel">
      <canvas id="myCanvas"></canvas>
    </div>
    <button id="toggle-controls">☰</button>
  </div>
  
  <script>
    /******************************************************************
     * Глобальные переменные
     ******************************************************************/
    let currentScale = null;
    let generatedScalesArray = [];
    let currentSortColumn = 'default'; // default – сортировка по консонансу (убыв.) и N (возр.)
    let currentSortOrder = 'desc'; // для default – consonance по убыванию

    const canvas = document.getElementById("myCanvas");
    const context = canvas.getContext("2d");
    
    /******************************************************************
     * Класс для работы с рациональными интервалами
     ******************************************************************/
    class RationalInterval {
      constructor(numerator, denominator) {
        this.numerator = numerator;
        this.denominator = denominator;
        this.simplify();
      }
      gcd(a, b) {
        return b === 0 ? a : this.gcd(b, a % b);
      }
      simplify() {
        const g = this.gcd(this.numerator, this.denominator);
        this.numerator /= g;
        this.denominator /= g;
      }
      normalize() {
        let num = this.numerator;
        let den = this.denominator;
        while (num >= 2 * den) num /= 2;
        while (num < den) num *= 2;
        return new RationalInterval(num, den);
      }
      toCents() {
        return 1200 * Math.log2(this.numerator / this.denominator);
      }
      toDecimal() {
        return this.numerator / this.denominator;
      }
      toString() {
        return `${this.numerator}/${this.denominator}`;
      }
      multiply(other) {
        return new RationalInterval(this.numerator * other.numerator, this.denominator * other.denominator);
      }
      divide(other) {
        return new RationalInterval(this.numerator * other.denominator, this.denominator * other.numerator);
      }
    }
    
    /******************************************************************
     * Вспомогательные функции для генерации ладов
     ******************************************************************/
    function isPow2(x) {
      return (x & (x - 1)) === 0;
    }
    function factorize(n) {
      let factors = [];
      let d = 2;
      while (n > 1) {
        while (n % d === 0) {
          factors.push(d);
          n /= d;
        }
        d++;
        if (d * d > n && n > 1) {
          factors.push(n);
          break;
        }
      }
      return factors;
    }
    function consonance(r) {
      return 1 / r.denominator + 1 / r.numerator;
    }
    function scaleConsonance(scale) {
      let pairs = [];
      let sorted = scale.slice().sort((a, b) => a.toDecimal() - b.toDecimal());
      for (let i = 0; i < sorted.length; i++) {
        for (let j = i + 1; j < sorted.length; j++) {
          let ratio = sorted[j].divide(sorted[i]).normalize();
          pairs.push(consonance(ratio));
        }
      }
      return pairs.length > 0 ? pairs.reduce((a, b) => a + b) / pairs.length : 1.0;
    }
    function oddLimit(limit, r) {
      return r.numerator <= limit || r.denominator <= limit;
    }
    function primeLimit(r) {
      if (!isPow2(r.denominator)) return false;
      let factors = factorize(r.numerator);
      if (factors.filter(p => p === 3).length > 4) return false;
      if (factors.filter(p => p >= 5).length > 2) return false;
      if (factors.filter(p => p >= 7).length > 1) return false;
      return true;
    }
    const MAX_SCALES = 100;
    function insertScale(scales, newScale, cons) {
      const key = newScale.map(r => r.toString()).sort().join("|");
      if (scales.some(entry => entry.key === key)) return false;
      const newEntry = { consonance: cons, scale: newScale, key, n: newScale.length };
      let pos = scales.findIndex(entry => entry.consonance < cons);
      if (pos === -1) scales.push(newEntry);
      else scales.splice(pos, 0, newEntry);
      if (scales.length > MAX_SCALES) scales.pop();
      return true;
    }
    function generateBaseIntervals(cutoff) {
      let baseRatios = [];
      for (let i = 3; i <= 45; i++) {
        for (let j = i + 1; j <= 45; j++) {
          baseRatios.push(new RationalInterval(j, i));
        }
      }
      let filtered = baseRatios.filter(r => primeLimit(r) && oddLimit(cutoff, r));
      let seen = new Set();
      let intervals = [];
      for (let r of filtered) {
        let nr = r.normalize();
        let key = nr.toString();
        if (!seen.has(key)) {
          seen.add(key);
          intervals.push(nr);
        }
      }
      return intervals;
    }
    function generateScales(maxNotes = 8, searchLimit = 32, minConsonance = 0.2) {
      let scalesDB = {};
      const unison = new RationalInterval(1,1);
      scalesDB[1] = [{ consonance: 1.0, scale: [unison], key: unison.toString(), n: 1 }];
      let intervals = generateBaseIntervals(searchLimit);
      for (let n = 2; n <= maxNotes; n++) {
        let newScales = [];
        let prev = scalesDB[n - 1] || [];
        for (let entry of prev) {
          let scale = entry.scale;
          for (let baseNote of scale) {
            for (let interval of intervals) {
              let newNoteUp = baseNote.multiply(interval).normalize();
              let newNoteDown = baseNote.divide(interval).normalize();
              for (let newNote of [newNoteUp, newNoteDown]) {
                if (scale.some(r => r.toString() === newNote.toString())) continue;
                let candidate = scale.slice();
                candidate.push(newNote);
                candidate.sort((a, b) => a.toDecimal() - b.toDecimal());
                if (candidate.length === n) {
                  let cons = scaleConsonance(candidate);
                  if (cons >= minConsonance) {
                    insertScale(newScales, candidate, cons);
                  }
                }
              }
            }
          }
        }
        scalesDB[n] = newScales;
      }
      return scalesDB;
    }
    function flattenScales(scalesDB) {
      generatedScalesArray = [];
      for (let n in scalesDB) {
        for (let entry of scalesDB[n]) {
          generatedScalesArray.push({ n: parseInt(n), consonance: entry.consonance, scale: entry.scale, key: entry.key });
        }
      }
      // Сортировка по умолчанию: сначала по консонансу (убыв.), затем по N (возр.)
      generatedScalesArray.sort((a, b) => {
        if (b.consonance !== a.consonance) return b.consonance - a.consonance;
        return a.n - b.n;
      });
    }
    
    /******************************************************************
     * Функции визуализации
     ******************************************************************/
    function resizeCanvas() {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
      if (currentScale) drawScale(currentScale);
    }
    window.addEventListener("resize", resizeCanvas);
    function drawScale(scale) {
      context.clearRect(0, 0, canvas.width, canvas.height);
      const marginLeft = canvas.width * 0.05;
      const usableWidth = canvas.width * 0.9;
      const marginTop = 20;
      const marginBottom = 20;
      const bottom = canvas.height - marginBottom;
      let sorted = scale.slice().sort((a, b) => a.toDecimal() - b.toDecimal());
      // Базовая линия
      context.strokeStyle = "#555";
      context.lineWidth = 2;
      context.beginPath();
      context.moveTo(marginLeft, bottom);
      context.lineTo(marginLeft + usableWidth, bottom);
      context.stroke();
      // Вычисление максимальной разницы между нотами
      let maxDiff = 0;
      for (let i = 0; i < sorted.length; i++) {
        for (let j = i + 1; j < sorted.length; j++) {
          let diff = sorted[j].toDecimal() - sorted[i].toDecimal();
          if (diff > maxDiff) maxDiff = diff;
        }
      }
      if (maxDiff === 0) maxDiff = 1;
      // Отрисовка дуг для каждого интервала
      context.lineWidth = 10;
      context.strokeStyle = "rgba(255,255,255,0.3)";
      for (let i = 0; i < sorted.length - 1; i++) {
        for (let j = i + 1; j < sorted.length; j++) {
          const x1 = marginLeft + ((sorted[i].toDecimal() - 1) / 1) * usableWidth;
          const x2 = marginLeft + ((sorted[j].toDecimal() - 1) / 1) * usableWidth;
          const diff = sorted[j].toDecimal() - sorted[i].toDecimal();
          const curveHeight = diff * (canvas.height - marginTop - marginBottom) / maxDiff;
          context.beginPath();
          context.moveTo(x1, bottom);
          context.bezierCurveTo(x1, bottom - curveHeight, x2, bottom - curveHeight, x2, bottom);
          context.stroke();
        }
      }
      // Отрисовка нот
      context.font = "12px sans-serif";
      context.textAlign = "center";
      const noteRadius = 10;
      for (let note of sorted) {
        const x = marginLeft + ((note.toDecimal() - 1) / 1) * usableWidth;
        context.beginPath();
        context.arc(x, bottom, noteRadius, 0, 2 * Math.PI);
        context.fillStyle = "#212121";
        context.fill();
        context.strokeStyle = "#ffffff";
        context.stroke();
        context.fillStyle = "#ffffff";
        context.fillText(note.toString(), x, bottom - noteRadius - 10);
        context.fillText(Math.round(note.toCents()) + " ct", x, bottom + noteRadius + 14);
      }
    }
    
    /******************************************************************
     * Функция сортировки ладов по выбранной колонке
     ******************************************************************/
    function sortScales(scales) {
      let sorted = scales.slice();
      if (currentSortColumn === 'default') {
        sorted.sort((a, b) => {
          if (b.consonance !== a.consonance) return b.consonance - a.consonance;
          return a.n - b.n;
        });
      } else if (currentSortColumn === 'N') {
        sorted.sort((a, b) => currentSortOrder === 'asc' ? a.n - b.n : b.n - a.n);
      } else if (currentSortColumn === 'consonance') {
        sorted.sort((a, b) => currentSortOrder === 'asc' ? a.consonance - b.consonance : b.consonance - a.consonance);
      } else if (currentSortColumn === 'scalename') {
        sorted.sort((a, b) => {
          let nameA = "Лад " + a.n;
          let nameB = "Лад " + b.n;
          return currentSortOrder === 'asc' ? nameA.localeCompare(nameB) : nameB.localeCompare(nameA);
        });
      } else if (currentSortColumn === 'scale') {
        sorted.sort((a, b) => {
          let scaleA = a.scale.map(r => r.toString()).join(", ");
          let scaleB = b.scale.map(r => r.toString()).join(", ");
          return currentSortOrder === 'asc' ? scaleA.localeCompare(scaleB) : scaleB.localeCompare(scaleA);
        });
      }
      return sorted;
    }
    
    /******************************************************************
     * Функция отрисовки таблицы ладов
     ******************************************************************/
    function renderScalesTable() {
      const tableBody = document.getElementById("scales-table-body");
      tableBody.innerHTML = "";
      let sortedScales = sortScales(generatedScalesArray);
      sortedScales.forEach((entry, index) => {
        const tr = document.createElement("tr");
        tr.dataset.index = index;
        const tdN = document.createElement("td");
        tdN.textContent = entry.n;
        const tdConsonance = document.createElement("td");
        tdConsonance.textContent = entry.consonance.toFixed(3);
        tdConsonance.classList.add("consonance");
        const tdName = document.createElement("td");
        tdName.textContent = "Лад " + (index + 1);
        const tdScale = document.createElement("td");
        tdScale.textContent = entry.scale.map(r => r.toString()).join(", ");
        tdScale.classList.add("scale");
        tr.appendChild(tdN);
        tr.appendChild(tdConsonance);
        tr.appendChild(tdName);
        tr.appendChild(tdScale);
        tr.addEventListener("click", () => {
          document.querySelectorAll(".scales-table tr").forEach(row => row.classList.remove("selected"));
          tr.classList.add("selected");
          currentScale = entry.scale;
          drawScale(currentScale);
        });
        tableBody.appendChild(tr);
      });
      // Если таблица не пуста – автоматически выбираем первую строку
      const firstRow = tableBody.querySelector("tr");
      if (firstRow) {
        firstRow.classList.add("selected");
        currentScale = sortedScales[0].scale;
        drawScale(currentScale);
      }
      attachHeaderSortListeners();
    }
    
    /******************************************************************
     * Функция привязки обработчиков клика по заголовкам таблицы для сортировки
     ******************************************************************/
    function attachHeaderSortListeners() {
      const headers = document.querySelectorAll(".scales-table th");
      headers.forEach(header => {
        header.addEventListener("click", () => {
          const sortKey = header.getAttribute("data-sort");
          if (currentSortColumn === sortKey) {
            currentSortOrder = currentSortOrder === 'asc' ? 'desc' : 'asc';
          } else {
            currentSortColumn = sortKey;
            currentSortOrder = 'asc';
          }
          renderScalesTable();
        });
      });
    }
    
    /******************************************************************
     * Обработчики событий и инициализация
     ******************************************************************/
    document.getElementById("genScalesBtn").addEventListener("click", () => {
      const maxNotes = parseInt(document.getElementById("maxNotes").value);
      const searchLimit = parseInt(document.getElementById("searchLimit").value);
      const minConsonance = parseFloat(document.getElementById("minConsonance").value);
      const scalesDB = generateScales(maxNotes, searchLimit, minConsonance);
      flattenScales(scalesDB);
      currentSortColumn = 'default';
      currentSortOrder = 'desc';
      renderScalesTable();
    });
    
    window.addEventListener("load", () => {
      document.getElementById("genScalesBtn").click();
    });
    
    document.getElementById("toggle-controls").addEventListener("click", () => {
      document.getElementById("control-panel").classList.toggle("visible");
    });
  </script>
</body>
</html>
