## Записки о музыкальной арифметике: Путешествие к гармонии через код

Музыка, язык вселенной, говорит с нами на языке вибраций. С древнейших времён люди стремились расшифровать этот язык, понять законы гармонии. От Пифагора, экспериментировавшего с монохордом, до современных композиторов, использующих сложные алгоритмы — это путешествие продолжается. В этой статье мы не просто коснёмся истории музыкальной теории, но и создадим инструмент для исследования гармонии — программу на языке Julia, которая позволит нам генерировать лады, основанные на акустических принципах. Этот метод, унтертоновая полимодальность, откроет новые горизонты для музыкального творчества, расширяя границы традиционной тональности.

### I. Звук как сумма гармоник

Прежде чем погрузиться в код, давайте вспомним, что музыкальный звук — это не просто одиночная частота, а сложная комбинация колебаний, называемых гармониками или обертонами. Частоты обертонов кратны основной частоте (основному тону).

<iframe src="interactive_oscilloscope.html"></iframe> <comment>Интерактивный пример с осциллоскопом, на котором можно включить разные обертоны с разными формами волны, укладывающимися в основной тон</comment>

### II. Математика консонанса: совпадения обертонов и гармоническая энтропия

Консонанс, или благозвучие, связан с совпадением обертонов у разных звуков. Чем больше совпадающих обертонов, тем консонантнее интервал. Если частоты двух нот относятся друг к другу как целые дроби *m/n*, то процент совпадающих гармоник можно оценить формулой  *1/m + 1/n*. Эта формула хороша своей простотой для расчёта (включая массовый перебор вариантов) и понимания, а также соответствует простому физическому параметру.

<iframe src="harmonics_visualizer.html"></iframe> <comment>Визуализатор гармоник на спектрограмме. Все гармоники кликабельны и звучат, а программа показывает общую тонику для двух звуков</comment>

Эта  формула  ляжет  в  основу  нашей  функции  `consonance`:

```julia
function consonance(ratio::Rational{Int})::Float64
    Float64(denominator(ratio)^-1 + numerator(ratio)^-1)
end
```

Однако, помимо совпадения обертонов, на восприятие консонанса влияет также *гармоническая энтропия*. Она отражает сложность соотношения частот двух нот. Чем проще соотношение, тем ниже энтропия и тем более консонантным воспринимается интервал. <iframe src="entropy_visualizer.html"></iframe> <comment>Интерактивный пример с визуализацией гармонической энтропии и её сравнением с эмпирическими исследованиями благозвучности</comment>  Как показывают исследования, существует высокая корреляция между гармонической энтропией и субъективным восприятием благозвучия.

### III. Строим математический фундамент: допустимые интервалы

Начнём с создания набора допустимых интервалов. Используем язык программирования Julia.

```julia
using Combinatorics
using Primes

#  Генерация всех возможных отношений частот (дробей) до 45/45
base_ratios = Rational{Int}[y // x for (x, y) in combinations(1:45, 2)]

#  Фильтрация отношений по odd limit (числитель и знаменатель не больше 32)
odd_limit(limit::Int, ratio::Rational{Int}) = numerator(ratio) <= limit && denominator(ratio) <= limit
filtered_by_odd_limit = filter(r -> odd_limit(32, r), base_ratios)

#  Фильтрация отношений по prime limit (только простые множители 2, 3, 5, 7 с ограничениями)
prime_limit(ratio::Rational{Int}) = begin
    ispow2(denominator(ratio)) || return false
    factors = Primes.factor(Vector, numerator(ratio))
    count(==(3), factors) <= 4 && count(>=(5), factors) <= 2 && count(>=(7), factors) <= 1
end
filtered_ratios = filter(prime_limit, filtered_by_odd_limit)

#  Нормализация интервалов к октаве и удаление дубликатов
normalize_to_octave(ratio::Rational{Int}) = ratio / (2//1)^floor(Int, log2(ratio))
intervals = unique(normalize_to_octave.(filtered_ratios))

#  Вывод таблицы интервалов
println("Допустимые интервалы:")
for interval in intervals
    cents = round(1200 * log2(interval), digits=2)
    name = "" #  Здесь нужно добавить названия интервалов (см. таблицу ниже)
    println("$interval \t $cents ц. \t $name")
end
```

Этот код генерирует все возможные дроби с числителем и знаменателем не более 45, а затем фильтрует их, используя `odd_limit` и `prime_limit`. `odd_limit` ограничивает сложность дробей, а  `prime_limit` отдаёт предпочтение интервалам, близким к гармоническому ряду. Результат — набор "допустимых" интервалов, из которых мы будем строить лады. Затем интервалы нормализуются к октаве, и мы избавляемся от дубликатов.

**Таблица интервалов (пример):**

| Дробь | Центы  | Название интервала            |
| ----- | ------ | ----------------------------- |
| 1//1  | 0      | Унисон                        |
| 3//2  | 701.96 | Квинта                        |
| 5//4  | 386.31 | Большая терция                |
| 7//4  | 968.83 | Малая септима (гармоническая) |
| ...   | ...    | ...                           |

### IV. Генерация ладов: полный перебор

Теперь, вооружившись набором допустимых интервалов, мы можем приступить к самой интересной части — генерации ладов. Мы будем использовать алгоритм полного перебора,  постепенно увеличивая число нот в ладу.

```julia
# ... (определение типов данных Scale, ScaleWithConsonance, ScaleDatabase)

function insert_scale!(scales::Vector{ScaleWithConsonance}, new_scale::Scale, consonance_value::Float64)
    # ... (код функции insert_scale! для добавления лада в коллекцию)
end

function scale_consonance(scale::Scale)::Float64
    # ... (код функции scale_consonance для расчета консонанса лада)
end

function generate_scales(max_notes::Int=7)::ScaleDatabase
    scales_db = ScaleDatabase() # Инициализируем базу данных ладов
    insert_scale!(scales_db[1], [1//1], 1.0) # Добавляем унисон как первый лад

    # Цикл по количеству нот в ладу (от 2 до max_notes)
    for n in 2:max_notes
        new_scales = Vector{ScaleWithConsonance}() # Создаем массив для хранения новых ладов с n нотами

         # Перебираем все лады с n-1 нотами
        for (_, scale) in scales_db[n-1]
            # Перебираем все допустимые интервалы
            for interval in intervals
                # Перебираем все ноты в текущем ладу
                for base_note in scale
                    new_note_up = normalize_to_octave(base_note * interval) # Умножаем на интервал
                    new_note_down = normalize_to_octave(base_note / interval) # Делим на интервал

                    # Проверяем оба варианта новой ноты
                    for new_note in [new_note_up, new_note_down]
                        new_scale = sort(unique([scale; new_note])) # Создаем новый лад

                        # Проверяем, что новая нота уникальна и лад имеет n нот
                        if length(new_scale) == n
                            cons = scale_consonance(new_scale) # Расчитываем консонанс
                            if cons >= MIN_CONSONANCE # Проверяем минимальный консонанс
                                insert_scale!(new_scales, new_scale, cons) # Добавляем лад
                            end
                        end
                    end
                end
            end
        end
        scales_db[n] = new_scales #  Сохраняем новые лады в базе данных
    end

    return scales_db
end

const MAX_NOTES = 8 #  Максимальное количество нот в ладу
const MIN_CONSONANCE = 0.3 #  Минимальный консонанс

scales_db = generate_scales(MAX_NOTES)

#  Вывод результатов (код функции print_scales)
```

Алгоритм начинается с унисона (одна нота) и последовательно строит лады с 2, 3, ... , `MAX_NOTES` нотами. На каждом шаге мы берём все найденные лады с  `n-1` нотами и пробуем добавить к ним ещё одну ноту, используя все допустимые интервалы. Мы умножаем и делим каждую ноту в исходном ладу на каждый интервал, нормализуем результат к октаве и проверяем, что полученная нота уникальна. Затем вычисляем консонанс нового лада и, если он превышает `MIN_CONSONANCE`, добавляем лад в нашу коллекцию. Это полный перебор, который гарантирует, что мы рассмотрим все возможные варианты в пределах заданных ограничений. Вывод результатов покажет нам найденные лады, отсортированные по консонансу. Среди них мы найдём и знакомые нам мажорный лад, мажорное и минорное трезвучия, и множество других.

### V. Исторический экскурс: визуализация строев

Понимание исторического контекста помогает оценить новаторство предлагаемого подхода. Давайте рассмотрим эволюцию музыкальных строев через призму визуализации.

**1. Модальность и натуральный строй (Античность):**

В древности музыка строилась на  модальных ладах,  близких к натуральному строю. Числовые соотношения частот, основанные на простых дробях,  обеспечивали  чистоту созвучий. Визуализировать эти лады можно с помощью схем,  подобных  тем,  что  использовал персидский теоретик Аль-Урвами.

<iframe src="al_urmavi_visualizer.html"></iframe> <comment>Визуализатор ладов в схемах Урмави</comment>

Преимущество натурального строя —  акустическая чистота и выразительность каждого интервала. Например, малая септима может быть представлена как 7/4, 9/5 или 16/9, и эти нюансы можно использовать для создания  богатой  гармонической  палитре.

**2. Пифагоров строй (Средневековье):**

В  Средневековье  получил  распространение  пифагоров  строй,  основанный  на  кварто-квинтовом  круге.

<iframe src="pythagorean_circle_visualizer.html"></iframe> <comment>Визуализатор кварто-квинтового круга</comment>

Математически  этот  строй  можно  представить  через  степени  3/2:

```julia
pythagor = [(3//2)^i for i in -5:5]

for i in -5:5
  println("3//2^$(i) -> $((3//2)^(i))") 
end

# Нормализация к октаве
function normalize_to_octave(ratio::Rational{Int})
    ratio / (2//1)^floor(Int, log2(ratio))
end
pythagor = normalize_to_octave.(pythagor)
println(pythagor)
```

Однако  кварто-квинтовый  круг  содержит  "волчьи  квинты" — диссонирующие  интервалы,  что  ограничивает  гармонические  возможности.

**3. Равномерная темперация (Новое Время):**

Равномерная  темперация,  ставшая  стандартом  в  Новое  время,  решает  проблему  "волчьих  квинт",  но  ценой  потери  акустической  чистоты. Визуализировать  ее  можно  с  помощью  тональной  сетки (Tonnetz).

<iframe src="tonnetz_visualizer.html"></iframe> <comment>Визуализатор Tonnetz</comment>

Математически  тональную  логику  можно  выразить  через  функцию,  генерирующую  мажорные  аккорды:

```julia
major_chord(tonica) = [tonic, tonic*5//4, tonic*3//2]
tonic = 1//1
subdominant_chord = major_chord(tonic * (3//2)^-1)
tonic_chord = major_chord(tonic * (3//2)^0)
dominant_chord = major_chord(tonic * (3//2)^1)
major_scale = vcat(subdominant_chord, tonic_chord, dominant_chord)

# Или ещё проще: 
major_scale = [tonica, tonica*5//4, tonica*3//2] # Строим мажорные аккорды 

sort!(unique!(major_scale))
```

### VI. Унтертоновая полимодальность: новая философия гармонии (продолжение)

Предлагаемый подход — *унтертоновая полимодальность* — сочетает акустическую чистоту с гибкостью в использовании любых нот. Название "унтертоновая"  отражает принцип построения ладов:  каждая нота рассматривается как унтертон по отношению к общей акустической тонике, что предотвращает возникновение конкурирующих тональных центров. Идея заключается в том, что каждый голос может иметь свой лад, при этом все лады "привязаны" к общей акустической тонике. Это позволяет использовать богатую гармоническую палитру, не теряя ощущения тонального центра. Унтертоновая полимодальность открывает удивительные  возможности для композиторов. Мы можем использовать  *любую* ноту, относя её к нужному ладу. Динамика развития гармонии приобретает новую гибкость: переходы между ладами становятся более плавными и не воспринимаются как резкие  модуляции. Однако эта система требует нового мышления о гармонии, основанного на понимании акустических соотношений частот.

```julia
# ... (код для генерации унтертоновых ладов)
```

<pre><code>
# Пример сгенерированных ладов (заглушка, дополнить реальными данными)
[1, 21//20, 7//6, 6//5, 21//16, 7//5, 3//2, 14//9, 7//4, 28//15]
[1, 16//15, 6//5, 4//3, 3//2, 8//5, 16//9]
...
</code></pre>

<iframe src="polymodal_music_example.html"></iframe> <comment>Пример унтертоновой полимодальности в интерактивном приложении</comment>

### VII. Заключение: Гармония как живое пространство

Мы совершили путешествие от древних музыкальных теорий до современных алгоритмов, способных генерировать гармонические структуры. Унтертоновая полимодальность предлагает новый взгляд на гармонию — не как на жёсткий каркас, а как на живое пространство с множеством измерений. Каждый лад — это своеобразный "регион" в этом пространстве, обладающий своей уникальной звуковой палитрой, но связанный с другими регионами через общую акустическую тонику. Этот подход открывает новые возможности для музыкального творчества, позволяя композиторам исследовать неизведанные гармонические миры.

**(В приложении приводится полный код программы, математические выкладки и дополнительные иллюстрации.)**

