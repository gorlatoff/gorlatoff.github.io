## ji_analyzer\8_ji_keyboard.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>JI Analyzer</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="style.css" />
</head>
<body>

<main class="app-compact">
  
  <!-- Controls Row -->
  <div class="controls-bar">
    <div class="control-group">
      <label class="control-label">Odd Limit</label>
      <input type="number" id="maxDenom" value="45" min="1" max="256" class="inp-small">
    </div>
    
    <div class="toggles-row">
      <label class="toggle-compact" title="Floating 1/1 center">
        <input type="checkbox" id="flagAutoTonic" checked>
        <span>Auto 1/1</span>
      </label>
      <label class="toggle-compact" title="Minimize Grid Cover">
        <input type="checkbox" id="flagLCM" checked>
        <span>LCM</span>
      </label>
      <label class="toggle-compact" title="Deep Fundamental">
        <input type="checkbox" id="flagGCD" checked>
        <span>GCD</span>
      </label>
    </div>
    
    <div class="slider-group">
      <label class="slider-label">
        GCD Weight: <span id="gcdWeightVal">1.5</span>
      </label>
      <input type="range" id="gcdWeight" min="0.5" max="3" step="0.1" value="1.5" class="slider-small">
    </div>
    
    <div class="slider-group">
      <label class="slider-label">
        Hysteresis: <span id="hysteresisVal">20%</span>
      </label>
      <input type="range" id="hysteresis" min="0" max="0.5" step="0.05" value="0.2" class="slider-small">
    </div>
  </div>

  <!-- Keyboard -->
  <div class="canvas-container">
    <canvas id="keyboard-canvas"></canvas>
  </div>

  <!-- Analysis Bar -->
  <div class="analysis-bar">
    <div class="analysis-item">
      <span class="analysis-label">Cover (LCM)</span>
      <span id="lcmValue" class="analysis-value">—</span>
    </div>
    <div class="analysis-item">
      <span class="analysis-label">Fundamental (GCD)</span>
      <span id="gcdValue" class="analysis-value">—</span>
      <span id="fundamentalInfo" class="analysis-hz"></span>
    </div>
    <div class="analysis-item interpretation-text">
      <pre id="playedNotes">Click keys or use MIDI</pre>
    </div>
  </div>

  <div class="footer-row">
    <button id="perfButton" class="btn-small">Benchmark</button>
    <span id="perfResult" class="perf-result"></span>
  </div>
  
</main>

<script src="ji-lib.js"></script>
<script src="keyboard.js"></script>
<script src="ji-interpretations.js"></script>
</body>
</html>
```

## ji_analyzer\diff.py

```python
#!/usr/bin/env python3
# applydiff_win.py — Windows-only минималистичный "patch" для unified diff
# Консольное приложение: можно просто вставить текст diff и завершить точкой на отдельной строке.
# Работает в папке, где лежит сам скрипт (root по умолчанию = каталог скрипта).
#
# Возможности:
# - Unified diff (---/+++; @@ хунки; + - ' ' строки)
# - Создание/удаление файлов через /dev/null
# - Сохранение стиля перевода строк; для новых файлов по умолчанию CRLF
# - Поддержка "\ No newline at end of file"
# - Игнорирование служебных строк git diff (diff --git, index, mode, rename ...)
# - Режимы игнорирования пробелов (--ignore-space-change, --ignore-whitespace)
# - Поиск позиции хунков с fuzz и окном поиска (--fuzz, --max-search)
#
# Использование (Windows):
#   1) Вставкой из буфера:
#        python applydiff_win.py
#        (вставьте unified diff)
#        затем введите на новой строке одиночную точку: .  и нажмите Enter
#        (или Ctrl+Z, затем Enter)
#   2) Из файла:
#        python applydiff_win.py change.diff -p 1
#   3) Через конвейер:
#        type change.diff | python applydiff_win.py --dry-run

import sys
import os
import argparse
import re
from typing import List, Tuple, Optional

HUNK_RE = re.compile(r"^@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@")

# Тип строки хунка: (op, text, has_newline)
HunkLine = Tuple[str, str, bool]

class Hunk:
    def __init__(self, ostart, ocnt, nstart, ncnt, lines: List[HunkLine]):
        self.ostart = int(ostart)
        self.ocnt = int(ocnt) if ocnt is not None else 1
        self.nstart = int(nstart)
        self.ncnt = int(ncnt) if ncnt is not None else 1
        self.lines = lines

class FilePatch:
    def __init__(self, src: Optional[str], dst: Optional[str]):
        self.src = src
        self.dst = dst
        self.hunks: List[Hunk] = []

    @property
    def is_delete(self):
        return (self.dst or '').strip() == '/dev/null'

    @property
    def is_create(self):
        return (self.src or '').strip() == '/dev/null'

SKIP_PREFIXES = (
    'diff --git', 'index ', 'new file mode', 'deleted file mode', 'old mode', 'new mode',
    'similarity index', 'rename from', 'rename to', 'copy from', 'copy to'
)


def normalize_path(raw: Optional[str], strip: Optional[int]) -> Optional[str]:
    if raw is None:
        return None
    raw = raw.strip()
    if raw == '/dev/null':
        return '/dev/null'
    if '\t' in raw:
        raw = raw.split('\t', 1)[0]
    path = raw
    if strip is None:
        if path.startswith('a/') or path.startswith('b/'):
            path = path.split('/', 1)[1]
    else:
        for _ in range(strip):
            if '/' in path:
                path = path.split('/', 1)[1]
            else:
                path = ''
                break
    return path


def parse_diff(text: str) -> List[FilePatch]:
    lines = text.splitlines(keepends=False)
    patches: List[FilePatch] = []
    i = 0
    current: Optional[FilePatch] = None
    while i < len(lines):
        line = lines[i]
        if line.startswith(SKIP_PREFIXES):
            i += 1
            continue
        if line.startswith('Binary files ') or line.startswith('GIT binary patch'):
            raise ValueError('Бинарные патчи не поддерживаются')
        if line.startswith('--- '):
            src = line[4:]
            i += 1
            while i < len(lines) and not lines[i].startswith('+++ '):
                if lines[i].startswith(SKIP_PREFIXES) or lines[i].strip() == '':
                    i += 1
                    continue
                break
            if i >= len(lines) or not lines[i].startswith('+++ '):
                raise ValueError('Повреждённый diff: отсутствует +++ после ---')
            dst = lines[i][4:]
            current = FilePatch(src, dst)
            patches.append(current)
            i += 1
            while i < len(lines):
                if lines[i].startswith('@@ '):
                    m = HUNK_RE.match(lines[i])
                    if not m:
                        raise ValueError(f'Повреждённый заголовок хунка: {lines[i]}')
                    ostart, ocnt, nstart, ncnt = m.groups()
                    i += 1
                    h_lines: List[HunkLine] = []
                    last_index = -1
                    while i < len(lines):
                        l = lines[i]
                        if l.startswith('@@ ') or l.startswith('--- '):
                            break
                        if l.startswith(' ') or l.startswith('+') or l.startswith('-'):
                            h_lines.append((l[0], l[1:], True))
                            last_index = len(h_lines) - 1
                        elif l.startswith('\\ No newline at end of file'):
                            if last_index >= 0:
                                op, txt, _ = h_lines[last_index]
                                h_lines[last_index] = (op, txt, False)
                        else:
                            h_lines.append((' ', l, True))
                            last_index = len(h_lines) - 1
                        i += 1
                    current.hunks.append(Hunk(ostart, ocnt, nstart, ncnt, h_lines))
                elif lines[i].startswith('diff ') or lines[i].startswith(SKIP_PREFIXES):
                    i += 1
                elif lines[i].startswith('--- '):
                    break
                else:
                    i += 1
        else:
            i += 1
    return patches


def detect_eol_from_lines(orig_lines: List[str]) -> Optional[str]:
    for s in orig_lines:
        if s.endswith('\r\n'):
            return '\r\n'
        if s.endswith('\n'):
            return '\n'
        if s.endswith('\r'):
            return '\r'
    return None


def choose_new_file_eol(policy: str) -> str:
    if policy == 'lf':
        return '\n'
    if policy == 'crlf':
        return '\r\n'
    if policy == 'cr':
        return '\r'
    return '\r\n'  # Windows по умолчанию


def split_content_and_nl(s: str):
    if s.endswith('\r\n'):
        return s[:-2], True
    if s.endswith('\n'):
        return s[:-1], True
    if s.endswith('\r'):
        return s[:-1], True
    return s, False

class CmpMode:
    NONE = 0
    SPACE_CHANGE = 1
    WHITESPACE = 2


def normalize_for_cmp(s: str, mode: int) -> str:
    s = s.replace('\r', '')
    if mode == CmpMode.NONE:
        return s
    if mode == CmpMode.WHITESPACE:
        return ''.join(ch for ch in s if not ch.isspace())
    out = []
    prev_space = False
    for ch in s:
        if ch.isspace():
            if not prev_space:
                out.append(' ')
                prev_space = True
        else:
            out.append(ch)
            prev_space = False
    return ''.join(out).strip()


def hunk_matches_at(orig_lines: List[str], start_idx: int, h_lines: List[HunkLine], cmp_mode: int):
    idx = start_idx
    for op, txt, _has_nl in h_lines:
        if op == '+':
            continue
        if idx >= len(orig_lines):
            return False, start_idx
        content, _ = split_content_and_nl(orig_lines[idx])
        if normalize_for_cmp(content, cmp_mode) != normalize_for_cmp(txt, cmp_mode):
            return False, start_idx
        idx += 1
    return True, idx


def reduce_hunk_lines(h_lines: List[HunkLine], drop_left_ctx: int, drop_right_ctx: int) -> List[HunkLine]:
    if drop_left_ctx == 0 and drop_right_ctx == 0:
        return h_lines
    ctx_idx = [i for i, (op, _, _) in enumerate(h_lines) if op == ' ']
    to_drop = set()
    for k in range(min(drop_left_ctx, len(ctx_idx))):
        to_drop.add(ctx_idx[k])
    for k in range(1, min(drop_right_ctx, len(ctx_idx)) + 1):
        to_drop.add(ctx_idx[-k])
    return [hl for j, hl in enumerate(h_lines) if j not in to_drop]


def apply_hunks_to_lines(orig_lines: List[str], hunks: List[Hunk], eol_new_file: str, cmp_mode: int, fuzz: int, max_search: Optional[int]) -> List[str]:
    out: List[str] = []
    in_pos = 0
    eol = detect_eol_from_lines(orig_lines) or eol_new_file

    for h in hunks:
        header_pos = max(h.ostart - 1, 0)
        variants = [(0, 0)]
        for f in range(1, max(0, fuzz) + 1):
            for dl in range(0, f + 1):
                dr = f - dl
                variants.append((dl, dr))

        placed = False
        chosen_start = None
        chosen_end_after = None
        chosen_lines: List[HunkLine] = []

        start_search = in_pos
        stop_search = len(orig_lines)
        if max_search is not None:
            start_search = max(in_pos, header_pos - max_search)
            stop_search = min(len(orig_lines), header_pos + max_search)

        for dl, dr in variants:
            reduced = reduce_hunk_lines(h.lines, dl, dr)
            candidates = []
            if header_pos >= start_search and header_pos <= stop_search:
                candidates.append(header_pos)
            for cand in range(start_search, stop_search + 1):
                if cand == header_pos:
                    continue
                candidates.append(cand)
            for cand in candidates:
                ok, end_after = hunk_matches_at(orig_lines, cand, reduced, cmp_mode)
                if ok and cand >= in_pos:
                    placed = True
                    chosen_start = cand
                    chosen_end_after = end_after
                    chosen_lines = reduced
                    break
            if placed:
                break

        if not placed:
            raise ValueError('Не удалось сопоставить хунк (контекст слишком изменился)')

        while in_pos < chosen_start:
            out.append(orig_lines[in_pos])
            in_pos += 1

        idx = in_pos
        for op, txt, has_nl in chosen_lines:
            if op == ' ':
                out.append(orig_lines[idx])
                idx += 1
            elif op == '-':
                idx += 1
            elif op == '+':
                out.append(txt + (eol if has_nl else ''))
            else:
                raise ValueError(f'Неизвестная операция хунка: {op}')
        in_pos = idx

    while in_pos < len(orig_lines):
        out.append(orig_lines[in_pos])
        in_pos += 1

    return out


def read_text_source(diff_path: Optional[str]) -> str:
    if diff_path:
        with open(diff_path, 'r', encoding='utf-8') as f:
            return f.read()
    # Интерактивный ввод: Windows-дружественно — завершаем точкой / EOF / END
    try:
        is_tty = sys.stdin.isatty()
    except Exception:
        is_tty = False
    if is_tty:
        print('Вставьте unified diff ниже. Для завершения введите на новой строке: .  (точка) и нажмите Enter.\nАльтернатива: Ctrl+Z, затем Enter.', file=sys.stderr)
        buf = []
        while True:
            try:
                line = input()
            except EOFError:
                break
            # Сентинелы завершения
            if line in ('.', 'EOF', 'END'):
                break
            buf.append(line + '\n')
        return ''.join(buf)
    # Не TTY — читаем как есть (pipe)
    return sys.stdin.read()


def main():
    if os.name != 'nt':
        print('Этот вариант утилиты рассчитан на Windows (os.name == "nt").', file=sys.stderr)
        return 2

    script_dir = os.path.dirname(os.path.abspath(sys.argv[0]))

    ap = argparse.ArgumentParser(description='Применить unified diff к файлам в папке (Windows, интерактивная вставка текста).')
    ap.add_argument('diff', nargs='?', help='Файл с diff. Если не задан, можно вставить текст вручную.')
    ap.add_argument('-p', '--strip', type=int, default=None, help='Отбросить N компонентов пути (как patch -pN). По умолчанию авто a/ b/.')
    ap.add_argument('--dry-run', action='store_true', help='Сухой прогон: только проверка применимости, без записи файлов.')
    ap.add_argument('--root', default=script_dir, help='Корень применения. По умолчанию: папка, где лежит скрипт.')
    ap.add_argument('--eol', choices=['auto', 'lf', 'crlf', 'cr'], default='crlf', help='Перевод строк для новых файлов (по умолчанию CRLF).')
    ap.add_argument('--ignore-space-change', action='store_true', help='Игнорировать различия в количестве пробелов.')
    ap.add_argument('--ignore-whitespace', action='store_true', help='Игнорировать пробелы полностью при сопоставлении.')
    ap.add_argument('--fuzz', type=int, default=2, help='Допустимый fuzz (отброс контекста) при поиске позиции хунка.')
    ap.add_argument('--max-search', type=int, default=None, help='Ограничить окно поиска позиции хунка (в строках).')

    args = ap.parse_args()

    text = read_text_source(args.diff)

    try:
        patches = parse_diff(text)
    except Exception as e:
        print(f'Ошибка разбора diff: {e}', file=sys.stderr)
        return 1

    if not patches:
        print('Патчи не найдены. Убедитесь, что вы вставили unified diff и завершили ввод точкой (.) или Ctrl+Z, Enter.', file=sys.stderr)
        return 1

    class CmpMode:
        NONE = 0
        SPACE_CHANGE = 1
        WHITESPACE = 2

    cmp_mode = CmpMode.NONE
    if args.ignore_whitespace:
        cmp_mode = CmpMode.WHITESPACE
    elif args.ignore_space_change:
        cmp_mode = CmpMode.SPACE_CHANGE

    failures = 0
    for fp in patches:
        src = normalize_path(fp.src, args.strip)
        dst = normalize_path(fp.dst, args.strip)

        if fp.is_delete:
            target = src
            op = 'delete'
        elif fp.is_create:
            target = dst
            op = 'create'
        else:
            target = dst
            op = 'modify'

        if not target:
            print('[-] Пропуск патча без применимого пути (возможно, /dev/null и слишком большой -p).')
            continue

        full_path = os.path.join(args.root, target)

        if op == 'delete':
            if not os.path.exists(full_path):
                print(f'[skip] {target}: уже отсутствует')
                continue
            if args.dry_run:
                print(f'[dry-run] будет удалён {target}')
            else:
                os.remove(full_path)
                print(f'[ok] удалён {target}')
            continue

        if os.path.exists(full_path):
            with open(full_path, 'r', encoding='utf-8', newline='') as f:
                orig_lines = f.read().splitlines(keepends=True)
        else:
            orig_lines = []
            if not args.dry_run:
                os.makedirs(os.path.dirname(full_path) or '.', exist_ok=True)

        try:
            new_lines = apply_hunks_to_lines(
                orig_lines,
                fp.hunks,
                eol_new_file=choose_new_file_eol(args.eol if args.eol != 'auto' else 'crlf'),
                cmp_mode=cmp_mode,
                fuzz=args.fuzz,
                max_search=args.max_search,
            )
        except Exception as e:
            failures += 1
            print(f'[fail] {target}: {e}', file=sys.stderr)
            continue

        if args.dry_run:
            print(f'[dry-run] будет записан {target} ({len(orig_lines)} → {len(new_lines)} строк)')
        else:
            with open(full_path, 'w', encoding='utf-8', newline='') as f:
                f.writelines(new_lines)
            print(f'[ok] {op} {target} ({len(orig_lines)} → {len(new_lines)} строк)')

    return 0 if failures == 0 else 1


if __name__ == '__main__':
    sys.exit(main())

```

## ji_analyzer\ji-interpretations.js

```javascript
'use strict';

/* ================= CONFIG ================= */
const BEAM_WIDTH = 50;   
const MAX_CANDS = 6;     
const VISUAL_GHOSTS = 3;
const CENTS_THRESHOLD = 35; 
const PRIME_LIMIT = 7;  // Отсекаем 11-limit и выше

// Базовая частота для расчёта Hz (A4 = 440Hz)
const A4_FREQ = 440;
const A4_MIDI = 69;

/**
 * Конвертация частоты в ближайшую MIDI ноту и центы отклонения
 */
function freqToNoteInfo(freq) {
    if (freq <= 0) return null;
    const midiFloat = A4_MIDI + 12 * Math.log2(freq / A4_FREQ);
    const midi = Math.round(midiFloat);
    const cents = Math.round((midiFloat - midi) * 100);
    const octave = Math.floor(midi / 12) - 1;
    const noteName = jiLib.getNoteName(midi);
    return {
        midi,
        noteName,
        octave,
        cents,
        display: `${noteName}${octave}${cents !== 0 ? (cents > 0 ? '+' : '') + cents + '¢' : ''}`
    };
}

const State = {
    allKeys: [],
    playedNotes: [], 
    tonicKeyIndex: null,
    lastTonicIndex: null,  // Для hysteresis
    intervalCandidates: new Map(), 
    
    config: {
        maxOdd: 45,
        autoTonic: true,
        useLCM: true,
        useGCD: true,
        gcdWeight: 1.5,      // Вес GCD (1.0 = равный, 2.0 = GCD вдвое важнее)
        hysteresis: 0.2      // Порог смены тоники (0 = без hysteresis, 0.5 = нужно 50% улучшение)
    }
};

const UI = {
    playedPre: document.getElementById('playedNotes'),
    perfRes: document.getElementById('perfResult'),
    lcmValue: document.getElementById('lcmValue'),
    gcdValue: document.getElementById('gcdValue'),
    fundamentalInfo: document.getElementById('fundamentalInfo'),
    lcmInfo: document.getElementById('lcmInfo'),
    gcdInfo: document.getElementById('gcdInfo'),
    inputs: {
        maxDenom: document.getElementById('maxDenom'),
        autoTonic: document.getElementById('flagAutoTonic'),
        lcm: document.getElementById('flagLCM'),
        gcd: document.getElementById('flagGCD'),
        gcdWeight: document.getElementById('gcdWeight'),
        gcdWeightVal: document.getElementById('gcdWeightVal'),
        hysteresis: document.getElementById('hysteresis'),
        hysteresisVal: document.getElementById('hysteresisVal'),
        perfBtn: document.getElementById('perfButton')
    }
};

/* ================= INIT ================= */

function init() {
    if (window.Keyboard) {
        Keyboard.init('keyboard-canvas', 2, 3, {
            onToggleKey: () => scheduleUpdate(),
            onSetTonic: (idx) => { 
                State.tonicKeyIndex = idx;
                State.lastTonicIndex = idx;
                scheduleUpdate(); 
            }
        });
        State.allKeys = Keyboard.allKeys;
    }

    UI.inputs.maxDenom.addEventListener('change', () => { 
        generateCandidates(); 
        scheduleUpdate(); 
    });
    
    UI.inputs.autoTonic.addEventListener('change', () => {
        if (UI.inputs.autoTonic.checked) {
            State.allKeys.forEach(k => k.isTonic = false);
            State.tonicKeyIndex = null;
        }
        scheduleUpdate();
    });
    
    UI.inputs.lcm.addEventListener('change', scheduleUpdate);
    UI.inputs.gcd.addEventListener('change', scheduleUpdate);
    
    // GCD Weight slider
    if (UI.inputs.gcdWeight) {
        UI.inputs.gcdWeight.addEventListener('input', () => {
            State.config.gcdWeight = parseFloat(UI.inputs.gcdWeight.value);
            if (UI.inputs.gcdWeightVal) {
                UI.inputs.gcdWeightVal.textContent = State.config.gcdWeight.toFixed(1);
            }
            scheduleUpdate();
        });
    }
    
    // Hysteresis slider
    if (UI.inputs.hysteresis) {
        UI.inputs.hysteresis.addEventListener('input', () => {
            State.config.hysteresis = parseFloat(UI.inputs.hysteresis.value);
            if (UI.inputs.hysteresisVal) {
                UI.inputs.hysteresisVal.textContent = Math.round(State.config.hysteresis * 100) + '%';
            }
            scheduleUpdate();
        });
    }
    
    if (UI.inputs.perfBtn) {
        UI.inputs.perfBtn.addEventListener('click', runBenchmark);
    }

    generateCandidates();
    scheduleUpdate();
}

/* ================= DEBOUNCED UPDATE ================= */

let pendingUpdate = false;

function scheduleUpdate() {
    if (!pendingUpdate) {
        pendingUpdate = true;
        requestAnimationFrame(() => {
            pendingUpdate = false;
            update();
        });
    }
}

/* ================= GENERATION ================= */

function generateCandidates() {
    State.intervalCandidates.clear();
    const maxOdd = parseInt(UI.inputs.maxDenom.value) || 45;
    State.config.maxOdd = maxOdd;

    for (let d = 1; d <= maxOdd; d++) {
        for (let n = d; n < d * 2; n++) { 
            if (jiLib.getOddPart(n) > maxOdd || jiLib.getOddPart(d) > maxOdd) continue;
            if (jiLib.gcd(n, d) !== 1) continue;
            
            // Prime Limit фильтр
            const maxPrime = Math.max(jiLib.getMaxPrime(n), jiLib.getMaxPrime(d));
            if (maxPrime > PRIME_LIMIT) continue;

            const cents = jiLib.ratioToCents({num: n, den: d});
            let step = Math.round(cents / 100);
            const deviation = Math.abs(cents - step * 100);
            
            if (deviation > CENTS_THRESHOLD) continue;
            if (step === 12) step = 0;

            if (!State.intervalCandidates.has(step)) State.intervalCandidates.set(step, []);
            
            const list = State.intervalCandidates.get(step);
            const exists = list.some(c => c.num === n && c.den === d);
            
            if (!exists) {
                list.push({ 
                    num: n, 
                    den: d, 
                    weight: jiLib.eulerGradus(n, d) 
                });
            }
        }
    }

    for (let [s, arr] of State.intervalCandidates) {
        arr.sort((a, b) => a.weight - b.weight);
        if (arr.length > MAX_CANDS) arr.length = MAX_CANDS; 
    }
}

/* ================= UPDATE LOOP ================= */

function update() {
    State.config.autoTonic = UI.inputs.autoTonic.checked;
    State.config.useLCM = UI.inputs.lcm.checked;
    State.config.useGCD = UI.inputs.gcd.checked;

    State.playedNotes = State.allKeys
        .map((k, i) => ({ k, i, midi: k.midiNote }))
        .filter(obj => obj.k.isActive)
        .map(obj => ({
            keyIndex: obj.i,
            midi: obj.midi,
            step: obj.k.edoStep
        }));

    let tonicOptions = [];
    if (State.config.autoTonic) {
        if (State.playedNotes.length > 0) {
            tonicOptions = State.playedNotes.map(n => n.keyIndex);
        } else if (State.tonicKeyIndex !== null) {
            tonicOptions = [State.tonicKeyIndex];
        }
    } else {
        if (State.tonicKeyIndex !== null) {
            tonicOptions = [State.tonicKeyIndex];
        } else {
            applyVisuals(new Map());
            updateLCMGCDDisplay(null, null, null);
            if (UI.playedPre) UI.playedPre.textContent = "Right-click to set tonic";
            if (window.Keyboard) {
                Keyboard.hintData = { colors: [], lcmKeys: [], gcdKeys: [] };
            }
            return;
        }
    }

    let result = { 
        map: new Map(), 
        score: 1.0, 
        tonicIndex: null, 
        analysisMap: new Map(),
        lcmValue: null,
        gcdValue: null,
        gcdHz: null,
        lcmHz: null,
        lcmKeys: [],
        gcdKeys: []
    };
    
    if (tonicOptions.length > 0) {
        result = solveGlobal(State.playedNotes, tonicOptions);
    }

    renderText(result.map, result.tonicIndex);
    updateLCMGCDDisplay(result);
    
    const { visualData, hintColors } = mapAnalysisToVisuals(result.analysisMap, result.map, result.tonicIndex);
    applyVisuals(visualData);
    
    // Передаём hint data в Keyboard
    if (window.Keyboard) {
        Keyboard.hintData = {
            colors: hintColors,
            lcmKeys: result.lcmKeys || [],
            gcdKeys: result.gcdKeys || []
        };
    }
}

/* ================= LCM/GCD DISPLAY ================= */

function updateLCMGCDDisplay(result) {
    if (UI.lcmValue) {
        UI.lcmValue.textContent = (result.lcmValue !== null) ? result.lcmValue : '—';
    }
    if (UI.gcdValue) {
        UI.gcdValue.textContent = (result.gcdValue !== null) ? result.gcdValue : '—';
    }
    
    // LCM info (Cover - высокая нота)
    if (UI.lcmInfo) {
        if (result.lcmHz !== null) {
            const noteInfo = freqToNoteInfo(result.lcmHz);
            UI.lcmInfo.textContent = noteInfo 
                ? `${result.lcmHz.toFixed(1)}Hz ≈ ${noteInfo.display}`
                : `${result.lcmHz.toFixed(1)}Hz`;
        } else {
            UI.lcmInfo.textContent = '';
        }
    }
    
    // GCD info (Fundamental - низкая нота)  
    if (UI.gcdInfo) {
        if (result.gcdHz !== null) {
            const noteInfo = freqToNoteInfo(result.gcdHz);
            UI.gcdInfo.textContent = noteInfo 
                ? `${result.gcdHz.toFixed(1)}Hz ≈ ${noteInfo.display}`
                : `${result.gcdHz.toFixed(1)}Hz`;
        } else {
            UI.gcdInfo.textContent = '';
        }
    }
}

/* ================= VISUAL MAPPING ================= */

function mapAnalysisToVisuals(analysisMap, solutionMap, tonicIndex) {
    const visuals = new Map();
    const hintColors = new Array(State.allKeys.length).fill(null);

    analysisMap.forEach((candidatesData, keyIndex) => {
        if (!candidatesData || candidatesData.length === 0) return;

        const isActive = State.allKeys[keyIndex].isActive;
        const isTonic = (keyIndex === tonicIndex);
        
        // Лучший score
        let minScore = Infinity;
        for (const c of candidatesData) {
            if (c.score < minScore) minScore = c.score;
        }

        // Hint color для ВСЕХ клавиш (и активных, и неактивных)
        const best = candidatesData[0];
        const gradus = jiLib.eulerGradus(best.num, best.den);
        // Hue: 120 (зелёный) для простых, 0 (красный) для сложных
        const hue = Math.max(0, Math.min(120, 120 - (gradus - 3) * 8));
        // Alpha: активные ярче, неактивные тусклее
        let alpha = isActive ? 0.85 : 0.45;
        if (isTonic) alpha = 1.0;
        hintColors[keyIndex] = { hue, alpha };

        const items = candidatesData.map((c, idx) => {
            const isSelected = solutionMap.has(keyIndex) && 
                (solutionMap.get(keyIndex).num === c.num && 
                 solutionMap.get(keyIndex).den === c.den);

            let alpha = 0;

            if (isSelected) {
                alpha = 1.0;
            } else if (isActive) {
                // Альтернативы для активных нот
                if (idx < 4) {
                    const ratio = (minScore > 0 && c.score > 0) ? minScore / c.score : 1;
                    alpha = 0.25 + 0.35 * ratio;
                }
            } else {
                // Призраки
                if (idx < VISUAL_GHOSTS) {
                    const ratio = (minScore > 0 && c.score > 0) ? minScore / c.score : 1;
                    alpha = 0.4 * Math.pow(ratio, 2);
                }
            }

            if (alpha < 0.08) alpha = 0;

            return { num: c.num, den: c.den, alpha: alpha };
        });

        visuals.set(keyIndex, items);
    });

    return { visualData: visuals, hintColors };
}

/* ================= SOLVER ================= */

function solveGlobal(notes, possibleTonics) {
    let bestGlobalScore = Infinity;
    let bestGlobalMap = new Map();
    let bestTonicIdx = null;
    let bestLCM = null;
    let bestGCD = null;
    let gcdHz = null;
    let lcmHz = null;
    let lcmKeys = [];
    let gcdKeys = [];
    
    const activeTonics = (notes.length === 0 && possibleTonics.length > 0) 
        ? [possibleTonics[0]] 
        : possibleTonics;

    // Сохраняем score текущей тоники для hysteresis
    let currentTonicScore = Infinity;

    for (let tIdx of activeTonics) {
        const tonicKey = State.allKeys[tIdx];
        if (!tonicKey) continue;

        const problemSpace = notes.map(n => {
            if (n.keyIndex === tIdx) return [{ num: 1, den: 1, key: n.keyIndex }];
            
            const relStep = (n.step - tonicKey.edoStep + 12) % 12;
            const octShift = Math.floor((n.midi - tonicKey.midiNote) / 12);
            const rawCands = State.intervalCandidates.get(relStep) || [];
            
            if (rawCands.length === 0) return [{ num: 1, den: 1, key: n.keyIndex }];

            return rawCands.map(c => {
                const r = jiLib.adjustRatioOctave({num: c.num, den: c.den}, octShift);
                return { num: r.num, den: r.den, key: n.keyIndex };
            });
        });

        if (problemSpace.length === 0) {
            if (1 < bestGlobalScore) {
                bestGlobalScore = 1;
                bestTonicIdx = tIdx;
                bestGlobalMap = new Map();
            }
            continue;
        }

        // Beam Search
        let beam = [{ ratios: [], score: 1 }]; 
        for (let i = 0; i < problemSpace.length; i++) {
            const layerCands = problemSpace[i];
            const nextBeam = [];
            for (let beamNode of beam) {
                for (let cand of layerCands) {
                    const newRatios = [...beamNode.ratios, cand];
                    const complexity = jiLib.computeWeightedComplexity(
                        newRatios, 
                        State.config.useLCM, 
                        State.config.useGCD,
                        State.config.gcdWeight
                    );
                    nextBeam.push({ ratios: newRatios, score: complexity });
                }
            }
            nextBeam.sort((a, b) => a.score - b.score);
            beam = nextBeam.slice(0, BEAM_WIDTH);
        }

        if (beam.length > 0) {
            const bestLocal = beam[0];
            
            // Hysteresis: если это текущая тоника, сохраняем её score
            if (tIdx === State.lastTonicIndex) {
                currentTonicScore = bestLocal.score;
            }
            
            if (bestLocal.score < bestGlobalScore) {
                bestGlobalScore = bestLocal.score;
                bestTonicIdx = tIdx;
                const m = new Map();
                bestLocal.ratios.forEach(r => m.set(r.key, r));
                bestGlobalMap = m;
            }
        }
    }

    // Hysteresis: не менять тонику если улучшение меньше порога
    if (State.lastTonicIndex !== null && 
        bestTonicIdx !== State.lastTonicIndex && 
        State.config.hysteresis > 0) {
        
        const improvement = 1 - (bestGlobalScore / currentTonicScore);
        if (improvement < State.config.hysteresis && currentTonicScore < Infinity) {
            // Возвращаем старую тонику
            bestTonicIdx = State.lastTonicIndex;
            // Пересчитываем map для старой тоники
            const oldResult = solveForTonic(notes, State.lastTonicIndex);
            bestGlobalMap = oldResult.map;
            bestGlobalScore = oldResult.score;
        }
    }
    
    // Обновляем lastTonicIndex
    if (bestTonicIdx !== null) {
        State.lastTonicIndex = bestTonicIdx;
    }

    // Compute LCM/GCD для отображения
    if (bestGlobalMap.size > 0 && bestTonicIdx !== null) {
        const ratios = Array.from(bestGlobalMap.values());
        const nums = ratios.map(r => r.num);
        const dens = ratios.map(r => r.den);
        bestLCM = jiLib.lcmArray(nums);
        bestGCD = jiLib.gcdArray(dens);
        
        // Частота тоники
        const tonicMidi = State.allKeys[bestTonicIdx].midiNote;
        const tonicHz = A4_FREQ * Math.pow(2, (tonicMidi - A4_MIDI) / 12);
        
        // GCD (Fundamental) - низкая нота: тоника / LCM(nums)
        // Это частота, где все числители совпадают
        gcdHz = tonicHz / bestLCM;
        
        // LCM (Cover) - высокая нота: тоника * LCM(nums) / GCD(nums)
        // Упрощаем: показываем период = тоника * LCM / GCD
        const gcdNums = jiLib.gcdArray(nums);
        lcmHz = tonicHz * bestLCM / gcdNums;
        
        // Находим клавиши, соответствующие этим частотам (в пределах клавиатуры)
        gcdKeys = findKeysForFreq(gcdHz);
        lcmKeys = findKeysForFreq(lcmHz);
    }

    // Contextual Analysis
    const analysisMap = new Map();

    if (bestTonicIdx !== null) {
        const tonicKey = State.allKeys[bestTonicIdx];
        const optimalRatios = Array.from(bestGlobalMap.values());

        for (let i = 0; i < State.allKeys.length; i++) {
            const key = State.allKeys[i];
            
            if (i === bestTonicIdx) {
                analysisMap.set(i, [{num: 1, den: 1, score: bestGlobalScore}]);
                continue;
            }

            const relStep = (key.edoStep - tonicKey.edoStep + 12) % 12;
            const octShift = Math.floor((key.midiNote - tonicKey.midiNote) / 12);
            const rawCands = State.intervalCandidates.get(relStep);

            if (!rawCands || rawCands.length === 0) continue;

            let context = optimalRatios;
            if (bestGlobalMap.has(i)) {
                context = optimalRatios.filter(r => r.key !== i);
            }

            const scoredCands = rawCands.map(c => {
                const r = jiLib.adjustRatioOctave({num: c.num, den: c.den}, octShift);
                const testSet = [...context, { num: r.num, den: r.den }];
                const score = jiLib.computeWeightedComplexity(
                    testSet, 
                    State.config.useLCM, 
                    State.config.useGCD,
                    State.config.gcdWeight
                );
                return { num: r.num, den: r.den, score: score };
            });

            analysisMap.set(i, scoredCands);
        }
    }

    return { 
        map: bestGlobalMap, 
        score: bestGlobalScore, 
        tonicIndex: bestTonicIdx,
        analysisMap: analysisMap,
        lcmValue: bestLCM,
        gcdValue: bestGCD,
        gcdHz: gcdHz,
        lcmHz: lcmHz,
        lcmKeys: lcmKeys,
        gcdKeys: gcdKeys
    };
}

/**
 * Найти индексы клавиш, соответствующих частоте (во всех октавах)
 */
function findKeysForFreq(freq) {
    if (!freq || freq <= 0) return [];
    
    const keys = [];
    const midiFloat = A4_MIDI + 12 * Math.log2(freq / A4_FREQ);
    const baseMidi = Math.round(midiFloat);
    const step = baseMidi % 12;
    
    // Находим все клавиши с этим step
    State.allKeys.forEach((key, idx) => {
        if (key.edoStep === step) {
            keys.push(idx);
        }
    });
    
    return keys;
}

/**
 * Вспомогательная функция для пересчёта с конкретной тоникой
 */
function solveForTonic(notes, tonicIdx) {
    const tonicKey = State.allKeys[tonicIdx];
    if (!tonicKey) return { map: new Map(), score: Infinity };

    const problemSpace = notes.map(n => {
        if (n.keyIndex === tonicIdx) return [{ num: 1, den: 1, key: n.keyIndex }];
        
        const relStep = (n.step - tonicKey.edoStep + 12) % 12;
        const octShift = Math.floor((n.midi - tonicKey.midiNote) / 12);
        const rawCands = State.intervalCandidates.get(relStep) || [];
        
        if (rawCands.length === 0) return [{ num: 1, den: 1, key: n.keyIndex }];

        return rawCands.map(c => {
            const r = jiLib.adjustRatioOctave({num: c.num, den: c.den}, octShift);
            return { num: r.num, den: r.den, key: n.keyIndex };
        });
    });

    if (problemSpace.length === 0) {
        return { map: new Map(), score: 1 };
    }

    let beam = [{ ratios: [], score: 1 }]; 
    for (let i = 0; i < problemSpace.length; i++) {
        const layerCands = problemSpace[i];
        const nextBeam = [];
        for (let beamNode of beam) {
            for (let cand of layerCands) {
                const newRatios = [...beamNode.ratios, cand];
                const complexity = jiLib.computeWeightedComplexity(
                    newRatios, 
                    State.config.useLCM, 
                    State.config.useGCD,
                    State.config.gcdWeight
                );
                nextBeam.push({ ratios: newRatios, score: complexity });
            }
        }
        nextBeam.sort((a, b) => a.score - b.score);
        beam = nextBeam.slice(0, BEAM_WIDTH);
    }

    if (beam.length > 0) {
        const m = new Map();
        beam[0].ratios.forEach(r => m.set(r.key, r));
        return { map: m, score: beam[0].score };
    }
    
    return { map: new Map(), score: Infinity };
}

/* ================= BENCHMARK ================= */

function runBenchmark() {
    if (UI.perfRes) UI.perfRes.textContent = "Running...";
    const mockNotes = [
        { keyIndex: 0, midi: 48, step: 0 },
        { keyIndex: 4, midi: 52, step: 4 },
        { keyIndex: 7, midi: 55, step: 7 },
        { keyIndex: 10, midi: 58, step: 10 },
        { keyIndex: 14, midi: 62, step: 2 }
    ];
    const tonicOpts = [0, 4, 7, 10, 14];

    setTimeout(() => {
        const t0 = performance.now();
        for(let i = 0; i < 100; i++) solveGlobal(mockNotes, tonicOpts);
        const dt = performance.now() - t0;
        if (UI.perfRes) UI.perfRes.textContent = `${(dt/100).toFixed(2)}ms avg`;
    }, 50);
}

/* ================= UI UTILS ================= */

function renderText(map, tonicIdx) {
    if (!UI.playedPre) return;
    
    if (map.size === 0) {
        UI.playedPre.textContent = "Click keys or use MIDI";
        return;
    }
    
    // Упрощённый вывод: только тоника и количество нот
    if (tonicIdx !== null) {
        const tonicName = jiLib.getNoteName(State.allKeys[tonicIdx].midiNote);
        const octave = State.allKeys[tonicIdx].octave;
        UI.playedPre.textContent = `Tonic: ${tonicName}${octave} | Notes: ${map.size}`;
    } else {
        UI.playedPre.textContent = `Notes: ${map.size}`;
    }
}

function applyVisuals(data) {
    State.allKeys.forEach((k, i) => {
        k.jiRatios = data.get(i) || [];
    });
}

// Start
init();
```

## ji_analyzer\ji-lib.js

```javascript
(function(global) {
  'use strict';

  /* --- MATH CORE --- */
  
  function gcd(a, b) {
    a = Math.abs(a); b = Math.abs(b);
    while (b) { let t = b; b = a % b; a = t; }
    return a;
  }

  function lcm(a, b) {
    if (a === 0 || b === 0) return 0;
    const prod = Math.abs(a * b);
    return prod / gcd(a, b);
  }

  function gcdArray(arr) {
    if (!arr.length) return 1;
    let r = arr[0];
    for (let i = 1; i < arr.length; i++) r = gcd(r, arr[i]);
    return r;
  }

  function lcmArray(arr) {
    if (!arr.length) return 1;
    let r = arr[0];
    for (let i = 1; i < arr.length; i++) {
        r = lcm(r, arr[i]);
        if (r > 1e14) return r; 
    }
    return r;
  }

  function getOddPart(n) {
    n = Math.abs(n);
    if (n === 0) return 0;
    while ((n & 1) === 0) n >>= 1; 
    return n;
  }

  /* --- PRIMES & EULER --- */

  const primeCache = new Map();

  function getPrimeFactors(n) {
    if (n === 1) return {};
    if (primeCache.has(n)) return primeCache.get(n);

    const factors = {};
    let d = 2;
    let temp = n;
    while (d * d <= temp) {
      while (temp % d === 0) {
        factors[d] = (factors[d] || 0) + 1;
        temp /= d;
      }
      d++;
    }
    if (temp > 1) factors[temp] = (factors[temp] || 0) + 1;
    
    if (n < 10000) primeCache.set(n, factors);
    return factors;
  }

  /**
   * Максимальный простой делитель числа
   */
  function getMaxPrime(n) {
    if (n <= 1) return 1;
    const factors = getPrimeFactors(n);
    const primes = Object.keys(factors).map(Number);
    return primes.length > 0 ? Math.max(...primes) : 1;
  }

  /**
   * Euler's Gradus Suavitatis
   * Чем МЕНЬШЕ, тем консонантнее
   */
  function eulerGradus(n, d) {
    const val = n * d;
    const factors = getPrimeFactors(val);
    let gradus = 1;
    
    for (let p in factors) {
        const k = factors[p];
        const prime = parseInt(p);
        gradus += (prime - 1) * k;
    }
    return gradus;
  }

  /* --- RATIO TOOLS --- */

  function createRatio(num, den) {
    if (!Number.isFinite(num) || !Number.isFinite(den) || den === 0) return { num: 1, den: 1 };
    const c = gcd(num, den);
    return { num: Math.abs(num/c), den: Math.abs(den/c) };
  }

  function adjustRatioOctave(r, shift) {
    let n = r.num;
    let d = r.den;
    if (shift > 0) n *= Math.pow(2, shift);
    else if (shift < 0) d *= Math.pow(2, Math.abs(shift));
    return createRatio(n, d);
  }

  function forceRatioToKey(r, semitoneDist) {
    const val = r.num / r.den;
    const currentCents = 1200 * Math.log2(val);
    const targetCents = semitoneDist * 100;
    const diff = targetCents - currentCents;
    const shifts = Math.round(diff / 1200);
    return adjustRatioOctave(r, shifts);
  }

  /* --- COMPLEXITY --- */

  /**
   * @param {Array} ratios - массив {num, den}
   * @param {boolean} useLCM - учитывать LCM factor
   * @param {boolean} useGCD - учитывать GCD factor
   * @param {boolean} ignoreOctaves - игнорировать степени 2
   */
  function computeComplexity(ratios, useLCM, useGCD, ignoreOctaves = false) {
    if (ratios.length === 0) return 1;
    
    const nums = [];
    const dens = [];
    for (let i = 0; i < ratios.length; i++) {
        nums.push(ignoreOctaves ? getOddPart(ratios[i].num) : ratios[i].num);
        dens.push(ignoreOctaves ? getOddPart(ratios[i].den) : ratios[i].den);
    }

    let complexity = 1.0;

    if (useLCM) {
        const lNum = lcmArray(nums);
        const lDen = gcdArray(dens);
        complexity *= (lDen === 0 ? 9999 : lNum / lDen);
    }

    if (useGCD) {
        const gNum = gcdArray(nums);
        const gDen = lcmArray(dens);
        complexity *= (gNum === 0 ? 9999 : gDen / gNum);
    }
    
    return complexity;
  }

  /**
   * Расширенная метрика с настраиваемым весом GCD
   * @param {number} gcdWeight - вес GCD (1.0 = равный, 2.0 = GCD вдвое важнее)
   */
  function computeWeightedComplexity(ratios, useLCM, useGCD, gcdWeight = 1.0) {
    if (ratios.length === 0) return 1;
    
    const nums = ratios.map(r => r.num);
    const dens = ratios.map(r => r.den);

    let complexity = 1.0;

    if (useLCM) {
        const lNum = lcmArray(nums);
        const lDen = gcdArray(dens);
        complexity *= (lDen === 0 ? 9999 : lNum / lDen);
    }

    if (useGCD) {
        const gNum = gcdArray(nums);
        const gDen = lcmArray(dens);
        const gcdFactor = (gNum === 0 ? 9999 : gDen / gNum);
        complexity *= Math.pow(gcdFactor, gcdWeight);
    }
    
    return complexity;
  }

  /* --- EXPORTS --- */
  
  global.jiLib = {
    gcd, lcm, gcdArray, lcmArray, getOddPart,
    createRatio, forceRatioToKey, adjustRatioOctave,
    computeComplexity, computeWeightedComplexity,
    eulerGradus, getPrimeFactors, getMaxPrime,
    
    ratioToCents: (r) => 1200 * Math.log2(r.num / r.den),
    getNoteName: (m) => ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'][m % 12]
  };

})(window);
```

## ji_analyzer\keyboard.js

```javascript
// keyboard.js — клавиатура: генерация, прорисовка, полигоны, mouse/MIDI
// Экспортирует глобально: Keyboard

(function(global){
  'use strict';

  const X_SCALE = 50;
  const Y_SCALE = 100;
  const WHITE_KEY_HEIGHT = 2;
  const BLACK_KEY_RELATIVE_HEIGHT = 0.8;
  const HINT_BAR_HEIGHT = 12;  // Высота подсказочной панели в пикселях

  const Keyboard = {
    allKeys: [],
    canvas: null,
    ctx: null,
    
    colorMode: false,
    
    // Данные для hint bar (передаются из ji-interpretations)
    hintData: {
      colors: [],    // [{hue, alpha}, ...] для каждой клавиши
      lcmKeys: [],   // Индексы клавиш для LCM маркера
      gcdKeys: []    // Индексы клавиш для GCD маркера
    },
    
    callbacks: {
      onToggleKey: null,
      onSetTonic: null
    },
    
    init(canvasId, octaves = 2, startOctave = 3, callbacks = {}) {
      this.canvas = document.getElementById(canvasId);
      if (!this.canvas) throw new Error('Canvas not found: ' + canvasId);
      this.ctx = this.canvas.getContext('2d');
      this.callbacks.onToggleKey = callbacks.onToggleKey || function(){};
      this.callbacks.onSetTonic = callbacks.onSetTonic || function(){};

      this.allKeys = this.generateKeys(octaves, startOctave);
      this.resizeCanvas();
      this.buildPolygons();
      this.setupListeners();
      this.loop();
      this.initWebMIDI();
    },

    generateKeys(octaves, startOctave){
      const base = [
        { note:'C', isBlack:false, midiOffset:0 },
        { note:'C#', isBlack:true, midiOffset:1 },
        { note:'D', isBlack:false, midiOffset:2 },
        { note:'D#', isBlack:true, midiOffset:3 },
        { note:'E', isBlack:false, midiOffset:4 },
        { note:'F', isBlack:false, midiOffset:5 },
        { note:'F#', isBlack:true, midiOffset:6 },
        { note:'G', isBlack:false, midiOffset:7 },
        { note:'G#', isBlack:true, midiOffset:8 },
        { note:'A', isBlack:false, midiOffset:9 },
        { note:'A#', isBlack:true, midiOffset:10 },
        { note:'B', isBlack:false, midiOffset:11 }
      ];
      const keys = [];
      for (let o = 0; o < octaves; o++){
        base.forEach(b => {
          const midiNote = 12 * (startOctave + o) + b.midiOffset;
          keys.push({ 
            ...b, 
            midiNote, 
            edoStep: b.midiOffset, 
            octave: startOctave + o, 
            isActive: false, 
            isTonic: false,
            jiRatios: [] 
          });
        });
      }
      // Завершающая C
      keys.push({ 
        note:'C', isBlack:false, midiOffset:0, 
        midiNote: 12*(startOctave+octaves), 
        edoStep:0, octave:startOctave+octaves, 
        isActive:false, isTonic:false, jiRatios:[] 
      });
      return keys;
    },

    resizeCanvas(){
      if (!this.canvas) return;
      const logicalWidth = this.allKeys.length * X_SCALE;
      const keyboardHeight = Math.max(WHITE_KEY_HEIGHT, BLACK_KEY_RELATIVE_HEIGHT * WHITE_KEY_HEIGHT) * Y_SCALE;
      this.canvas.width = logicalWidth;
      this.canvas.height = HINT_BAR_HEIGHT + keyboardHeight;
      
      const dpr = window.devicePixelRatio || 1;
      if (dpr > 1) {
        const sw = this.canvas.width, sh = this.canvas.height;
        this.canvas.style.width = sw + 'px';
        this.canvas.style.height = sh + 'px';
        this.canvas.width = sw * dpr;
        this.canvas.height = sh * dpr;
        this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      } else {
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
      }
    },

    buildPolygons(){
      this.allKeys.forEach((key, i) => {
        if (key.isBlack) {
          key.polygon = [
            { x: i, y: 0 }, 
            { x: i + 1, y: 0 }, 
            { x: i + 1, y: BLACK_KEY_RELATIVE_HEIGHT * WHITE_KEY_HEIGHT }, 
            { x: i, y: BLACK_KEY_RELATIVE_HEIGHT * WHITE_KEY_HEIGHT }
          ];
        } else {
          let l = 0, r = 0;
          if (i > 0 && this.allKeys[i - 1].isBlack) l = 0.5;
          if (i < this.allKeys.length - 1 && this.allKeys[i + 1].isBlack) r = 0.5;
          key.polygon = [
            { x: i, y: 0 }, 
            { x: i + 1, y: 0 }, 
            { x: i + 1, y: 1 }, 
            { x: i + 1 + r, y: 1 }, 
            { x: i + 1 + r, y: WHITE_KEY_HEIGHT }, 
            { x: i - l, y: WHITE_KEY_HEIGHT }, 
            { x: i - l, y: 1 }, 
            { x: i, y: 1 }
          ];
        }
      });
    },

    draw(){
      const ctx = this.ctx;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      
      // Рисуем hint bar сначала
      this.drawHintBar();
      
      // Белые клавиши
      this.allKeys.forEach((k, i) => { if (!k.isBlack) this.drawKey(k, i); });
      // Чёрные сверху
      this.allKeys.forEach((k, i) => { if (k.isBlack) this.drawKey(k, i); });
    },

    drawHintBar() {
      const ctx = this.ctx;
      const colors = this.hintData.colors || [];
      
      // Фон панели
      ctx.fillStyle = '#11111b';
      ctx.fillRect(0, 0, this.allKeys.length * X_SCALE, HINT_BAR_HEIGHT);
      
      // Цветовые подсказки для каждой клавиши
      this.allKeys.forEach((key, i) => {
        const hint = colors[i];
        if (!hint || hint.alpha < 0.05) return;
        
        const x = i * X_SCALE;
        const width = X_SCALE;
        
        ctx.fillStyle = `hsla(${hint.hue}, 70%, 50%, ${hint.alpha})`;
        ctx.fillRect(x + 1, 1, width - 2, HINT_BAR_HEIGHT - 2);
      });
      
      // GCD маркеры (синий ромб) - Fundamental
      const gcdKeys = this.hintData.gcdKeys || [];
      gcdKeys.forEach(i => {
        if (i < 0 || i >= this.allKeys.length) return;
        const x = i * X_SCALE + X_SCALE / 2;
        const y = HINT_BAR_HEIGHT / 2;
        
        ctx.beginPath();
        ctx.moveTo(x, y - 5);
        ctx.lineTo(x + 5, y);
        ctx.lineTo(x, y + 5);
        ctx.lineTo(x - 5, y);
        ctx.closePath();
        ctx.fillStyle = '#89b4fa';
        ctx.fill();
        ctx.strokeStyle = '#1e1e2e';
        ctx.lineWidth = 1;
        ctx.stroke();
      });
      
      // LCM маркеры (жёлтый треугольник вверх) - Cover
      const lcmKeys = this.hintData.lcmKeys || [];
      lcmKeys.forEach(i => {
        if (i < 0 || i >= this.allKeys.length) return;
        const x = i * X_SCALE + X_SCALE / 2;
        ctx.beginPath();
        ctx.moveTo(x, HINT_BAR_HEIGHT - 2);
        ctx.lineTo(x + 5, 3);
        ctx.lineTo(x - 5, 3);
        ctx.closePath();
        ctx.fillStyle = '#f9e2af';
        ctx.fill();
      });
    },

    getRatioColor(ratio, isBlack, alpha) {
      if (!this.colorMode) {
        const baseColor = isBlack ? [255, 255, 255] : [0, 0, 0];
        return `rgba(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]}, ${alpha})`;
      }
      
      const gradus = jiLib.eulerGradus(ratio.num, ratio.den);
      const hue = Math.max(0, 120 - (gradus - 1) * 5);
      const sat = 80;
      const light = isBlack ? 65 : 40;
      
      return `hsla(${hue}, ${sat}%, ${light}%, ${alpha})`;
    },

    drawKey(key, idx){
      const ctx = this.ctx;
      const isTonic = key.isTonic;
      
      // Смещаем всё вниз на высоту hint bar
      const poly = key.polygon.map(p => ({ x: p.x * X_SCALE, y: p.y * Y_SCALE + HINT_BAR_HEIGHT }));
      
      ctx.beginPath();
      ctx.moveTo(poly[0].x, poly[0].y);
      poly.forEach((p) => ctx.lineTo(p.x, p.y));
      ctx.closePath();
      
      // Градиент фона
      if (key.isBlack) {
        const g = ctx.createLinearGradient(0, poly[0].y, 0, poly[2].y); 
        g.addColorStop(0, '#444'); 
        g.addColorStop(1, '#000'); 
        ctx.fillStyle = g;
      } else {
        const g = ctx.createLinearGradient(0, HINT_BAR_HEIGHT, 0, HINT_BAR_HEIGHT + WHITE_KEY_HEIGHT * Y_SCALE); 
        g.addColorStop(0, '#fff'); 
        g.addColorStop(1, '#bbb'); 
        ctx.fillStyle = g;
      }
      ctx.fill();
      
      // Подсветка активных нот
      if (key.isActive) { 
        ctx.fillStyle = 'rgba(97,175,239,0.6)'; 
        ctx.fill(); 
      }
      
      // Подсветка тоники
      if (isTonic) { 
        ctx.fillStyle = 'rgba(229,192,123,0.7)'; 
        ctx.fill(); 
      }
      
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Рисуем JI ratios
      if (key.jiRatios && key.jiRatios.length) {
        const centerX = poly.reduce((s, p) => s + p.x, 0) / poly.length;
        const labelY = key.isBlack 
          ? HINT_BAR_HEIGHT + BLACK_KEY_RELATIVE_HEIGHT * WHITE_KEY_HEIGHT * Y_SCALE * 0.4 
          : HINT_BAR_HEIGHT + WHITE_KEY_HEIGHT * Y_SCALE * 0.6;
        const fontSize = 12;
        ctx.font = `bold ${fontSize}px 'JetBrains Mono', monospace`; 
        ctx.textAlign = 'center';
        
        // Считаем количество видимых ratios
        const visibleRatios = key.jiRatios.filter(r => r.alpha > 0.05);
        let yOff = -((visibleRatios.length - 1) * (fontSize + 2)) / 2;
        
        for (const r of key.jiRatios) {
          if (r.alpha < 0.05) continue;
          
          ctx.fillStyle = this.getRatioColor(r, key.isBlack, r.alpha);
          ctx.fillText(`${r.num}/${r.den}`, centerX, labelY + yOff);
          yOff += fontSize + 2;
        }
      }
    },

    pointInPolygon(px, py, polygon) {
      // Учитываем смещение на HINT_BAR_HEIGHT
      const poly = polygon.map(p => ({ x: p.x * X_SCALE, y: p.y * Y_SCALE + HINT_BAR_HEIGHT }));
      let inside = false;
      for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
        const xi = poly[i].x, yi = poly[i].y, xj = poly[j].x, yj = poly[j].y;
        if (((yi > py) !== (yj > py)) && (px < (xj - xi) * (py - yi) / (yj - yi) + xi)) inside = !inside;
      }
      return inside;
    },

    getKeyAtPosition(x, y) {
      // Сначала проверяем чёрные (они сверху)
      for (let i = 0; i < this.allKeys.length; i++) {
        if (this.allKeys[i].isBlack && this.pointInPolygon(x, y, this.allKeys[i].polygon)) return i;
      }
      for (let i = 0; i < this.allKeys.length; i++) {
        if (!this.allKeys[i].isBlack && this.pointInPolygon(x, y, this.allKeys[i].polygon)) return i;
      }
      return null;
    },

    setupListeners(){
      this.canvas.addEventListener('mousedown', (evt) => {
        const rect = this.canvas.getBoundingClientRect();
        
        const logicalWidth = this.allKeys.length * X_SCALE;
        const keyboardHeight = Math.max(WHITE_KEY_HEIGHT, BLACK_KEY_RELATIVE_HEIGHT * WHITE_KEY_HEIGHT) * Y_SCALE;
        const logicalHeight = HINT_BAR_HEIGHT + keyboardHeight;
        
        const mouseX = (evt.clientX - rect.left);
        const mouseY = (evt.clientY - rect.top);
        
        const polygonX = (mouseX / rect.width) * logicalWidth;
        const polygonY = (mouseY / rect.height) * logicalHeight;

        // Игнорируем клики на hint bar
        if (polygonY < HINT_BAR_HEIGHT) return;

        const keyIndex = this.getKeyAtPosition(polygonX, polygonY);
        if (keyIndex === null) return;
        
        if (evt.button === 0) {
          // ЛКМ: toggle активности
          this.allKeys[keyIndex].isActive = !this.allKeys[keyIndex].isActive;
          if (this.callbacks.onToggleKey) this.callbacks.onToggleKey(keyIndex);
        } else if (evt.button === 2) {
          // ПКМ: установка тоники + отключение Auto Tonic
          this.allKeys.forEach(k => k.isTonic = false);
          this.allKeys[keyIndex].isTonic = true;
          
          const autoTonicCheckbox = document.getElementById('flagAutoTonic');
          if (autoTonicCheckbox && autoTonicCheckbox.checked) {
            autoTonicCheckbox.checked = false;
          }
          
          if (this.callbacks.onSetTonic) this.callbacks.onSetTonic(keyIndex);
        }
      });
      
      this.canvas.addEventListener('contextmenu', (e) => { e.preventDefault(); });

      window.addEventListener('resize', () => {
        this.resizeCanvas();
        this.buildPolygons();
      });
    },

    handleMIDIMessage(evt) {
      const [status, note, velocity] = evt.data;
      const cmd = status & 0xf0;
      const isNoteOn = (cmd === 0x90 && velocity > 0);
      const isNoteOff = (cmd === 0x80 || (cmd === 0x90 && velocity === 0));
      const keyIndex = this.allKeys.findIndex(k => k.midiNote === note);
      if (keyIndex === -1) return;
      
      if (isNoteOn) {
        this.allKeys[keyIndex].isActive = true;
        if (this.callbacks.onToggleKey) this.callbacks.onToggleKey(keyIndex);
      }
      else if (isNoteOff) {
        this.allKeys[keyIndex].isActive = false;
        if (this.callbacks.onToggleKey) this.callbacks.onToggleKey(keyIndex);
      }
    },

    initWebMIDI() {
      if (!navigator.requestMIDIAccess) return;
      navigator.requestMIDIAccess().then((midi) => {
        midi.inputs.forEach(input => input.onmidimessage = (e) => this.handleMIDIMessage(e));
        midi.onstatechange = () => { 
          midi.inputs.forEach(input => input.onmidimessage = (e) => this.handleMIDIMessage(e)); 
        };
      }).catch((err) => console.warn('MIDI not available', err));
    },

    loop() {
      this.draw();
      requestAnimationFrame(() => this.loop());
    }
  };

  global.Keyboard = Keyboard;
})(window);
```

## ji_analyzer\style.css

```css
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: 'JetBrains Mono', monospace;
  background: #1e1e2e;
  color: #cdd6f4;
  font-size: 12px;
  line-height: 1.4;
}

.app-compact {
  padding: 8px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  max-width: 100%;
}

/* Controls Bar */
.controls-bar {
  display: flex;
  align-items: center;
  gap: 16px;
  flex-wrap: wrap;
  padding: 8px;
  background: #181825;
  border-radius: 6px;
}

.control-group {
  display: flex;
  align-items: center;
  gap: 6px;
}

.control-label {
  font-size: 11px;
  opacity: 0.7;
  text-transform: uppercase;
}

.inp-small {
  width: 50px;
  padding: 4px 6px;
  background: #313244;
  border: 1px solid #45475a;
  border-radius: 4px;
  color: #cdd6f4;
  font-family: inherit;
  font-size: 12px;
}

.toggles-row {
  display: flex;
  gap: 12px;
}

.toggle-compact {
  display: flex;
  align-items: center;
  gap: 4px;
  cursor: pointer;
  opacity: 0.6;
  transition: opacity 0.15s;
}

.toggle-compact:has(input:checked) {
  opacity: 1;
}

.toggle-compact input {
  accent-color: #89b4fa;
}

.toggle-compact span {
  font-size: 11px;
}

/* Slider groups */
.slider-group {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.slider-label {
  font-size: 10px;
  opacity: 0.7;
}

.slider-label span {
  color: #89b4fa;
  font-weight: 700;
}

.slider-small {
  width: 80px;
  height: 4px;
  -webkit-appearance: none;
  appearance: none;
  background: #45475a;
  border-radius: 2px;
  outline: none;
}

.slider-small::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 12px;
  height: 12px;
  background: #89b4fa;
  border-radius: 50%;
  cursor: pointer;
}

.slider-small::-moz-range-thumb {
  width: 12px;
  height: 12px;
  background: #89b4fa;
  border-radius: 50%;
  cursor: pointer;
  border: none;
}

/* Canvas */
.canvas-container {
  background: #11111b;
  border-radius: 6px;
  overflow: hidden;
}

#keyboard-canvas {
  display: block;
  width: 100%;
  height: auto;
}

/* Analysis Bar */
.analysis-bar {
  display: flex;
  align-items: center;
  gap: 20px;
  padding: 8px 12px;
  background: #181825;
  border-radius: 6px;
  flex-wrap: wrap;
}

.analysis-item {
  display: flex;
  align-items: center;
  gap: 8px;
}

.analysis-label {
  font-size: 10px;
  text-transform: uppercase;
  opacity: 0.5;
}

.analysis-value {
  font-size: 14px;
  font-weight: 700;
  color: #89b4fa;
  min-width: 30px;
}

.analysis-hz {
  font-size: 11px;
  opacity: 0.6;
  color: #a6e3a1;
}

.marker-lcm {
  color: #f9e2af;
  font-size: 10px;
}

.marker-gcd {
  color: #89b4fa;
  font-size: 10px;
}

.interpretation-text {
  flex: 1;
  min-width: 150px;
}

.interpretation-text pre {
  font-family: inherit;
  font-size: 11px;
  opacity: 0.8;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Footer */
.footer-row {
  display: flex;
  align-items: center;
  gap: 12px;
}

.btn-small {
  padding: 4px 10px;
  background: #45475a;
  border: none;
  border-radius: 4px;
  color: #cdd6f4;
  font-family: inherit;
  font-size: 10px;
  cursor: pointer;
}

.btn-small:hover {
  background: #585b70;
}

.perf-result {
  font-size: 10px;
  opacity: 0.6;
}
```

## ji_analyzer\Спецификация проекта JI Analyzer.md

```markdown
# Спецификация проекта JI Analyzer

## Общее описание

Инструмент для анализа музыкальной гармонии в натуральном строе (Just Intonation). Интерпретирует MIDI-ноты как рациональные дроби (p/q), визуализируя акустические взаимосвязи аккордов.

**Ключевая проблема:** Многозначность. Одной клавише соответствуют десятки дробей (6/5, 7/6, 19/16...). Алгоритм выбирает оптимальный вариант по глобальной структуре аккорда.

------

## Эволюция алгоритма (тезисно)

| Версия | Подход                                  | Проблема                                            |
| ------ | --------------------------------------- | --------------------------------------------------- |
| v1     | Попарная консонантность (Euler, Tenney) | Не видит структуру аккорда целиком                  |
| v2     | GCD/LCM с `getOddPart()`                | 7-limit побеждал 5-limit (степени 2 игнорировались) |
| v3     | GCD/LCM полные числа + Prime Limit      | ✓ Рабочая версия                                    |

**Критический инсайт v2→v3:**

text



```
5-limit мажор: 1/1, 9/8, 5/4, 4/3, 3/2, 5/3, 15/8
  → LCM(odd) = 45, LCM(full) = 180

7-limit: 1/1, 8/7, 5/4, 4/3, 32/21, 5/3, 40/21  
  → LCM(odd) = 5 ← ложный победитель!
  → LCM(full) = 3360 ← правильно проигрывает
```

------

## Текущая архитектура (v3)

### 1. Метрика сложности

JavaScript



```
Score = (LCM(nums) / GCD(dens)) × (LCM(dens) / GCD(nums))^gcdWeight
```

| Параметр          | Значение              | Смысл                                         |
| ----------------- | --------------------- | --------------------------------------------- |
| `gcdWeight`       | 1.0–3.0 (default 1.5) | Вес фундамента vs cover                       |
| `PRIME_LIMIT`     | 7                     | Отсекает 11/8, 13/8 и т.д.                    |
| `CENTS_THRESHOLD` | 35                    | Фильтр четвертьтонов (7/4 проходит, 11/6 нет) |

**Важно:** `ignoreOctaves = false` — степени 2 учитываются!

### 2. Фильтрация кандидатов

JavaScript



```
for (n/d) in all_ratios:
  if gcd(n,d) ≠ 1: skip           // Несократимые
  if oddPart > maxOdd: skip       // Odd Limit (default 45)
  if maxPrime(n,d) > 7: skip      // Prime Limit — КРИТИЧНО!
  if |cents - 12EDO| > 35: skip   // Не четвертьтона
  
  candidates[step].push({n, d, weight: eulerGradus(n,d)})
```

**Сортировка по Euler Gradus** — фиксирует порядок на экране и tiebreaker.

### 3. Beam Search

text



```
1. Для каждой потенциальной тоники:
   - Beam width = 50
   - На каждом шаге: расширяем все лучи всеми кандидатами
   - Пересчитываем computeWeightedComplexity()
   - Оставляем top-50

2. Hysteresis: не менять тонику если улучшение < порога (default 20%)

3. Результат: набор дробей + тоника с минимальным Score
```

### 4. Визуализация

**Hint Bar (над клавишами):**

- Цвет = Euler Gradus лучшего кандидата (зелёный → красный)
- Alpha: активные 0.85, неактивные 0.45, тоника 1.0
- Маркеры: ◆ (синий) = GCD/Fundamental, ▲ (жёлтый) = LCM/Cover

**На клавишах:**

- Активные: до 4 альтернатив, alpha = 0.25 + 0.35 × (best/current)
- Призраки: до 3 альтернатив, alpha = 0.4 × ratio²
- Порядок фиксирован (по Euler), меняется только alpha

**Analysis Bar:**

- Cover (LCM): значение + Hz + нота (например: `180 | 1760.0Hz ≈ A6`)
- Fundamental (GCD): значение + Hz + нота

### 5. Режимы тоники

| Режим  | Поведение                             | UI                 |
| ------ | ------------------------------------- | ------------------ |
| Auto   | Перебор всех нот, выбор лучшего Score | Checkbox           |
| Manual | ПКМ фиксирует 1/1                     | ПКМ отключает Auto |

**Hysteresis:** Не менять тонику если новый Score лучше менее чем на N% (слайдер 0–50%).

------

## Ключевые формулы

**Частота фундамента:**

JavaScript



```
tonicHz = 440 × 2^((tonicMidi - 69) / 12)
gcdHz = tonicHz / LCM(nums)    // Низкая нота
lcmHz = tonicHz × LCM / GCD    // Высокая нота
```

**Euler Gradus:**

JavaScript



```
G(n/d) = 1 + Σ((p-1) × k) для всех p^k в факторизации n×d
// G(3/2) = 1 + (3-1) + (2-1) = 4
// G(5/4) = 1 + (5-1) + (2-1)×2 = 7
// G(7/4) = 1 + (7-1) + (2-1)×2 = 9
```

------

## Решённые проблемы

| Проблема                       | Решение                            |
| ------------------------------ | ---------------------------------- |
| 7-limit побеждает 5-limit      | Полные числа в метрике             |
| Большие простые (19/16, 11/8)  | Prime Limit = 7 + Euler сортировка |
| Скачущие позиции интерпретаций | Фиксированный порядок по Euler     |
| Тоника "прыгает"               | Hysteresis (порог смены)           |
| Нет баланса LCM/GCD            | gcdWeight слайдер                  |

------

## Нюансы и ловушки

### Prime Limit vs Odd Limit

- **Odd Limit 45** пропускает 11/8 (odd=11), 13/8 (odd=13)
- **Prime Limit 7** их отсекает — это правильное поведение!

### Октавы в расчётах

- **Score:** Полные числа (9/8 ≠ 9/4)
- **Генерация:** Только [1,2), потом `adjustRatioOctave()`
- **LCM/GCD маркеры:** Показываются во всех октавах клавиатуры

### Hysteresis

При быстрой игре тоника может "прыгать". Hysteresis=20% означает: не менять тонику, если новый Score лучше менее чем на 20%.

------

## API ji-lib.js

JavaScript



```
jiLib = {
  // Core
  gcd, lcm, gcdArray, lcmArray, getOddPart,
  getMaxPrime(n),                              // Для Prime Limit
  
  // Ratios  
  createRatio(n, d),
  adjustRatioOctave(r, shift),
  
  // Complexity
  computeComplexity(ratios, useLCM, useGCD, ignoreOctaves=false),
  computeWeightedComplexity(ratios, useLCM, useGCD, gcdWeight),
  eulerGradus(n, d),
  
  // Utils
  ratioToCents(r),
  getNoteName(midi)
}
```

------

## TODO (по приоритету)

### Высокий

1. **Динамическое окно (realtime)**
   - Decay factor для нот со временем
   - 60 FPS обновление
   - Режимы: instant / smooth / sticky
2. **Звук**
   - Синтез JI интервалов
   - A/B сравнение с 12-EDO

### Средний

1. **Оптимизации**
   - Инкрементальный LCM/GCD (кэширование)
   - Web Worker для тяжёлых расчётов
   - Профилирование при 10+ нотах
2. **Расширенная аналитика**
   - Prime limit аккорда
   - Comma detection (синтонические, септимальные)
   - Export интерпретации

### Низкий

1. UX polish
   - Hover tooltips с центами
   - Keyboard shortcuts
   - Preset аккорды для демо

------

## Конфигурация (defaults)

JavaScript



```
BEAM_WIDTH = 50
MAX_CANDS = 6
VISUAL_GHOSTS = 3
CENTS_THRESHOLD = 35
PRIME_LIMIT = 7
gcdWeight = 1.5
hysteresis = 0.2
maxOdd = 45
```
```

## lib\additivepiano.js

```javascript
// lib/additivepiano.js
(function() {
  if (typeof Utils === 'undefined' || typeof Synth === 'undefined') {
    console.warn('audio-lib.js not loaded, using stubs');
    window.PianoSynth = { 
      init() {}, 
      playNote() {}, 
      playInterval() {} 
    };
    return;
  }

  const ctx = Utils.initAudio();

  const PIANO = {
    harmonics: 16,
    envelope: { attack: 0.005, decay: 0.4, sustain: 0.2, release: 0.8 }
  };

  const pianoPartials = (freq) => 
    Array.from({ length: PIANO.harmonics }, (_, i) => {
      const n = i + 1;
      const oddBoost = (n % 2 === 1) ? 1.2 : 0.8;
      const gain = oddBoost / Math.pow(n, 1.8); 
      return {
        ratio: n,
        amp: gain,
        startDelay: 0,
        attack: PIANO.envelope.attack,
        decay: PIANO.envelope.decay + (n * 0.05),
        sustain: Math.max(PIANO.envelope.sustain - (n * 0.02), 0.1),
        release: PIANO.envelope.release
      };
    });

  const synth = new Synth(ctx, {
    partials: pianoPartials,
    type: 'sine'
  });
  synth.connect(ctx.destination);

  window.PianoSynth = {
    ctx,
    
    init() {
      if (ctx.state === 'suspended') ctx.resume();
    },

    playNote(ratio, duration = 0.5, velocity = 0.4) {
      this.init();
      const baseFreq = 220;
      const freq = baseFreq * ratio.toDecimal();
      synth.triggerAttackRelease('note_' + Date.now(), freq, duration, velocity);
    },

    playInterval(noteA, noteB, duration = 0.6) {
      this.init();
      const baseFreq = 220;
      const freqA = baseFreq * noteA.toDecimal();
      const freqB = baseFreq * noteB.toDecimal();
      
      synth.triggerAttackRelease('interval_a_' + Date.now(), freqA, duration, 0.35);
      synth.triggerAttackRelease('interval_b_' + Date.now(), freqB, duration, 0.35);
    }
  };
})();
```

## lib\applydiff_win.py

```python
#!/usr/bin/env python3
# applydiff_win.py — Windows-only минималистичный "patch" для unified diff
# Консольное приложение: можно просто вставить текст diff и завершить точкой на отдельной строке.
# Работает в папке, где лежит сам скрипт (root по умолчанию = каталог скрипта).
#
# Возможности:
# - Unified diff (---/+++; @@ хунки; + - ' ' строки)
# - Создание/удаление файлов через /dev/null
# - Сохранение стиля перевода строк; для новых файлов по умолчанию CRLF
# - Поддержка "\ No newline at end of file"
# - Игнорирование служебных строк git diff (diff --git, index, mode, rename ...)
# - Режимы игнорирования пробелов (--ignore-space-change, --ignore-whitespace)
# - Поиск позиции хунков с fuzz и окном поиска (--fuzz, --max-search)
#
# Использование (Windows):
#   1) Вставкой из буфера:
#        python applydiff_win.py
#        (вставьте unified diff)
#        затем введите на новой строке одиночную точку: .  и нажмите Enter
#        (или Ctrl+Z, затем Enter)
#   2) Из файла:
#        python applydiff_win.py change.diff -p 1
#   3) Через конвейер:
#        type change.diff | python applydiff_win.py --dry-run

import sys
import os
import argparse
import re
from typing import List, Tuple, Optional

HUNK_RE = re.compile(r"^@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@")

# Тип строки хунка: (op, text, has_newline)
HunkLine = Tuple[str, str, bool]

class Hunk:
    def __init__(self, ostart, ocnt, nstart, ncnt, lines: List[HunkLine]):
        self.ostart = int(ostart)
        self.ocnt = int(ocnt) if ocnt is not None else 1
        self.nstart = int(nstart)
        self.ncnt = int(ncnt) if ncnt is not None else 1
        self.lines = lines

class FilePatch:
    def __init__(self, src: Optional[str], dst: Optional[str]):
        self.src = src
        self.dst = dst
        self.hunks: List[Hunk] = []

    @property
    def is_delete(self):
        return (self.dst or '').strip() == '/dev/null'

    @property
    def is_create(self):
        return (self.src or '').strip() == '/dev/null'

SKIP_PREFIXES = (
    'diff --git', 'index ', 'new file mode', 'deleted file mode', 'old mode', 'new mode',
    'similarity index', 'rename from', 'rename to', 'copy from', 'copy to'
)


def normalize_path(raw: Optional[str], strip: Optional[int]) -> Optional[str]:
    if raw is None:
        return None
    raw = raw.strip()
    if raw == '/dev/null':
        return '/dev/null'
    if '\t' in raw:
        raw = raw.split('\t', 1)[0]
    path = raw
    if strip is None:
        if path.startswith('a/') or path.startswith('b/'):
            path = path.split('/', 1)[1]
    else:
        for _ in range(strip):
            if '/' in path:
                path = path.split('/', 1)[1]
            else:
                path = ''
                break
    return path


def parse_diff(text: str) -> List[FilePatch]:
    lines = text.splitlines(keepends=False)
    patches: List[FilePatch] = []
    i = 0
    current: Optional[FilePatch] = None
    while i < len(lines):
        line = lines[i]
        if line.startswith(SKIP_PREFIXES):
            i += 1
            continue
        if line.startswith('Binary files ') or line.startswith('GIT binary patch'):
            raise ValueError('Бинарные патчи не поддерживаются')
        if line.startswith('--- '):
            src = line[4:]
            i += 1
            while i < len(lines) and not lines[i].startswith('+++ '):
                if lines[i].startswith(SKIP_PREFIXES) or lines[i].strip() == '':
                    i += 1
                    continue
                break
            if i >= len(lines) or not lines[i].startswith('+++ '):
                raise ValueError('Повреждённый diff: отсутствует +++ после ---')
            dst = lines[i][4:]
            current = FilePatch(src, dst)
            patches.append(current)
            i += 1
            while i < len(lines):
                if lines[i].startswith('@@ '):
                    m = HUNK_RE.match(lines[i])
                    if not m:
                        raise ValueError(f'Повреждённый заголовок хунка: {lines[i]}')
                    ostart, ocnt, nstart, ncnt = m.groups()
                    i += 1
                    h_lines: List[HunkLine] = []
                    last_index = -1
                    while i < len(lines):
                        l = lines[i]
                        if l.startswith('@@ ') or l.startswith('--- '):
                            break
                        if l.startswith(' ') or l.startswith('+') or l.startswith('-'):
                            h_lines.append((l[0], l[1:], True))
                            last_index = len(h_lines) - 1
                        elif l.startswith('\\ No newline at end of file'):
                            if last_index >= 0:
                                op, txt, _ = h_lines[last_index]
                                h_lines[last_index] = (op, txt, False)
                        else:
                            h_lines.append((' ', l, True))
                            last_index = len(h_lines) - 1
                        i += 1
                    current.hunks.append(Hunk(ostart, ocnt, nstart, ncnt, h_lines))
                elif lines[i].startswith('diff ') or lines[i].startswith(SKIP_PREFIXES):
                    i += 1
                elif lines[i].startswith('--- '):
                    break
                else:
                    i += 1
        else:
            i += 1
    return patches


def detect_eol_from_lines(orig_lines: List[str]) -> Optional[str]:
    for s in orig_lines:
        if s.endswith('\r\n'):
            return '\r\n'
        if s.endswith('\n'):
            return '\n'
        if s.endswith('\r'):
            return '\r'
    return None


def choose_new_file_eol(policy: str) -> str:
    if policy == 'lf':
        return '\n'
    if policy == 'crlf':
        return '\r\n'
    if policy == 'cr':
        return '\r'
    return '\r\n'  # Windows по умолчанию


def split_content_and_nl(s: str):
    if s.endswith('\r\n'):
        return s[:-2], True
    if s.endswith('\n'):
        return s[:-1], True
    if s.endswith('\r'):
        return s[:-1], True
    return s, False

class CmpMode:
    NONE = 0
    SPACE_CHANGE = 1
    WHITESPACE = 2


def normalize_for_cmp(s: str, mode: int) -> str:
    s = s.replace('\r', '')
    if mode == CmpMode.NONE:
        return s
    if mode == CmpMode.WHITESPACE:
        return ''.join(ch for ch in s if not ch.isspace())
    out = []
    prev_space = False
    for ch in s:
        if ch.isspace():
            if not prev_space:
                out.append(' ')
                prev_space = True
        else:
            out.append(ch)
            prev_space = False
    return ''.join(out).strip()


def hunk_matches_at(orig_lines: List[str], start_idx: int, h_lines: List[HunkLine], cmp_mode: int):
    idx = start_idx
    for op, txt, _has_nl in h_lines:
        if op == '+':
            continue
        if idx >= len(orig_lines):
            return False, start_idx
        content, _ = split_content_and_nl(orig_lines[idx])
        if normalize_for_cmp(content, cmp_mode) != normalize_for_cmp(txt, cmp_mode):
            return False, start_idx
        idx += 1
    return True, idx


def reduce_hunk_lines(h_lines: List[HunkLine], drop_left_ctx: int, drop_right_ctx: int) -> List[HunkLine]:
    if drop_left_ctx == 0 and drop_right_ctx == 0:
        return h_lines
    ctx_idx = [i for i, (op, _, _) in enumerate(h_lines) if op == ' ']
    to_drop = set()
    for k in range(min(drop_left_ctx, len(ctx_idx))):
        to_drop.add(ctx_idx[k])
    for k in range(1, min(drop_right_ctx, len(ctx_idx)) + 1):
        to_drop.add(ctx_idx[-k])
    return [hl for j, hl in enumerate(h_lines) if j not in to_drop]


def apply_hunks_to_lines(orig_lines: List[str], hunks: List[Hunk], eol_new_file: str, cmp_mode: int, fuzz: int, max_search: Optional[int]) -> List[str]:
    out: List[str] = []
    in_pos = 0
    eol = detect_eol_from_lines(orig_lines) or eol_new_file

    for h in hunks:
        header_pos = max(h.ostart - 1, 0)
        variants = [(0, 0)]
        for f in range(1, max(0, fuzz) + 1):
            for dl in range(0, f + 1):
                dr = f - dl
                variants.append((dl, dr))

        placed = False
        chosen_start = None
        chosen_end_after = None
        chosen_lines: List[HunkLine] = []

        start_search = in_pos
        stop_search = len(orig_lines)
        if max_search is not None:
            start_search = max(in_pos, header_pos - max_search)
            stop_search = min(len(orig_lines), header_pos + max_search)

        for dl, dr in variants:
            reduced = reduce_hunk_lines(h.lines, dl, dr)
            candidates = []
            if header_pos >= start_search and header_pos <= stop_search:
                candidates.append(header_pos)
            for cand in range(start_search, stop_search + 1):
                if cand == header_pos:
                    continue
                candidates.append(cand)
            for cand in candidates:
                ok, end_after = hunk_matches_at(orig_lines, cand, reduced, cmp_mode)
                if ok and cand >= in_pos:
                    placed = True
                    chosen_start = cand
                    chosen_end_after = end_after
                    chosen_lines = reduced
                    break
            if placed:
                break

        if not placed:
            raise ValueError('Не удалось сопоставить хунк (контекст слишком изменился)')

        while in_pos < chosen_start:
            out.append(orig_lines[in_pos])
            in_pos += 1

        idx = in_pos
        for op, txt, has_nl in chosen_lines:
            if op == ' ':
                out.append(orig_lines[idx])
                idx += 1
            elif op == '-':
                idx += 1
            elif op == '+':
                out.append(txt + (eol if has_nl else ''))
            else:
                raise ValueError(f'Неизвестная операция хунка: {op}')
        in_pos = idx

    while in_pos < len(orig_lines):
        out.append(orig_lines[in_pos])
        in_pos += 1

    return out


def read_text_source(diff_path: Optional[str]) -> str:
    if diff_path:
        with open(diff_path, 'r', encoding='utf-8') as f:
            return f.read()
    # Интерактивный ввод: Windows-дружественно — завершаем точкой / EOF / END
    try:
        is_tty = sys.stdin.isatty()
    except Exception:
        is_tty = False
    if is_tty:
        print('Вставьте unified diff ниже. Для завершения введите на новой строке: .  (точка) и нажмите Enter.\nАльтернатива: Ctrl+Z, затем Enter.', file=sys.stderr)
        buf = []
        while True:
            try:
                line = input()
            except EOFError:
                break
            # Сентинелы завершения
            if line in ('.', 'EOF', 'END'):
                break
            buf.append(line + '\n')
        return ''.join(buf)
    # Не TTY — читаем как есть (pipe)
    return sys.stdin.read()


def main():
    if os.name != 'nt':
        print('Этот вариант утилиты рассчитан на Windows (os.name == "nt").', file=sys.stderr)
        return 2

    script_dir = os.path.dirname(os.path.abspath(sys.argv[0]))

    ap = argparse.ArgumentParser(description='Применить unified diff к файлам в папке (Windows, интерактивная вставка текста).')
    ap.add_argument('diff', nargs='?', help='Файл с diff. Если не задан, можно вставить текст вручную.')
    ap.add_argument('-p', '--strip', type=int, default=None, help='Отбросить N компонентов пути (как patch -pN). По умолчанию авто a/ b/.')
    ap.add_argument('--dry-run', action='store_true', help='Сухой прогон: только проверка применимости, без записи файлов.')
    ap.add_argument('--root', default=script_dir, help='Корень применения. По умолчанию: папка, где лежит скрипт.')
    ap.add_argument('--eol', choices=['auto', 'lf', 'crlf', 'cr'], default='crlf', help='Перевод строк для новых файлов (по умолчанию CRLF).')
    ap.add_argument('--ignore-space-change', action='store_true', help='Игнорировать различия в количестве пробелов.')
    ap.add_argument('--ignore-whitespace', action='store_true', help='Игнорировать пробелы полностью при сопоставлении.')
    ap.add_argument('--fuzz', type=int, default=2, help='Допустимый fuzz (отброс контекста) при поиске позиции хунка.')
    ap.add_argument('--max-search', type=int, default=None, help='Ограничить окно поиска позиции хунка (в строках).')

    args = ap.parse_args()

    text = read_text_source(args.diff)

    try:
        patches = parse_diff(text)
    except Exception as e:
        print(f'Ошибка разбора diff: {e}', file=sys.stderr)
        return 1

    if not patches:
        print('Патчи не найдены. Убедитесь, что вы вставили unified diff и завершили ввод точкой (.) или Ctrl+Z, Enter.', file=sys.stderr)
        return 1

    class CmpMode:
        NONE = 0
        SPACE_CHANGE = 1
        WHITESPACE = 2

    cmp_mode = CmpMode.NONE
    if args.ignore_whitespace:
        cmp_mode = CmpMode.WHITESPACE
    elif args.ignore_space_change:
        cmp_mode = CmpMode.SPACE_CHANGE

    failures = 0
    for fp in patches:
        src = normalize_path(fp.src, args.strip)
        dst = normalize_path(fp.dst, args.strip)

        if fp.is_delete:
            target = src
            op = 'delete'
        elif fp.is_create:
            target = dst
            op = 'create'
        else:
            target = dst
            op = 'modify'

        if not target:
            print('[-] Пропуск патча без применимого пути (возможно, /dev/null и слишком большой -p).')
            continue

        full_path = os.path.join(args.root, target)

        if op == 'delete':
            if not os.path.exists(full_path):
                print(f'[skip] {target}: уже отсутствует')
                continue
            if args.dry_run:
                print(f'[dry-run] будет удалён {target}')
            else:
                os.remove(full_path)
                print(f'[ok] удалён {target}')
            continue

        if os.path.exists(full_path):
            with open(full_path, 'r', encoding='utf-8', newline='') as f:
                orig_lines = f.read().splitlines(keepends=True)
        else:
            orig_lines = []
            if not args.dry_run:
                os.makedirs(os.path.dirname(full_path) or '.', exist_ok=True)

        try:
            new_lines = apply_hunks_to_lines(
                orig_lines,
                fp.hunks,
                eol_new_file=choose_new_file_eol(args.eol if args.eol != 'auto' else 'crlf'),
                cmp_mode=cmp_mode,
                fuzz=args.fuzz,
                max_search=args.max_search,
            )
        except Exception as e:
            failures += 1
            print(f'[fail] {target}: {e}', file=sys.stderr)
            continue

        if args.dry_run:
            print(f'[dry-run] будет записан {target} ({len(orig_lines)} → {len(new_lines)} строк)')
        else:
            with open(full_path, 'w', encoding='utf-8', newline='') as f:
                f.writelines(new_lines)
            print(f'[ok] {op} {target} ({len(orig_lines)} → {len(new_lines)} строк)')

    return 0 if failures == 0 else 1


if __name__ == '__main__':
    sys.exit(main())

```

## lib\audio-lib.js

```javascript
// ============================================
// audio-lib.js - Optimized & Safe
// ============================================

const Utils = {
  initAudio() {
    const Ctx = window.AudioContext || window.webkitAudioContext;
    return new Ctx();
  },
  
  // Конвертация центов в частоту
  centsToFrequency(centsOffset, baseFrequency = 440) {
    return baseFrequency * Math.pow(2, centsOffset / 1200);
  },
  
  // Генерация импульса для реверберации
  createImpulse(ctx, duration = 2, decay = 2) {
    const sr = ctx.sampleRate;
    const len = sr * duration;
    const impulse = ctx.createBuffer(2, len, sr);
    for (let ch = 0; ch < 2; ch++) {
      const data = impulse.getChannelData(ch);
      for (let i = 0; i < len; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, decay);
      }
    }
    return impulse;
  }
};

const Envelope = {
  attack(param, now, target, time) {
    param.cancelScheduledValues(now);
    param.setValueAtTime(0, now);
    param.linearRampToValueAtTime(target, now + time);
  },

  release(param, now, time) {
    param.cancelAndHoldAtTime(now);
    
    // FIX: Экспоненциальный спад звучит натуральнее и убирает "ступеньку" в конце
    param.exponentialRampToValueAtTime(0.001, now + time);
    param.linearRampToValueAtTime(0, now + time + 0.05); // Гарантированный ноль
  },
    
  // release(param, now, time) {
  //   param.cancelScheduledValues(now);
    
  //   // FIX: Безопасное начало релиза с текущего уровня громкости
  //   if (param.cancelAndHoldAtTime) {
  //     param.cancelAndHoldAtTime(now);
  //   } else {
  //     // Fallback для старых браузеров
  //     param.setValueAtTime(param.value, now); 
  //   }
    
  //   // FIX: Экспоненциальный спад звучит натуральнее и убирает "ступеньку" в конце
  //   param.exponentialRampToValueAtTime(0.001, now + time);
  //   param.linearRampToValueAtTime(0, now + time + 0.05); // Гарантированный ноль
  // },
  
  adsr(param, now, a, d, s, target) {
    param.cancelScheduledValues(now);
    param.setValueAtTime(0, now);
    param.linearRampToValueAtTime(target, now + a);
    // sustain не может быть чистым 0 для exponentialRamp
    param.exponentialRampToValueAtTime(Math.max(target * s, 0.001), now + a + d);
  }
};

class Voice {
  constructor(ctx, freq, opts = {}) {
    this.ctx = ctx;
    this.osc = ctx.createOscillator();
    this.gain = ctx.createGain();
    this.vibrato = null;
    this.onEnded = null; // Внутренний колбэк
    
    this.osc.type = opts.type || 'sine';
    this.osc.frequency.value = freq;
    
    // LFO Vibrato logic
    if (opts.vibrato) {
      const lfo = ctx.createOscillator();
      const lfoGain = ctx.createGain();
      lfo.frequency.value = opts.vibrato.rate || 5;
      lfoGain.gain.value = freq * (opts.vibrato.depth || 0.001);
      lfo.connect(lfoGain);
      lfoGain.connect(this.osc.frequency);
      lfo.start();
      this.vibrato = { lfo, lfoGain };
    }
    
    if (opts.filter) {
      this.osc.connect(opts.filter);
      opts.filter.connect(this.gain);
    } else {
      this.osc.connect(this.gain);
    }
    
    this.gain.gain.value = 0;
    
    // FIX: Используем нативное событие для очистки ресурсов
    this.osc.onended = () => {
      this.disconnect();
      if (this.onEnded) this.onEnded();
    };
  }
  
  start(when = this.ctx.currentTime) {
    this.osc.start(when);
  }
  
  stop(when = this.ctx.currentTime) {
    try {
      this.osc.stop(when);
      if (this.vibrato) this.vibrato.lfo.stop(when);
    } catch(e) {} // Игнорируем, если уже остановлен
  }
  
  disconnect() {
    if (this.vibrato) {
      this.vibrato.lfo.disconnect();
      this.vibrato.lfoGain.disconnect();
    }
    this.osc.disconnect();
    // Gain не отключаем, так как он может еще доигрывать хвост релиза
  }
  
  connect(node) {
    this.gain.connect(node);
  }
  
  setFrequency(freq, when, glide = 0) {
    if (glide > 0) {
      this.osc.frequency.linearRampToValueAtTime(freq, when + glide);
    } else {
      this.osc.frequency.setValueAtTime(freq, when);
    }
  }
}

class Synth {
  constructor(ctxOrConfig, opts = {}) {
    const isStableMode = ctxOrConfig?.destination !== undefined;
    
    if (isStableMode) {
      this.ctx = ctxOrConfig;
      this.opts = opts;
      this.voices = new Map();
      
      // === FIX: ВНУТРЕННЯЯ ЦЕПОЧКА ОБРАБОТКИ ===
      // Voices -> Limiter -> Output
      this.output = this.ctx.createGain();
      this.output.gain.value = 0.5; // Headroom по умолчанию (чтобы не было клиппинга сразу)
      
      // Встроенный компрессор для защиты от перегруза
      this.limiter = this.ctx.createDynamicsCompressor();
      this.limiter.threshold.value = -10;
      this.limiter.knee.value = 10;
      this.limiter.ratio.value = 12;
      this.limiter.attack.value = 0.005;
      this.limiter.release.value = 0.1;
      
      this.limiter.connect(this.output);
      // Все голоса будем подключать к лимитеру, а не напрямую к выходу
      this.internalBus = this.limiter; 
      
    } else {
      // ... (Legacy/Extended mode initialization kept as is) ...
       this.output = null; 
       // Simple fallback for extended mode just in case
    }
  }
  
  _parsePartials(partials, baseFreq) {
    if (!partials || partials.length === 0) return [{ ratio: 1, amp: 1 }];
    if (typeof partials === 'function') partials = partials(baseFreq);
    if (typeof partials[0] === 'number') {
      partials = partials.map((amp, i) => ({ ratio: i + 1, amp }));
    }
    
    // FIX: АВТО-НОРМАЛИЗАЦИЯ
    // Если юзер подал 16 гармоник с громкостью 1.0 каждая, 
    // мы их скалируем, чтобы сумма была = 1.0
    const totalAmp = partials.reduce((sum, p) => sum + (p.amp || 0), 0);
    if (totalAmp > 1.0) {
      const scale = 1.0 / totalAmp;
      // Не меняем исходный массив (он может использоваться повторно), создаем копию
      return partials.map(p => ({ ...p, amp: (p.amp || 0) * scale }));
    }
    
    return partials;
  }
  
  noteOn(id, freq, velocity = 1) {
    // FIX: Предотвращение наслоения нот с одинаковым ID
    if (this.voices.has(id)) {
      // Мгновенная остановка предыдущей ноты без релиза
      const oldVoice = this.voices.get(id);
      try {
        oldVoice.master.gain.cancelScheduledValues(this.ctx.currentTime);
        oldVoice.master.gain.setValueAtTime(0, this.ctx.currentTime);
        oldVoice.voices.forEach(v => v.stop(this.ctx.currentTime));
      } catch(e){}
      this.voices.delete(id);
    }
    
    const now = this.ctx.currentTime;
    const partials = this._parsePartials(this.opts.partials, freq);
    const master = this.ctx.createGain();
    const activeVoices = [];
    
    // Начальная громкость мастера 0
    master.gain.value = 0;
    // Подключаем к внутренней шине (компрессору), а не сразу на выход
    master.connect(this.internalBus || this.output);
    
    // Счетчик живых осцилляторов для Garbage Collection
    let pendingVoices = partials.length;

    partials.forEach(p => {
      const voice = new Voice(this.ctx, freq * (p.ratio || 1), {
        type: this.opts.type || 'sine',
        vibrato: this.opts.vibrato,
        filter: p.filter || this.opts.filter
      });
      
      voice.gain.gain.value = p.amp || 0;
      voice.connect(master);
      
      // Когда голос закончит играть, уменьшаем счетчик
      voice.onEnded = () => {
        pendingVoices--;
        if (pendingVoices <= 0) {
          // Когда все гармоники затихли, отключаем мастер-шину ноты
          master.disconnect();
        }
      };

      const startTime = now + (p.startDelay || 0);
      voice.start(startTime);
      
      // Применяем ADSR к каждой гармонике индивидуально
      if (p.attack !== undefined) {
        if (p.decay !== undefined && p.sustain !== undefined) {
          Envelope.adsr(voice.gain.gain, startTime, p.attack, p.decay, p.sustain, p.amp);
        } else {
          Envelope.attack(voice.gain.gain, startTime, p.amp, p.attack);
        }
      }
      
      activeVoices.push(voice);
    });
    
    // Глобальная огибающая на мастер ноды
    const hasIndividualEnv = partials.some(p => p.attack !== undefined);
    if (!hasIndividualEnv && this.opts.envelope) {
      const env = this.opts.envelope;
      if (env.decay !== undefined && env.sustain !== undefined) {
        Envelope.adsr(master.gain, now, env.attack, env.decay, env.sustain, velocity);
      } else if (env.attack !== undefined) {
        Envelope.attack(master.gain, now, velocity, env.attack);
      } else {
        master.gain.setValueAtTime(velocity, now);
      }
    } else {
      master.gain.setValueAtTime(velocity, now);
    }
    
    this.voices.set(id, { voices: activeVoices, master, partials });
  }
  
  noteOff(id, when = this.ctx.currentTime) {
    if (!this.voices.has(id)) return;
    
    const { voices, master, partials } = this.voices.get(id);
    const release = this.opts.envelope?.release || 0.1;
    
    // Безопасное время остановки (релиз + небольшой буфер)
    const stopTime = when + release + 0.2;
    
    const hasIndividualEnv = partials.some(p => p.release !== undefined);
    if (hasIndividualEnv) {
      voices.forEach((voice, i) => {
        const r = partials[i].release || release;
        Envelope.release(voice.gain.gain, when, r);
        voice.stop(when + r + 0.2);
      });
    } else {
      Envelope.release(master.gain, when, release);
      voices.forEach(voice => voice.stop(stopTime));
    }
    
    // Удаляем из Map сразу, очистка ресурсов произойдет автоматически через onEnded
    this.voices.delete(id);
  }
  
  triggerAttackRelease(id, freq, duration, velocity = 1) {
    this.noteOn(id, freq, velocity);
    this.noteOff(id, this.ctx.currentTime + duration);
  }

  // ... Остальные методы без изменений (connect, disconnect, setFrequency) ...
  setFrequency(id, freq, glide = 0) {
    if (!this.voices.has(id)) return;
    const { voices, partials } = this.voices.get(id);
    voices.forEach((voice, i) => {
      voice.setFrequency(freq * (partials[i].ratio || 1), this.ctx.currentTime, glide);
    });
  }
  
  connect(node) { 
    this.output?.connect(node); 
  }
  
  disconnect() { 
    this.output?.disconnect(); 
  }
}

// ============================================
// AudioSession - High-level API for entropy app
// (Replaces legacy audio.js)
// ============================================
class AudioSession {
  constructor(config = {}) {
    this.ctx = null;
    this.synths = [null, null];
    this.filters = [null, null];
    this.analysers = [null, null];
    this.reverbNode = null;
    this.reverbMix = null;
    
    this.baseFrequency = config.baseFrequency || 440;
    this.isMouseDown = false;
    
    this.params = {
      oscillatorType: "sawtooth",
      filterFrequency: 1000,
      filterType: "lowpass",
      gainAttackTime: 0.05,
      gainSustainLevel: 0.5,
      gainReleaseTime: 0.2,
      ...config.params
    };
    
    this.noteIndicators = [
      { noteIndex: 0, x: null, opacity: 0 },
      { noteIndex: 1, x: 0, opacity: 0 },
    ];
    
    this._animationId = null;
    this._chartRenderer = null;
  }
  
  async init() {
    if (this.ctx) return;
    
    this.ctx = Utils.initAudio();
    
    // Reverb (shared)
    this.reverbNode = this.ctx.createConvolver();
    this.reverbNode.buffer = Utils.createImpulse(this.ctx, 1.0, 2.0);
    this.reverbMix = this.ctx.createGain();
    this.reverbMix.gain.value = 0.3;
    this.reverbNode.connect(this.reverbMix);
    this.reverbMix.connect(this.ctx.destination);
    
    // Two independent synths with filter + analyser each
    for (let i = 0; i < 2; i++) {
      this.synths[i] = new Synth(this.ctx, {
        type: this.params.oscillatorType,
        envelope: {
          attack: this.params.gainAttackTime,
          release: this.params.gainReleaseTime,
        }
      });
      
      this.filters[i] = this.ctx.createBiquadFilter();
      this.filters[i].type = this.params.filterType;
      this.filters[i].frequency.value = this.params.filterFrequency;
      
      this.analysers[i] = this.ctx.createAnalyser();
      this.analysers[i].fftSize = 256;
      
      // Chain: Synth -> Filter -> Analyser -> Destination
      //                       \-> Reverb
      this.synths[i].connect(this.filters[i]);
      this.filters[i].connect(this.analysers[i]);
      this.filters[i].connect(this.reverbNode);
      this.analysers[i].connect(this.ctx.destination);
    }
  }
  
  centsToFrequency(centsOffset) {
    return Utils.centsToFrequency(centsOffset, this.baseFrequency);
  }
  
  createNote(frequency, startTime, noteIndex) {
    const synth = this.synths[noteIndex];
    if (!synth) return null;
    
    synth.noteOn(0, frequency, this.params.gainSustainLevel);
    return { noteIndex };
  }
  
  stopNote(note, stopTime) {
    if (note && note.noteIndex !== undefined) {
      const synth = this.synths[note.noteIndex];
      if (synth) {
        synth.noteOff(0, stopTime);
      }
    }
  }
  
  getAnalyserLevel(noteIndex) {
    const analyser = this.analysers[noteIndex];
    if (!analyser) return 0;
    
    const dataArray = new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteTimeDomainData(dataArray);
    
    let level = 0;
    for (let i = 0; i < dataArray.length; i++) {
      level += Math.abs(dataArray[i] - 128);
    }
    level = dataArray.length > 0 ? level / dataArray.length : 0;
    return Math.min(1, Math.max(0, level / 40));
  }
  
  startVisualization(chartRenderer) {
    this._chartRenderer = chartRenderer;
    this._updateLoop();
  }
  
  _updateLoop() {
    let needsRedraw = false;
    
    for (let i = 0; i < 2; i++) {
      if (!this.noteIndicators[i]) continue;
      
      const newOpacity = this.getAnalyserLevel(i);
      if (Math.abs(this.noteIndicators[i].opacity - newOpacity) > 0.01) {
        this.noteIndicators[i].opacity = newOpacity;
        needsRedraw = true;
      }
    }
    
    if ((needsRedraw || this.isMouseDown) && this._chartRenderer) {
      this._chartRenderer.setNoteIndicators(this.noteIndicators);
      this._chartRenderer.requestDraw();
    }
    
    this._animationId = requestAnimationFrame(() => this._updateLoop());
  }
  
  get currentTime() {
    return this.ctx?.currentTime || 0;
  }
}

// Export
if (typeof window !== 'undefined') {
  window.AudioLib = { Utils, Envelope, Synth, AudioSession };
}

```

## lib\audio.js

```javascript
// Global audio-related state used by main.js / ChartRenderer
let audioContext = null;
let analysers = [null, null];
let currentNote1 = null, currentNote2 = null;
const baseFrequency = 440;
let isMouseDown = false;
const audioParams = {
  oscillatorType: "sawtooth",
  filterFrequency: 1000,
  filterType: "lowpass",
  gainAttackTime: 0.05,
  gainSustainLevel: 0.5,
  gainReleaseTime: 0.2,
};
let activeNoteIndicators = [
  { noteIndex: 0, x: null, opacity: 0 },
  { noteIndex: 1, x: 0, opacity: 0 },
];
let reverbNode = null;
let tonicTimeout = null;

async function initAudio() {
  if (!audioContext) {
    audioContext = AudioLib.Utils.initAudio();
    if (!reverbNode) {
      reverbNode = audioContext.createConvolver();
      reverbNode.buffer = AudioLib.Utils.createImpulse(audioContext, 1.0, 2.0);
      const reverbMix = audioContext.createGain(); reverbMix.gain.value = 0.3;
      reverbNode.connect(reverbMix); reverbMix.connect(audioContext.destination);
    }
  }
}
function createNote(frequency, startTime, noteIndex) {
  const oscillator = audioContext.createOscillator();
  const gainNode = audioContext.createGain();
  const filter = audioContext.createBiquadFilter();
  const analyser = audioContext.createAnalyser();
  analyser.fftSize = 256; analysers[noteIndex] = analyser;
  oscillator.type = audioParams.oscillatorType; oscillator.frequency.value = frequency;
  filter.type = audioParams.filterType; filter.frequency.value = audioParams.filterFrequency;
  AudioLib.Envelope.attack(gainNode.gain, startTime, audioParams.gainSustainLevel, audioParams.gainAttackTime);
  oscillator.connect(filter); filter.connect(gainNode);
  gainNode.connect(analyser); gainNode.connect(reverbNode); analyser.connect(audioContext.destination);
  return { oscillator, gainNode };
}
function centsToFrequency(centsOffset) { return baseFrequency * Math.pow(2, centsOffset / 1200); }
function stopNote(note, stopTime) {
  if (note && note.gainNode && note.gainNode.gain && note.oscillator) {
    try {
      AudioLib.Envelope.release(note.gainNode.gain, stopTime, audioParams.gainReleaseTime);
      note.oscillator.stop(stopTime + audioParams.gainReleaseTime + 0.25);
    } catch(e){}
  }
}
function updateNoteIndicatorsOpacity(chartRenderer) {
  let needsRedraw = false;
  analysers.forEach((analyser, i) => {
    if (!analyser || !activeNoteIndicators[i]) return;
    const dataArray = new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteTimeDomainData(dataArray);
    let level = 0;
    for (let j = 0; j < dataArray.length; j++) level += Math.abs(dataArray[j] - 128);
    level = dataArray.length > 0 ? level / dataArray.length : 0;
    const newOpacity = Math.min(1, Math.max(0, level / 40));
    if (Math.abs(activeNoteIndicators[i].opacity - newOpacity) > 0.01) {
      activeNoteIndicators[i].opacity = newOpacity; needsRedraw = true;
    }
    if (i === 1 && currentNote2 && activeNoteIndicators[i].opacity <= 0.01) { activeNoteIndicators[i].opacity = 0; needsRedraw = true; }
    if (i === 0 && !currentNote1 && activeNoteIndicators[i].opacity <= 0.01) { activeNoteIndicators[i].opacity = 0; needsRedraw = true; }
  });
  if ((needsRedraw || isMouseDown) && chartRenderer) {
    chartRenderer.setNoteIndicators(activeNoteIndicators);
    chartRenderer.requestDraw();
  }
  requestAnimationFrame(() => updateNoteIndicatorsOpacity(chartRenderer));
}

// экспонируем на глобальный объект, main.js использует
window.audioAPI = {
  initAudio,
  createNote,
  stopNote,
  centsToFrequency,
  activeNoteIndicators,
  updateNoteIndicatorsOpacity,
  setIsMouseDown(v){ isMouseDown = v; },
  setCurrentNotes(n1, n2){ currentNote1 = n1; currentNote2 = n2; }
};

```

## lib\chart-renderer.js

```javascript
// ------------------ ChartRenderer (рендер графика) ------------------
class ChartRenderer {
  constructor(canvas, options = {}) {
    this.canvas = canvas;
    this.ctx = canvas.getContext("2d");
    this.data = [];
    this.annotations = [];
    this.options = {
      paddingTop: 20,
      paddingBottom: 30,
      paddingLeft: 40,
      paddingRight: 20,
      gridColor: "rgba(255,255,255,0.05)",
      textColor: "rgba(255,255,255,0.6)",
      annotationColor: "#BB86FC",
      lineColor: "#FFFFFF",
      noteIndicatorColor1: "rgba(30, 144, 255, 1)",
      noteIndicatorColor2: "rgba(255, 100, 0, 1)",
      lineWidth: 3,
      animationSpeed: 0.15,
      ...options,
    };
    this.currentView = { xMin: 0, xMax: 1200, yMin: 0, yMax: 1 };
    this.targetView = { ...this.currentView };
    this.animationFrameId = null;
    this.noteIndicators = [];
    this.isDrawing = false;
    this.drawRequestScheduled = false;
    this.pixelRatio = window.devicePixelRatio || 1;
    this.resizeObserver = new ResizeObserver(() => { this.requestDraw(); });
    if (this.canvas.parentElement) this.resizeObserver.observe(this.canvas.parentElement);
    this.resizeCanvas();
    this.requestDraw();
  }
  setAnnotations(annotations) { this.annotations = annotations || []; this.requestDraw(); }
  setNoteIndicators(indicators) { this.noteIndicators = indicators || []; }
  setData(data) { this.data = Array.isArray(data) ? data : []; this.autoScale(); }

  // plotHE теперь принимает флаг invert и сохраняет его в экземпляре,
  // чтобы draw() мог позиционировать подписи корректно.
  plotHE(HE, annotations, invert = false) {
    this.invert = !!invert; // true/false
    if (!HE || HE.length === 0) {
      this.setData([]); this.setAnnotations([]); return;
    }
    // сохраняем данные/аннотации и запускаем перерисовку/масштабирование
    this.setData(HE);
    this.setAnnotations(annotations || []);
  }

  resizeCanvas() {
    const parent = this.canvas.parentElement; if (!parent) return false;
    const cssWidth = parent.clientWidth, cssHeight = parent.clientHeight;
    this.pixelRatio = window.devicePixelRatio || 1;
    const targetWidth = Math.round(cssWidth * this.pixelRatio);
    const targetHeight = Math.round(cssHeight * this.pixelRatio);
    if (cssWidth <= 0 || cssHeight <= 0) { if (this.canvas.width !== 0 || this.canvas.height !== 0) { this.canvas.width = 0; this.canvas.height = 0; return true; } return false; }
    if (this.canvas.width === targetWidth && this.canvas.height === targetHeight) return false;
    this.canvas.width = targetWidth; this.canvas.height = targetHeight;
    this.ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
    return true;
  }
  autoScale() {
    let xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity;
    if (this.data.length > 0) {
      this.data.forEach((point) => {
        if (!Number.isFinite(point.x) || !Number.isFinite(point.y)) return;
        xMin = Math.min(xMin, point.x); xMax = Math.max(xMax, point.x);
        yMin = Math.min(yMin, point.y); yMax = Math.max(yMax, point.y);
      });
    }
    if (xMin === Infinity) { xMin = 0; xMax = 1200; yMin = 0; yMax = 1; }
    if (xMin === xMax) { xMin -= 100; xMax += 100; }
    if (yMin === yMax) { yMin -= 0.5; yMax += 0.5; }
    const xPadding = (xMax - xMin) * 0.01;
    const yPadding = (yMax - yMin) * 0.05;
    this.targetView.xMin = xMin - xPadding;
    this.targetView.xMax = xMax + xPadding;
    this.targetView.yMin = Math.floor((yMin - yPadding) * 10) / 10;
    this.targetView.yMax = Math.ceil((yMax + yPadding) * 10) / 10;
    this.startAnimationLoop();
  }
  startAnimationLoop() { if (this.animationFrameId === null) this.animationStep(); }
  stopAnimationLoop() { if (this.animationFrameId !== null) { cancelAnimationFrame(this.animationFrameId); this.animationFrameId = null; } }
  animationStep() {
    const speed = 1.0 - this.options.animationSpeed;
    let changed = false; const epsilon = 1e-5;
    for (const key of ['xMin','xMax','yMin','yMax']) {
      const current = this.currentView[key], target = this.targetView[key]; const diff = target - current;
      if (Math.abs(diff) > epsilon) { this.currentView[key] = current + diff * (1 - speed); changed = true; } else { this.currentView[key] = target; }
    }
    if (changed) { this.requestDraw(); this.animationFrameId = requestAnimationFrame(() => this.animationStep()); }
    else { this.stopAnimationLoop(); if (JSON.stringify(this.currentView) !== JSON.stringify(this.targetView)) { this.currentView = { ...this.targetView }; this.requestDraw(); } }
  }
  requestDraw() {
    if (!this.drawRequestScheduled) {
      this.drawRequestScheduled = true;
      requestAnimationFrame(() => { this.draw(); this.drawRequestScheduled = false; });
    }
  }
  draw() {
    if (this.isDrawing) return; this.isDrawing = true;
    this.resizeCanvas();
    if (this.canvas.width === 0 || this.canvas.height === 0) { this.isDrawing = false; return; }
    const { clientWidth: cssWidth, clientHeight: cssHeight } = this.canvas.parentElement;
    const { ctx, options } = this;
    ctx.clearRect(0, 0, cssWidth, cssHeight);
    const gx = options.paddingLeft, gy = options.paddingTop;
    const gw = cssWidth - options.paddingLeft - options.paddingRight;
    const gh = cssHeight - options.paddingTop - options.paddingBottom;
    if (gw <= 0 || gh <= 0) { this.isDrawing = false; return; }

    const { xMin, xMax, yMin, yMax } = this.currentView;
    const xRange = xMax - xMin, yRange = yMax - yMin;
    if (!xRange || !yRange || !Number.isFinite(xMin) || !Number.isFinite(xMax) || !Number.isFinite(yMin) || !Number.isFinite(yMax)) {
      this.isDrawing = false; return;
    }

    // Grid
    ctx.lineWidth = 1; ctx.strokeStyle = options.gridColor; ctx.fillStyle = options.textColor; ctx.font = "10px Arial";
    const xStep = 100; const startX = Math.ceil(xMin / xStep) * xStep; ctx.textAlign = "center"; ctx.textBaseline = "top";
    for (let x = startX; x <= xMax; x += xStep) {
      const screenX = gx + ((x - xMin) / xRange) * gw; const sharpX = Math.round(screenX);
      if (sharpX >= gx && sharpX <= gx + gw) {
        ctx.beginPath(); ctx.moveTo(sharpX, gy); ctx.lineTo(sharpX, gy + gh); ctx.stroke();
        if (sharpX > gx + 10 && sharpX < gx + gw - 10) ctx.fillText(x.toFixed(0), sharpX, gy + gh + 4);
      }
    }
    ctx.textAlign = "left"; ctx.fillText(xMin.toFixed(0), gx, gy + gh + 4);
    ctx.textAlign = "right"; ctx.fillText(xMax.toFixed(0), gx + gw, gy + gh + 4);

    const yTargetSteps = Math.max(3, Math.floor(gh / 40));
    const roughYStep = yRange / yTargetSteps;
    let yStep = roughYStep > 0 ? Math.pow(10, Math.floor(Math.log10(roughYStep))) : 0.1;
    const mult = yTargetSteps > 0 ? yRange / (yStep * yTargetSteps) : 1; if (mult > 5) yStep *= 5; else if (mult > 2) yStep *= 2;
    const yNumDecimals = yStep > 0 ? Math.max(0, -Math.floor(Math.log10(yStep) + 0.01)) : 1;
    const startY = yStep > 0 ? Math.ceil(yMin / yStep) * yStep : yMin;
    ctx.textAlign = "right"; ctx.textBaseline = "middle";
    for (let y = startY; y <= yMax; y += yStep) {
      if (yStep <= 0) break;
      const screenY = gy + gh - ((y - yMin) / yRange) * gh; const sharpY = Math.round(screenY);
      if (sharpY >= gy && sharpY <= gy + gh) {
        ctx.beginPath(); ctx.moveTo(gx, sharpY); ctx.lineTo(gx + gw, sharpY); ctx.stroke();
        if (sharpY > gy + 8 && sharpY < gy + gh - 8) ctx.fillText(y.toFixed(yNumDecimals), gx - 5, sharpY);
      }
    }
    ctx.textBaseline = "bottom"; ctx.fillText(yMin.toFixed(1), gx - 5, gy + gh);
    ctx.textBaseline = "top"; ctx.fillText(yMax.toFixed(1), gx - 5, gy);

    // Data line
    if (this.data.length >= 1) {
      ctx.beginPath();
      let firstPointDrawn = false;
      let startIndex = this.data.findIndex(p => p.x >= xMin); if (startIndex === -1) startIndex = this.data.length;
      let endIndex = this.data.length; for(let i = startIndex; i < this.data.length; i++) { if (this.data[i].x > xMax) { endIndex = i + 1; break; } }
      if (startIndex > 0) startIndex--;
      for (let i = startIndex; i < Math.min(endIndex, this.data.length); i++) {
        const p = this.data[i]; if (!p || !Number.isFinite(p.x) || !Number.isFinite(p.y)) continue;
        const screenX = gx + ((p.x - xMin) / xRange) * gw;
        const screenY = gy + gh - ((p.y - yMin) / yRange) * gh;
        const clampedY = Math.max(gy, Math.min(gy + gh, screenY));
        if (!firstPointDrawn) { ctx.moveTo(screenX, clampedY); firstPointDrawn = true; } else { ctx.lineTo(screenX, clampedY); }
      }
      if (firstPointDrawn) {
        ctx.strokeStyle = this.options.lineColor; ctx.lineWidth = this.options.lineWidth; ctx.lineJoin = "round"; ctx.lineCap = "round"; ctx.stroke();
      }
    }

    // Annotations (позиционирование подписей зависит от this.invert)
    if (this.annotations && this.annotations.length) {
      const xRange2 = xMax - xMin, yRange2 = yMax - yMin;
      ctx.font = "12px Arial";
      ctx.textAlign = "center";

      // Параметры смещения подписи относительно точки:
      // invert === true  -> подписи НАД кривой  (baseline = 'bottom', y = screenY - offset)
      // invert === false -> подписи ПОД кривой  (baseline = 'top',    y = screenY + offset)
      const labelOffset = 8; // px; подправь по вкусу
      const invertFlag = !!this.invert;
      ctx.textBaseline = invertFlag ? "bottom" : "top";

      for (const ann of this.annotations) {
        // ожидаем: ann.x и ann.y — в координатах данных (не в пикселях)
        if (ann.x < xMin || ann.x > xMax) continue;
        const screenX = gx + ((ann.x - xMin) / xRange2) * gw;
        const screenY = gy + gh - ((ann.y - yMin) / yRange2) * gh;

        // рисуем маркер
        ctx.fillStyle = this.options.annotationColor;
        ctx.beginPath();
        ctx.arc(screenX, screenY, 5, 0, Math.PI * 2);
        ctx.fill();

        // позиция текста: над/под точкой
        const textY = invertFlag ? (screenY - labelOffset) : (screenY + labelOffset);

        // читаемость: рисуем контур + заливку (как в других местах)
        ctx.fillStyle = this.options.textColor;
        // обводка для читаемости (толстая тёмная линия)
        ctx.strokeStyle = "rgba(0,0,0,0.6)";
        ctx.lineWidth = 3;
        ctx.strokeText(ann.label, screenX, textY);
        ctx.fillText(ann.label, screenX, textY);
      }
      // восстановим параметры lineWidth/strokeStyle, если нужно (необязательно)
      ctx.lineWidth = this.options.lineWidth;
      ctx.strokeStyle = this.options.gridColor;
    }


    // Note indicators
    if (this.noteIndicators && this.noteIndicators.length) {
      ctx.lineWidth = 2; ctx.setLineDash([4, 4]);
      for (const ind of this.noteIndicators) {
        if (!ind || ind.x === null || ind.opacity <= 0.01) continue;
        if (ind.x < xMin || ind.x > xMax) continue;
        const screenX = gx + ((ind.x - xMin) / xRange) * gw;
        const baseColor = ind.noteIndex === 0 ? this.options.noteIndicatorColor1 : this.options.noteIndicatorColor2;
        let colorWithAlpha = baseColor;
        if (baseColor.startsWith("rgba")) colorWithAlpha = baseColor.replace(/(\d+(\.\d+)?)\)$/, `${ind.opacity.toFixed(2)})`);
        else if (baseColor.startsWith("rgb")) colorWithAlpha = baseColor.replace("rgb","rgba").replace(")", `, ${ind.opacity.toFixed(2)})`);
        ctx.strokeStyle = colorWithAlpha;
        ctx.beginPath(); const sharpX = Math.round(screenX); ctx.moveTo(sharpX, gy); ctx.lineTo(sharpX, gy + gh); ctx.stroke();
      }
      ctx.setLineDash([]);
    }
    this.isDrawing = false;
  }
}
```

## lib\entropy.js

```javascript
/**
 * UNIFIED HARMONIC ENTROPY 2.0
 * Обобщает алгоритм вычисления гармонической энтропии (P. Erlich)
 * и взвешенных метрик консонанса (Euler, Murzin, и др.) через FFT.
 * 
 * Заменяет собой HarmonicEntropyCalculator и ConsonanceWeightedHE.
 */

// ------------------ FFT (Standard implementation) ------------------
class FFT {
    constructor(size) {
        this.size = size;
        this.real = new Float32Array(size);
        this.imag = new Float32Array(size);
    }
    forward(input) {
        const n = this.size;
        this.real.set(input);
        this.imag.fill(0);
        this._transform(this.real, this.imag, n, 1);
    }
    inverse() {
        const n = this.size;
        this._transform(this.real, this.imag, n, -1);
        for (let i = 0; i < n; i++) {
            this.real[i] /= n;
            this.imag[i] /= n;
        }
        return this.real; // Возвращаем TypedArray для скорости
    }
    _transform(real, imag, n, direction) {
        const nn = n === 1 ? 0 : Math.log2(n);
        if (Math.pow(2, nn) !== n) throw new Error("FFT Size must be power of 2");
        
        for (let i = 0; i < n; i++) {
            const j = this._reverseBits(i, nn);
            if (j > i) {
                [real[i], real[j]] = [real[j], real[i]];
                [imag[i], imag[j]] = [imag[j], imag[i]];
            }
        }
        for (let s = 1; s <= nn; s++) {
            const m = 1 << s;
            const mh = m >> 1;
            const thetaBase = direction * (-2 * Math.PI / m);
            
            for (let k = 0; k < n; k += m) {
                for (let j = 0; j < mh; j++) {
                    const kr = k + j;
                    const ki = kr + mh;
                    const theta = thetaBase * j;
                    const wr = Math.cos(theta);
                    const wi = Math.sin(theta);
                    const tr = real[ki] * wr - imag[ki] * wi;
                    const ti = real[ki] * wi + imag[ki] * wr;
                    real[ki] = real[kr] - tr;
                    imag[ki] = imag[kr] - ti;
                    real[kr] += tr;
                    imag[kr] += ti;
                }
            }
        }
    }
    _reverseBits(x, bits) {
        let y = 0;
        for (let i = 0; i < bits; i++) {
            y = (y << 1) | (x & 1);
            x >>= 1;
        }
        return y;
    }
}

// ------------------ UnifiedEntropyCalculator ------------------
class UnifiedEntropyCalculator {
    constructor() {
        this.ratios = []; // Хранит { p, q, w, cent }
        this.cacheKey = ""; 
    }

    /**
     * Генерация списка дробей и их весов.
     * @param {number} N - Лимит сложности (для HE: p*q <= N).
     * @param {string} method - 'he-classic', 'murzin', 'euler', etc.
     * @param {number} beta - Степенной коэффициент для весов (1.0 = стандарт).
     */
    async generateRatios({ N = 3000, method = 'he-classic', beta = 1.0 }) {
        const currentKey = `${N}-${method}-${beta}`;
        if (this.cacheKey === currentKey && this.ratios.length > 0) return;

        this.ratios = [];
        this.cacheKey = currentKey;

        // All consonance methods are now in ji-lib.js
        const baseWeightFn = (p, q) => jiLib.computeConsonance(p, q, method);
        const weightFn = (p, q) => {
            const w = baseWeightFn(p, q);
            return (beta === 1.0) ? w : Math.pow(w, beta);
        };

        return new Promise((resolve) => {
            // Асинхронная генерация чанками, чтобы не фризить UI
            let nIter = N;
            const processChunk = () => {
                const start = performance.now();
                while (nIter > 0 && performance.now() - start < 15) {
                    // Генерируем по Farey sequence logic (p*q <= N) для равномерного распределения энтропии
                    const maxI = Math.floor(Math.sqrt(nIter));
                    for (let i = 1; i <= maxI; i++) {
                        if (nIter % i === 0) {
                            const p = i;
                            const q = nIter / i;
                            if (jiLib.gcd(p, q) === 1) {
                                this._addRatio(p, q, weightFn);
                                if (p !== q) this._addRatio(q, p, weightFn);
                            }
                        }
                    }
                    nIter--;
                }

                if (nIter > 0) {
                    setTimeout(processChunk, 0);
                } else {
                    this.ratios.sort((a, b) => a.cent - b.cent);
                    resolve();
                }
            };
            processChunk();
        });
    }

    _addRatio(p, q, weightFn) {
        const w = weightFn(p, q);
        if (w < 1e-12) return;
        const ratioVal = p / q;
        const cent = 1200 * Math.log2(ratioVal);
        this.ratios.push({ p, q, w, cent });
    }

    convolve(inputA, inputB) {
        const lenA = inputA.length;
        const lenB = inputB.length;
        const outLen = lenA + lenB - 1;
        let minlen = 1;
        while (minlen < outLen) minlen *= 2;

        const A = new Float32Array(minlen);
        const B = new Float32Array(minlen);
        A.set(inputA);
        B.set(inputB);

        const fftA = new FFT(minlen);
        const fftB = new FFT(minlen);
        fftA.forward(A);
        fftB.forward(B);

        const real = new Float32Array(minlen);
        const imag = new Float32Array(minlen);
        for (let i = 0; i < minlen; i++) {
            real[i] = fftA.real[i] * fftB.real[i] - fftA.imag[i] * fftB.imag[i];
            imag[i] = fftA.real[i] * fftB.imag[i] + fftA.imag[i] * fftB.real[i];
        }

        const fftOut = new FFT(minlen);
        fftOut.real = real;
        fftOut.imag = imag;
        
        return fftOut.inverse();
    }

    /**
     * Основной расчет кривой
     * @param {Object} params - { mincents, maxcents, s, a, res }
     * s - ширина сглаживания в центах (или % от полутона, см. логику ниже)
     * a - коэффициент Реньи
     */
    calculateCurve({ mincents = 0, maxcents = 1200, s = 1.25, a = 2, res = 1 }) {
        if (this.ratios.length === 0) return [];

        // Логика конвертации s (из UI приходит 0.5...2.5) в центы
        // Если s ~ 1.0, считаем это % от 100 центов (как было в CWHE слайдере) -> 10 центов
        const sigmaCents = s * 10; 
        
        const padding = Math.ceil(4 * sigmaCents);
        const gridMin = mincents - padding;
        const gridMax = maxcents + padding;
        const size = Math.floor((gridMax - gridMin) / res) + 1;
        
        const K = new Float32Array(size).fill(0);
        const AK = new Float32Array(size).fill(0);

        // Биннинг весов
        for (const r of this.ratios) {
            if (r.cent < gridMin || r.cent > gridMax) continue;
            // Линейная интерполяция
            const exactIdx = (r.cent - gridMin) / res;
            const idx = Math.floor(exactIdx);
            const frac = exactIdx - idx;
            
            if (idx >= 0 && idx < size - 1) {
                const w = r.w;
                const wa = Math.pow(w, a);
                K[idx] += w * (1 - frac);
                K[idx + 1] += w * frac;
                AK[idx] += wa * (1 - frac);
                AK[idx + 1] += wa * frac;
            }
        }

        // Ядро Гаусса
        const kernelRadius = Math.ceil(4 * sigmaCents / res);
        const kernelSize = kernelRadius * 2 + 1;
        const G = new Float32Array(kernelSize);
        const twoSigmaSq = 2 * sigmaCents * sigmaCents;
        const normFactor = 1 / (sigmaCents * Math.sqrt(2 * Math.PI));
        
        let gSum = 0;
        for (let i = 0; i < kernelSize; i++) {
            const dist = (i - kernelRadius) * res;
            const val = normFactor * Math.exp(-(dist * dist) / twoSigmaSq);
            G[i] = val;
            gSum += val;
        }
        const AG = new Float32Array(kernelSize);
        for (let i = 0; i < kernelSize; i++) {
            G[i] /= gSum;
            AG[i] = Math.pow(G[i], a);
        }

        // Свертка
        const entRaw = this.convolve(AK, AG);
        const nrmRaw = this.convolve(K, G);

        const result = [];
        // Индекс начала данных (компенсация паддинга и радиуса ядра)
        // Сетка начиналась с gridMin (mincents - padding).
        // Свертка сдвигает на kernelRadius.
        // Нам нужны данные начиная с mincents.
        const offset = Math.floor((mincents - gridMin) / res) + kernelRadius;
        
        const plotPoints = Math.floor((maxcents - mincents) / res);
        const epsilon = 1e-15;

        for (let i = 0; i <= plotPoints; i++) {
            const arrIdx = offset + i;
            if (arrIdx < 0 || arrIdx >= entRaw.length) {
                result.push({ x: mincents + i * res, y: 0 });
                continue;
            }

            const entVal = entRaw[arrIdx] + epsilon;
            const nrmVal = nrmRaw[arrIdx] + epsilon;
            // Формула Реньи
            const y = (1 / (1 - a)) * Math.log(entVal / Math.pow(nrmVal, a));
            
            result.push({ x: mincents + i * res, y: y });
        }

        return result;
    }

    /**
     * Поиск минимумов (консонансов)
     */
    findExtrema(curveData, threshold = 0.001) {
        const points = [];
        const w = 5;
        for (let i = w; i < curveData.length - w; i++) {
            const cy = curveData[i].y;
            // Локальный минимум
            if (cy < curveData[i-1].y && cy < curveData[i+1].y) {
                // Проверка "выраженности" минимума
                const leftDiff = curveData[i-w].y - cy;
                const rightDiff = curveData[i+w].y - cy;
                if (leftDiff > threshold && rightDiff > threshold) {
                    points.push({ x: curveData[i].x, y: cy });
                }
            }
        }
        return points.sort((a, b) => a.y - b.y);
    }

    annotateExtrema(extrema, tolerance = 15) {
        const anns = [];
        for (const ex of extrema) {
            // Ищем дробь
            let bestR = null;
            let maxW = -1;
            
            // Оптимизация: бинарный поиск или просто фильтр, если массив большой
            // Для 3000-10000 элементов простой фильтр приемлем
            for (const r of this.ratios) {
                if (Math.abs(r.cent - ex.x) < tolerance) {
                    if (r.w > maxW) {
                        maxW = r.w;
                        bestR = r;
                    }
                }
            }
            if (bestR) {
                anns.push({
                    x: ex.x,
                    y: ex.y,
                    label: `${bestR.p}/${bestR.q}`
                });
            }
        }
        return anns;
    }
}

// Экспорт для браузера
window.UnifiedEntropyCalculator = UnifiedEntropyCalculator;
window.FFT = FFT;
```

## lib\generate_modes.js

```javascript
/**
 * generate_modes.js - Генератор JI ладов
 * Зависит от: ji-lib.js (должен быть загружен первым)
 */
(function(global) {
  'use strict';

  const jiLib = global.jiLib;
  if (!jiLib) throw new Error('ji-lib.js must be loaded before generate_modes.js');

  const RationalInterval = jiLib.RationalInterval;
  const primeFactorsFull = jiLib.primeFactorsFull;
  const consonanceMethods = jiLib.consonanceMethods;

  /* ==================================================
     CONSTANTS
     ================================================== */
  
  const MAX_SCALES = 100;

  /* ==================================================
     HELPER FUNCTIONS
     ================================================== */

  /**
   * Вычисляет консонанс интервала указанным методом
   * @param {RationalInterval} r - интервал
   * @param {string} method - название метода ('murzin', 'euler', etc.)
   * @returns {number}
   */
  function intervalConsonance(r, method = 'murzin') {
    const fn = consonanceMethods[method] || consonanceMethods['murzin'];
    return fn(r.numerator, r.denominator);
  }

  /**
   * Вычисляет среднюю консонансу лада (всех пар интервалов)
   * @param {RationalInterval[]} scale - массив интервалов
   * @param {string} method - метод консонанса
   * @returns {number}
   */
  function scaleConsonance(scale, method = 'murzin') {
    const sorted = scale.slice().sort((a, b) => a.toDecimal() - b.toDecimal());
    const pairs = [];
    
    for (let i = 0; i < sorted.length; i++) {
      for (let j = i + 1; j < sorted.length; j++) {
        const ratio = sorted[j].divide(sorted[i]).normalize();
        pairs.push(intervalConsonance(ratio, method));
      }
    }
    
    return pairs.length > 0 
      ? pairs.reduce((a, b) => a + b, 0) / pairs.length 
      : 1.0;
  }

  /**
   * Проверка odd-limit
   * @param {number} limit - максимальный odd-limit
   * @param {RationalInterval} r - интервал
   * @returns {boolean}
   */
  function oddLimit(limit, r) {
    return r.numerator <= limit || r.denominator <= limit;
  }

  /**
   * Проверка prime-limit для генерации ладов
   * Запрет простых >7, ограничения на экспоненты
   * @param {RationalInterval} r - интервал
   * @returns {boolean}
   */
  function checkPrimeLimit(r) {
    const fnum = primeFactorsFull(r.numerator);
    const fden = primeFactorsFull(r.denominator);

    // Запрет любых простых > 7
    const combinedPrimes = new Set([
      ...Object.keys(fnum).map(Number), 
      ...Object.keys(fden).map(Number)
    ]);
    
    for (const p of combinedPrimes) {
      if (p > 7) return false;
    }

    // Суммарные экспоненты для 3, 5, 7
    const exp3 = (fnum[3] || 0) + (fden[3] || 0);
    const exp5 = (fnum[5] || 0) + (fden[5] || 0);
    const exp7 = (fnum[7] || 0) + (fden[7] || 0);

    // Ограничения
    if (exp3 > 4) return false;           // не более 4 троек
    if ((exp5 + exp7) > 2) return false;  // не более 2 пятёрок/семёрок суммарно
    if (exp7 > 1) return false;           // не более 1 семёрки

    return true;
  }

  /**
   * Вставка лада в отсортированный массив (по консонансу)
   * @param {Array} scales - массив ладов
   * @param {RationalInterval[]} newScale - новый лад
   * @param {number} cons - консонанс
   * @returns {boolean} - был ли добавлен
   */
  function insertScale(scales, newScale, cons) {
    const key = newScale.map(r => r.toString()).sort().join('|');
    
    // Проверка дубликатов
    if (scales.some(entry => entry.key === key)) return false;
    
    const newEntry = { 
      consonance: cons, 
      scale: newScale, 
      key, 
      n: newScale.length 
    };
    
    // Бинарный поиск позиции для вставки
    let pos = scales.findIndex(entry => entry.consonance < cons);
    if (pos === -1) {
      scales.push(newEntry);
    } else {
      scales.splice(pos, 0, newEntry);
    }
    
    // Ограничение размера
    if (scales.length > MAX_SCALES) scales.pop();
    
    return true;
  }

  /**
   * Генерация базовых интервалов для построения ладов
   * @param {number} cutoff - ограничение odd-limit
   * @returns {RationalInterval[]}
   */
  function generateBaseIntervals(cutoff) {
    const baseRatios = [];
    
    for (let i = 3; i <= 45; i++) {
      for (let j = i + 1; j <= 45; j++) {
        baseRatios.push(new RationalInterval(j, i));
      }
    }
    
    // Фильтрация: применяем primeLimit и oddLimit
    const filtered = baseRatios.filter(r => 
      checkPrimeLimit(r) && oddLimit(cutoff, r)
    );

    // Удаление дубликатов после нормализации
    const seen = new Set();
    const intervals = [];
    
    for (const r of filtered) {
      const nr = r.normalize();
      const key = nr.toString();
      if (!seen.has(key)) {
        seen.add(key);
        intervals.push(nr);
      }
    }
    
    return intervals;
  }

  /**
   * Основная функция генерации ладов
   * @param {Object} options - параметры генерации
   * @param {number} options.minNotes - минимальное число нот (default: 3)
   * @param {number} options.maxNotes - максимальное число нот (default: 8)
   * @param {number} options.searchLimit - ограничение odd-limit (default: 32)
   * @param {number} options.minConsonance - минимальная консонанса (default: 0.2)
   * @param {string} options.method - метод консонанса (default: 'murzin')
   * @param {Function} options.onProgress - callback для прогресса (optional)
   * @returns {Promise<Object>} - объект scalesDB где ключи — число нот
   */
  async function generateScales(options = {}) {
    const {
      minNotes = 3,
      maxNotes = 8,
      searchLimit = 32,
      minConsonance = 0.2,
      method = 'murzin',
      onProgress = null
    } = options;

    const scalesDB = {};
    const unison = new RationalInterval(1, 1);
    
    // База: лад из одной ноты (унисон)
    scalesDB[1] = [{ 
      consonance: 1.0, 
      scale: [unison], 
      key: unison.toString(), 
      n: 1 
    }];
    
    const intervals = generateBaseIntervals(searchLimit);

    // Рекурсивная генерация от 2 до maxNotes
    for (let n = 2; n <= maxNotes; n++) {
      // Callback прогресса
      if (onProgress && n >= minNotes) {
        onProgress(n, maxNotes);
        // Даём браузеру шанс отрисовать
        await new Promise(resolve => setTimeout(resolve, 0));
      }

      const newScales = [];
      const prev = scalesDB[n - 1] || [];
      
      for (const entry of prev) {
        const scale = entry.scale;
        
        for (const baseNote of scale) {
          for (const interval of intervals) {
            // Пробуем добавить интервал вверх и вниз
            const newNoteUp = baseNote.multiply(interval).normalize();
            const newNoteDown = baseNote.divide(interval).normalize();
            
            for (const newNote of [newNoteUp, newNoteDown]) {
              // Проверка: нота ещё не в ладе
              if (scale.some(r => r.toString() === newNote.toString())) continue;
              
              // Создаём кандидата
              const candidate = scale.slice();
              candidate.push(newNote);
              candidate.sort((a, b) => a.toDecimal() - b.toDecimal());
              
              if (candidate.length === n) {
                const cons = scaleConsonance(candidate, method);
                if (cons >= minConsonance) {
                  insertScale(newScales, candidate, cons);
                }
              }
            }
          }
        }
      }
      
      scalesDB[n] = newScales;
    }
    
    return scalesDB;
  }

  /**
   * Преобразует scalesDB в плоский массив
   * @param {Object} scalesDB - результат generateScales
   * @param {number} minNotes - минимальное число нот для включения
   * @returns {Array}
   */
  function flattenScales(scalesDB, minNotes = 3) {
    const result = [];
    
    for (const n in scalesDB) {
      if (parseInt(n) < minNotes) continue;
      
      for (const entry of scalesDB[n]) {
        result.push({ 
          n: parseInt(n), 
          consonance: entry.consonance, 
          scale: entry.scale, 
          key: entry.key 
        });
      }
    }
    
    // Сортировка: по консонансу (desc), затем по числу нот (asc)
    result.sort((a, b) => {
      if (b.consonance !== a.consonance) return b.consonance - a.consonance;
      return a.n - b.n;
    });
    
    return result;
  }

  /**
   * JI-интервал → ближайший темперированный полутон
   * @param {RationalInterval} r
   * @returns {number}
   */
  function jiToSemitone(r) {
    return Math.round(Math.log2(r.toDecimal()) * 12);
  }

  /**
   * Создаёт ключ для поиска названия лада
   * @param {number[]} semitones - массив полутонов
   * @returns {string}
   */
  // function makeKeyFromSemitones(semitones) {
  //   const classes = semitones
  //     .map(s => ((s % 12) + 12) % 12)
  //     .sort((a, b) => a - b);
  //   return `{${classes.join(', ')}}`;
  // }

    function makeKeyFromSemitones(semitones) {
      const classes = [...new Set(
        semitones
          .map(s => ((s % 12) + 12) % 12)
          .sort((a, b) => a - b)
      )];
      return `{${classes.join(', ')}}`;
    }


  /**
   * Генерирует название лада
   * @param {RationalInterval[]} scale - лад
   * @param {Object} namesMap - карта названий (optional)
   * @returns {string}
   */
  function generateScaleName(scale, namesMap = null) {
    const semitones = scale.map(jiToSemitone);
    const key = makeKeyFromSemitones(semitones);
    
    // Используем глобальную карту если не передана
    const map = namesMap || (typeof scalesNamesMap !== 'undefined' ? scalesNamesMap : null);
    const names = map ? map[key] : null;
    
    return (names && names.length > 0) 
      ? names.join(', ') 
      : ('Лад ' + scale.length);
  }

  /* ==================================================
     EXPORT
     ================================================== */

  const ModeGenerator = {
    // Основные функции
    generateScales,
    flattenScales,
    
    // Утилиты для анализа
    scaleConsonance,
    intervalConsonance,
    checkPrimeLimit,
    oddLimit,
    
    // Утилиты для именования
    jiToSemitone,
    makeKeyFromSemitones,
    generateScaleName,
    
    // Константы
    MAX_SCALES
  };

  global.ModeGenerator = ModeGenerator;

})(typeof globalThis !== 'undefined' ? globalThis : window);
```

## lib\ji-lib.js

```javascript
(function(global) {
  'use strict';

  /* ==================================================
     INTERNAL STATE & CACHES
     ================================================== */
  
  const _consCache = new Map();
  const _factorsCache = new Map();

  /* ==================================================
     MATH HELPERS
     ================================================== */

  function gcd(a, b) {
    a = Math.abs(a); b = Math.abs(b);
    while (b) { let t = b; b = a % b; a = t; }
    return a;
  }

  function lcm(a, b) {
    if (a === 0 || b === 0) return 0;
    return Math.abs(a * b) / gcd(a, b);
  }

    // НОД для двух рациональных интервалов
  function gcdOfRationals(a, b) {
    const gcdOfNumerators = jiLib.gcd(a.numerator, b.numerator);
    const lcmOfDenominators = jiLib.lcm(a.denominator, b.denominator);
    return new jiLib.RationalInterval(gcdOfNumerators, lcmOfDenominators);
  }

  function getPrimeFactors(n) {
    n = Math.abs(Math.floor(n));
    if (n <= 1) return {};
    
    if (_factorsCache.has(n)) return _factorsCache.get(n);

    const f = {}; 
    let tempN = n;

    while (tempN % 2 === 0) { f[2] = (f[2]||0)+1; tempN /= 2; }
    let d = 3;
    while (d*d <= tempN) {
      while (tempN % d === 0) { f[d] = (f[d]||0)+1; tempN /= d; }
      d += 2;
    }
    if (tempN > 1) f[tempN] = (f[tempN]||0)+1;
    
    _factorsCache.set(n, f);
    return f;
  }

  // ✅ Совместимость с core - принимает (n, d)
  function toSemitones(n, d) {
    return Math.round(12 * Math.log2(n / d));
  }

  /* ==================================================
     RATIO STRUCT & ARITHMETIC
     ================================================== */

  function createRatio(num, den) {
    if (!Number.isFinite(num) || !Number.isFinite(den)) {
      return { num: 1, den: 1 };
    }
    if (Math.abs(den) < 1e-9) return { num: 1, den: 1 };

    const common = gcd(num, den);
    const s = (num * den < 0) ? -1 : 1;
    
    return { 
      num: s * Math.abs(num / common), 
      den: Math.abs(den / common) 
    };
  }

  const multiply = (a, b) => createRatio(a.num * b.num, a.den * b.den);
  const divide   = (a, b) => createRatio(a.num * b.den, a.den * b.num);

  function normalize(ratio) {
    let { num, den } = ratio;
    if (num <= 0 || den <= 0) return createRatio(Math.abs(num), Math.abs(den));
    let val = num / den;
    while (val < 1) { num *= 2; val = num / den; }
    while (val >= 2) { den *= 2; val = num / den; }
    return createRatio(num, den);
  }

  /* ==================================================
     EDO & CONVERSIONS
     ================================================== */

  const toEDO = (ratio, steps) => steps * Math.log2(Math.abs(ratio.num / ratio.den));
  const toCents = (ratio) => toEDO(ratio, 1200);
  const ratioToSemitones = (ratio) => Math.round(toEDO(ratio, 12));
  const toDecimal = (ratio) => ratio.num / ratio.den;

  /* ==================================================
     ANALYSIS
     ================================================== */

  function primeLimit(ratio, limits) {
    const fnum = getPrimeFactors(ratio.num);
    const fden = getPrimeFactors(ratio.den);
    
    const count3 = (fnum[3]||0) + (fden[3]||0);
    const count5 = (fnum[5]||0) + (fden[5]||0);
    const count7 = (fnum[7]||0) + (fden[7]||0);
    
    let countExtra = 0;
    const allPrimes = new Set([...Object.keys(fnum), ...Object.keys(fden)]);
    for (const pStr of allPrimes) {
      const p = Number(pStr);
      if (p > 7) countExtra += (fnum[p]||0) + (fden[p]||0);
    }

    return (
      count3 <= (limits[3] || 0) &&
      count5 <= (limits[5] || 0) &&
      count7 <= (limits[7] || 0) &&
      (limits.extra === undefined ? true : (countExtra <= (limits.extra || 0)))
    );
  }

  /* ==================================================
     CONSONANCE METHODS - ✅ ПОЛНАЯ СОВМЕСТИМОСТЬ С CORE
     ================================================== */

  const Methods = {
    heClassic: {
      desc: `<b>HE Classic (Erlich):</b> 1 / √(N × D).<br>
             Paul Erlich's original Harmonic Entropy weight.<br>
             Based on Farey mediant probability: simpler ratios 
             with smaller N×D product are more likely to be perceived 
             under Gaussian pitch uncertainty.`,
      calc(n, d) {
        return 1 / Math.sqrt(n * d);
      }
    },

    murzin: {
      desc: '<b>Murzin:</b> 1/N + 1/D. Classic simplicity metric.',
      calc(n, d) {
        return 1 / n + 1 / d;
      }
    },

    euler: {
      desc: '<b>Euler:</b> 1 / (1 + Gradus/5). Weighted prime exponents.',
      calc(n, d) {
        const factors = { ...getPrimeFactors(n) };
        const dFactors = getPrimeFactors(d);
        
        for (const k in dFactors) {
          factors[k] = (factors[k] || 0) + dFactors[k];
        }

        let gradus = 0;
        for (const k in factors) {
          gradus += (Number(k) - 1) * factors[k];
        }

        return 1 / (1 + gradus / 5);
      }
    },

    sopfr: {
      desc: '<b>Sum of Primes:</b> 1 / (1 + Sum(factors)/5). Sum of all prime factors.',
      calc(n, d) {
        const sopfr = (x) => {
          const f = getPrimeFactors(x);
          let sum = 0;
          for (const k in f) sum += f[k] * Number(k);
          return sum;
        };
        return 1 / (1 + (sopfr(n) + sopfr(d)) / 5);
      }
    },

    barlow: {
      desc: '<b>Barlow:</b> 1 / (1 + Indigestibility). Quadratic prime penalty.',
      calc(n, d) {
        const indigestibility = (x) => {
          const f = getPrimeFactors(x);
          let sum = 0;
          for (const k in f) {
            const p = Number(k);
            sum += f[k] * (2 * Math.pow(p - 1, 2) / p);
          }
          return sum;
        };
        return 1 / (1 + indigestibility(n) + indigestibility(d));
      }
    },

    tenney: {
      desc: '<b>Tenney:</b> 1 / (1 + log₂(N×D)). Favors small numbers.',
      calc(n, d) {
        return 1 / (1 + Math.log2(n * d));
      }
    },

    harmUtility: {
      desc: '<b>HarmUtility:</b> 1 / (1 + Sum(count × ln(p))). Logarithmic prime penalty.',
      calc(n, d) {
        const complexity = (x) => {
          const f = getPrimeFactors(x);
          let sum = 0;
          for (const k in f) sum += f[k] * Math.log(Number(k));
          return sum;
        };
        return 1 / (1 + complexity(n) + complexity(d));
      }
    }
  };

  // Быстрый доступ для computeConsonance
  const consonanceMethods = {};
  for (const key in Methods) {
    consonanceMethods[key] = (n, d) => Methods[key].calc(n, d);
  }
  // Aliases for backward compatibility
  consonanceMethods['he-classic'] = consonanceMethods.heClassic;
  consonanceMethods.original = consonanceMethods.heClassic;
  consonanceMethods.default = consonanceMethods.heClassic;

  function computeConsonance(num, den, method = 'default') {
    const key = `${num}/${den}::${method}`;
    if (_consCache.has(key)) return _consCache.get(key);
    const fn = consonanceMethods[method] || consonanceMethods.default;
    const val = fn(num, den);
    _consCache.set(key, val);
    return val;
  }

  function clearCache() { 
    _consCache.clear(); 
    _factorsCache.clear();
  }

  function getNoteName(midiNote) { 
    const n = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B']; 
    return n[(midiNote % 12 + 12) % 12] + (Math.floor(midiNote / 12) - 1); 
  }

  /* ==================================================
     ✅ RATIONAL INTERVAL CLASS (СОВМЕСТИМОСТЬ С CORE)
     ================================================== */

  class RationalInterval {
    constructor(numerator, denominator) {
      this.numerator = Math.abs(Math.floor(numerator));
      this.denominator = Math.abs(Math.floor(denominator));
      this.simplify();
    }

    simplify() {
      const g = gcd(this.numerator, this.denominator) || 1;
      this.numerator = Math.floor(this.numerator / g);
      this.denominator = Math.floor(this.denominator / g);
      return this;
    }

    normalize() {
      let num = this.numerator;
      let den = this.denominator;
      while (num >= 2 * den) num /= 2;
      while (num < den) num *= 2;
      return new RationalInterval(num, den);
    }

    // ✅ NEW: Умножение интервалов (a/b * c/d = ac/bd)
    multiply(other) {
      return new RationalInterval(
        this.numerator * other.numerator,
        this.denominator * other.denominator
      );
    }

    // ✅ NEW: Деление интервалов (a/b ÷ c/d = ad/bc)
    divide(other) {
      return new RationalInterval(
        this.numerator * other.denominator,
        this.denominator * other.numerator
      );
    }

    // ✅ NEW: Инверсия интервала (a/b → b/a)
    invert() {
      return new RationalInterval(this.denominator, this.numerator);
    }

    // ✅ NEW: Сравнение интервалов
    equals(other) {
      return this.numerator === other.numerator && 
             this.denominator === other.denominator;
    }

    toDecimal() {
      return this.numerator / this.denominator;
    }

    toCents() {
      return 1200 * Math.log2(this.numerator / this.denominator);
    }

    toSemitones() {
      return toSemitones(this.numerator, this.denominator);
    }

    toString() {
      return `${this.numerator}/${this.denominator}`;
    }

    consonance(method = 'euler', options = {}) {
      const calc = Methods[method]?.calc;
      if (!calc) throw new Error(`Unknown method: ${method}`);
      return calc(this.numerator, this.denominator);
    }
  }

  /* ==================================================
     EXPORT OBJECT
     ================================================== */

  const jiLib = {
    // Math Core
    gcd,
    lcm,
    gcdOfRationals,
    primeFactors: getPrimeFactors,
    primeFactorsFull: getPrimeFactors,
    toSemitones,
    
    // Ratio Core
    createRatio,
    normalizeRatio: normalize,
    divideRatios: divide,
    multiplyRatios: multiply,
    
    adjustRatioOctave(r, shift) {
      let n = r.num;
      let d = r.den;
      if (shift > 0) n *= Math.pow(2, shift);
      else if (shift < 0) d *= Math.pow(2, Math.abs(shift));
      return createRatio(n, d);
    },

    // Conversions
    ratioToCents: toCents,
    ratioToSemitones,
    ratioToDecimal: toDecimal,
    getNoteName,

    // Analysis
    primeLimit,
    consonanceMethods,
    computeConsonance,

    // ✅ Class
    RationalInterval,

    // Tools
    clearCache
  };

  global.jiLib = jiLib;
  global.Methods = Methods;

})(typeof globalThis !== 'undefined' ? globalThis : window);
```

## lib\style_reference_default.html

```html
<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Style Reference — App Template</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Space+Grotesk:wght@300;400;500;600;700&display=swap" rel="stylesheet">

<style>
/* ============================================
   FONTS:
   - JetBrains Mono: NUMBERS ONLY (inputs, displays, values)
   - Space Grotesk: ALL OTHER TEXT (labels, buttons, UI)
   ============================================ */

:root {
  /* === PALETTE (LOCKED) === */
  --bg-void: hsl(225, 21.5%, 5%);
  --bg-panel: hsl(225, 24%, 8%);
  
  --hue-cyan: 190;
  --hue-purple: 260;
  --hue-warm: 35;
  
  --color-cyan: hsla(190, 90%, 62.5%, 1);
  --color-purple: hsla(260, 85%, 67.5%, 1);
  --color-warm: hsla(35, 100%, 67.5%, 1);
  
  --text-bright: hsl(0, 0%, 100%);
  --text-main: hsl(220, 28.5%, 91%);
  --text-dim: hsl(223, 18.5%, 69%);
  
  --radius-sm: 6px;
  --radius-md: 12px;
  
  --ease-out: cubic-bezier(0.2, 0.8, 0.2, 1);
  
  /* Shadows & Glows */
  --shadow-input: inset 0 2px 4px hsla(0, 0%, 0%, 0.45);
  --shadow-panel: 0 15px 40px -7.5px hsla(0, 0%, 0%, 0.6);
  
  --border-base: 1px solid hsla(0, 0%, 100%, 0.065);
  
  /* Inner Glows */
  --glow-cyan-inner: inset 0 0 0 1px hsla(190, 80%, 65%, 0.35), inset -1px -3px 20px hsla(190, 80%, 62.5%, 0.1);
  --glow-purple-inner: inset 0 0 0 1px hsla(260, 80%, 65%, 0.35), inset -1px -3px 20px hsla(260, 80%, 67.5%, 0.1);
  --glow-warm-inner: inset 0 0 0 1px hsla(35, 80%, 65%, 0.35), inset -1px -3px 20px hsla(35, 80%, 67.5%, 0.1);
  
  /* Slider gradient colors (reusable) */
  --slider-gradient: linear-gradient(90deg, 
    hsla(260, 75%, 60%, 0.6) 0%, 
    hsla(190, 85%, 61%, 0.9) 100%
  );
  --slider-track-bg: hsla(0, 0%, 100%, 0.08);
}

/* === RESET === */
* { box-sizing: border-box; outline: none; -webkit-tap-highlight-color: transparent; }

body, button, label, .label, .label-row, .toggle-face, .select-trigger, .option, .tick-marks {
  user-select: none; -webkit-user-select: none;
}
input[type="number"] { user-select: text; -webkit-user-select: text; }

body {
  margin: 0;
  min-height: 100vh;
  min-height: 100dvh;
  background-color: var(--bg-void);
  background-image: radial-gradient(circle at 50% -20%, hsl(225, 25%, 14.5%) 0%, var(--bg-void) 67.5%);
  color: var(--text-main);
  font-family: 'Space Grotesk', sans-serif;
  display: flex; flex-direction: column; overflow-x: hidden;
}



input::-webkit-outer-spin-button, input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
input[type=number] { -moz-appearance: textfield; }

/* === APP TITLE === */
.app-title {
  padding: 20px 24px 12px;
  font-size: 18px;
  font-weight: 700;
  letter-spacing: 0.5px;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: var(--text-bright);
  font-family: 'Space Grotesk', sans-serif;
}

/* === MAIN PANEL === */
main {
  flex: 1;
  display: flex;
  justify-content: center;
  align-items: flex-start;
  padding: 8px 16px 24px;
}

.panel {
  width: 100%;
  max-width: 480px;
  background: var(--bg-panel);
  border: var(--border-base);
  border-radius: 16px;
  padding: clamp(20px, 4vw, 32px);
  display: flex; flex-direction: column; gap: 28px;
  box-shadow: var(--shadow-panel);
}

.label, .label-row {
  font-size: 10px; text-transform: uppercase; color: var(--text-dim);
  letter-spacing: 1px; margin-bottom: 10px; display: block; font-weight: 600;
}
.label-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }

/* === COMPONENT: SELECT === */
.custom-select { position: relative; font-family: 'Space Grotesk', sans-serif; }
.select-trigger {
  background: hsla(0, 0%, 0%, 0.25);
  color: var(--text-main); padding: 12px 16px;
  border-radius: var(--radius-md); cursor: pointer;
  display: flex; justify-content: space-between; align-items: center;
  border: var(--border-base); box-shadow: var(--shadow-input);
  font-size: 13.5px; font-weight: 500; transition: border-color 0.2s;
}
.select-trigger:hover { border-color: hsla(0, 0%, 100%, 0.15); }

.custom-select.open .select-trigger {
  background-color: hsla(260, 75%, 50%, 0.05);
  box-shadow: var(--glow-purple-inner); border-color: transparent; color: var(--text-bright);
}
.select-arrow { font-size: 9px; color: var(--text-dim); transition: transform 0.2s; }
.custom-select.open .select-arrow { transform: rotate(180deg); color: var(--color-purple); }

.select-options {
  position: absolute; top: calc(100% + 6px); left: 0; right: 0;
  background: #0b0d12; border: var(--border-base);
  border-radius: var(--radius-md); overflow: hidden;
  max-height: 0; opacity: 0; z-index: 10;
  transition: all 0.2s var(--ease-out); box-shadow: 0 10px 30px rgba(0,0,0,0.8);
}
.custom-select.open .select-options { max-height: 200px; opacity: 1; }

.option {
  padding: 10px 16px; cursor: pointer; font-size: 13px; color: var(--text-dim);
  border-left: 2px solid transparent; transition: all 0.2s;
}
.option:hover { color: var(--text-bright); background: hsla(0, 0%, 100%, 0.04); }
.option.selected {
  color: var(--text-bright); border-left-color: var(--color-purple);
  background: linear-gradient(90deg, hsla(260, 85%, 67.5%, 0.06), transparent);
}

/* === COMPONENT: TOGGLE === */
.toggle-group {
  display: flex; background: hsla(0, 0%, 0%, 0.25); padding: 3px;
  border-radius: var(--radius-md); border: var(--border-base); height: 42px;
}
.toggle-opt { flex: 1; position: relative; cursor: pointer; }
.toggle-opt input { display: none; }

.toggle-face {
  width: 100%; height: 100%;
  display: flex; align-items: center; justify-content: center;
  color: var(--text-dim); font-size: 11.5px; font-weight: 500;
  border-radius: var(--radius-sm); transition: all 0.2s; border: 1px solid transparent;
}
.toggle-opt:hover .toggle-face { color: var(--text-main); }

.toggle-opt input:checked + .toggle-face {
  background: hsla(0, 0%, 100%, 0.06); color: var(--text-bright);
  border: 1px solid hsla(0, 0%, 100%, 0.08); box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}
.toggle-opt input:checked + .toggle-face::after {
  content: ''; position: absolute; bottom: -1px; left: 30%; right: 30%; height: 2px;
  background: var(--color-cyan); box-shadow: 0 0 6px var(--color-cyan); border-radius: 2px;
}

/* === COMPONENT: INPUTS === */
.input-row { display: flex; align-items: center; gap: 12px; }

/* NUMBERS: JetBrains Mono */
input[type="number"] {
  background-color: hsla(0, 0%, 0%, 0.25);
  border: var(--border-base); border-radius: var(--radius-sm);
  color: var(--text-bright);
  font-family: 'JetBrains Mono', monospace;
  text-align: center; padding: 8px 0; width: 60px;
  box-shadow: var(--shadow-input); font-size: 14px; font-weight: 500; transition: all 0.2s;
}
input[type="number"]:hover { border-color: hsla(0, 0%, 100%, 0.15); }

.inp-large { width: 68px; height: 44px; font-size: 16px; }

.inp-warm:focus { background-color: hsla(35, 75%, 50%, 0.05); box-shadow: var(--glow-warm-inner); border-color: transparent; }
.inp-cool:focus { background-color: hsla(190, 75%, 50%, 0.05); box-shadow: var(--glow-cyan-inner); border-color: transparent; }

.ratio-divider { font-size: 16px; color: var(--text-dim); padding-bottom: 2px; font-family: 'Space Grotesk', sans-serif; }

/* ============================================
   COMPONENT: SLIDER (SHARED STYLES)
   ============================================ */
.slider-wrap {
  flex: 1; position: relative; display: flex; align-items: center; height: 32px; padding: 0 8px;
}

/* Track element: gray base with gradient ::before */
.slider-track {
  position: absolute; left: 8px; right: 8px; height: 2px;
  background: var(--slider-track-bg); border-radius: 2px; pointer-events: none;
  overflow: hidden;
}

/* Full gradient, clipped to reveal "window" */
.slider-track::before {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background: linear-gradient(90deg,
    hsla(260, 75%, 60%, 0.6) 0%,
    hsla(190, 85%, 61%, 0.9) 100%
  );
  border-radius: 2px;
  /* Single slider: reveal from left, clip right side */
  clip-path: inset(0 var(--clip-right, 50%) 0 0);
  transition: clip-path 0.05s ease-out;
}

input[type=range] {
  -webkit-appearance: none;
  width: 100%;
  background: transparent;
  cursor: pointer;
  touch-action: none;
  position: relative; /* Above the track */
  z-index: 1;
}

/* Track on input itself: transparent (we use .slider-track instead) */
input[type=range]::-webkit-slider-runnable-track {
  width: 100%; height: 2px; cursor: pointer; border-radius: 2px;
  background: transparent;
}

input[type=range]::-moz-range-track {
  width: 100%; height: 2px; cursor: pointer; border-radius: 2px;
  background: transparent;
}

/* Thumb */
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance: none;
  height: 16px; width: 4px;
  border-radius: 2px;
  background: #fff;
  cursor: grab; margin-top: -7px;
  box-shadow: 0 0 0 1px rgba(0,0,0,0.3), 0 2px 4px rgba(0,0,0,0.5);
  transition: all 0.2s;
  opacity: 0.8;
}

input[type=range]::-moz-range-thumb {
  border: none; height: 16px; width: 4px; border-radius: 2px;
  background: #fff; cursor: grab;
  box-shadow: 0 0 0 1px rgba(0,0,0,0.3), 0 2px 4px rgba(0,0,0,0.5);
  transition: all 0.2s; opacity: 0.8;
}

input[type=range]:hover::-webkit-slider-thumb,
input[type=range]:focus::-webkit-slider-thumb {
  opacity: 1;
  background: #fff;
  transform: scaleY(1.1);
  box-shadow: 0 0 10px rgba(255,255,255,0.6), 0 0 2px var(--color-cyan);
}
input[type=range]:active::-webkit-slider-thumb {
  cursor: grabbing; background: var(--color-cyan);
  box-shadow: 0 0 15px var(--color-cyan);
}

/* ============================================
   COMPONENT: DUAL RANGE SLIDER (extends shared styles)
   Same "window reveal" effect
   ============================================ */
.dual-slider-wrap {
  flex: 1; position: relative; height: 32px; padding: 0 8px; display: flex; align-items: center;
}

/* Base track: gray */
.dual-slider-wrap .slider-track {
  /* Inherits base styles from .slider-track */
}

/* Dual slider: clip both sides */
.dual-slider-wrap .slider-track::before {
  /* Override clip-path for dual handles */
  clip-path: inset(0 var(--clip-right, 66.67%) 0 var(--clip-left, 33.33%));
}

/* Remove old range bar - now using clip-path on track::before */
.dual-slider-range {
  display: none;
}

/* Stacked Inputs */
.dual-slider-wrap input[type=range] {
  position: absolute; left: 0; right: 0; pointer-events: none;
}
.dual-slider-wrap input[type=range]::-webkit-slider-thumb { pointer-events: auto; }
.dual-slider-wrap input[type=range]::-moz-range-thumb { pointer-events: auto; }
/* Track already transparent from base styles */
.dual-slider-wrap input[type=range]::-webkit-slider-runnable-track { background: transparent; }
.dual-slider-wrap input[type=range]::-moz-range-track { background: transparent; }

.tick-marks {
  position: absolute; top: 18px; left: 8px; right: 8px;
  display: flex; justify-content: space-between; pointer-events: none;
}
.tick { width: 1px; height: 4px; background: hsla(0, 0%, 100%, 0.15); }

/* === COMPONENT: ACTION BUTTON === */
.btn-action {
  width: 100%; padding: 16px; margin-top: 12px;
  background: linear-gradient(180deg, hsl(225, 20%, 15%), hsl(225, 20%, 9%));
  border: 1px solid hsla(0, 0%, 100%, 0.08);
  border-radius: var(--radius-md);
  color: var(--text-main); font-family: 'Space Grotesk', sans-serif;
  font-weight: 600; text-transform: uppercase; letter-spacing: 1.5px; font-size: 12px;
  cursor: pointer; overflow: hidden;
  transition: all 0.2s var(--ease-out);
  position: relative;
  white-space: nowrap;
}

.btn-action:hover {
  border-color: hsla(0, 0%, 100%, 0.2);
  background: linear-gradient(180deg, hsl(225, 20%, 17%), hsl(225, 20%, 11%));
  color: var(--text-bright); transform: translateY(-1px);
  box-shadow: 0 8px 25px hsla(0, 0%, 0%, 0.5);
}

.btn-action::after {
  content: ''; position: absolute; bottom: 0; left: 0; width: 100%; height: 2px;
  background: var(--color-cyan); transform: scaleX(0.5); opacity: 0.6;
  transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
  box-shadow: 0 -1px 6px hsla(190, 90%, 62.5%, 0.2);
}
.btn-action:hover::after { transform: scaleX(1); opacity: 1; height: 3px; box-shadow: 0 0 15px var(--color-cyan); }
.btn-action:active { transform: translateY(0); opacity: 0.9; }

/* === FOOTER === */
footer {
  text-align: center;
  font-size: 10px;
  color: var(--text-dim);
  opacity: 0.5;
  padding: 16px;
  letter-spacing: 0.8px;
  text-transform: uppercase;
  font-family: 'JetBrains Mono', monospace;
}

/* === RESPONSIVE === */
@media (max-width: 480px) {
  .app-title { padding: 16px 16px 8px; }
  .panel { gap: 24px; }
  .toggle-face { font-size: 10.5px; }
  .inp-large { width: 56px; height: 40px; font-size: 14px; }
}
</style>
</head>
<body>

<div class="app-title">Lorem Ipsum Calculator</div>

<main>
  <div class="panel">
    
    <!-- Model Select -->
    <div>
      <span class="label">Modus Operandi</span>
      <div class="custom-select" id="modelSelect">
        <div class="select-trigger">
          <span>Veni Vidi Vici</span>
          <span class="select-arrow">▼</span>
        </div>
        <div class="select-options">
          <div class="option selected">Veni Vidi Vici</div>
          <div class="option">Carpe Diem</div>
          <div class="option">Memento Mori</div>
        </div>
      </div>
    </div>

    <!-- Analysis Mode -->
    <div>
      <span class="label">Tempus Fugit</span>
      <div class="toggle-group">
        <label class="toggle-opt">
          <input type="radio" name="mode" checked>
          <div class="toggle-face">Alpha</div>
        </label>
        <label class="toggle-opt">
          <input type="radio" name="mode">
          <div class="toggle-face">Beta</div>
        </label>
        <label class="toggle-opt">
          <input type="radio" name="mode">
          <div class="toggle-face">Gamma</div>
        </label>
      </div>
    </div>

    <!-- Interval Ratio -->
    <div>
      <div class="label-row"><span>Ratio Aurea</span></div>
      <div class="input-row">
        <input type="number" value="5" class="inp-large inp-warm">
        <span class="ratio-divider">:</span>
        <input type="number" value="4" class="inp-large inp-cool">
        <div class="slider-wrap">
          <div class="slider-track"></div>
          <input type="range" min="0" max="100" value="55" class="js-slider">
        </div>
      </div>
    </div>

    <!-- Range Selector (Dual) -->
    <div>
      <div class="label-row">
        <span>Spatium Infinitum</span>
        <span id="rangeVal" style="color:var(--color-cyan); font-family:'JetBrains Mono'">0 – +1</span>
      </div>
      <div class="input-row">
        <input type="number" value="0" min="-1" max="2" class="inp-cool js-range-min">
        <span class="ratio-divider">–</span>
        <input type="number" value="1" min="-1" max="2" class="inp-cool js-range-max">
        
        <div class="dual-slider-wrap">
          <div class="slider-track"></div>
          <input type="range" min="-1" max="2" step="1" value="0" class="js-range-lower" id="lowerSlider">
          <input type="range" min="-1" max="2" step="1" value="1" class="js-range-upper" id="upperSlider">
          <div class="tick-marks">
            <span class="tick"></span><span class="tick"></span><span class="tick"></span><span class="tick"></span>
          </div>
        </div>
      </div>
    </div>

    <button class="btn-action">Fiat Lux</button>

  </div>
</main>

<footer>Status: Lorem Ipsum • V 0.0.0 (Reference)</footer>

<script>
// === SINGLE SLIDER ===
function updateSingleSlider(input) {
  const percent = (input.value - input.min) / (input.max - input.min) * 100;
  const track = input.parentElement.querySelector('.slider-track');
  if (track) {
    track.style.setProperty('--clip-right', (100 - percent) + '%');
  }
}
document.querySelectorAll('.js-slider').forEach(s => {
  updateSingleSlider(s); s.addEventListener('input', e => updateSingleSlider(e.target));
});

// === SELECT ===
const select = document.getElementById('modelSelect');
const trigger = select.querySelector('.select-trigger span');
select.addEventListener('click', () => select.classList.toggle('open'));
select.querySelectorAll('.option').forEach(opt => {
  opt.addEventListener('click', () => {
    select.querySelectorAll('.option').forEach(o => o.classList.remove('selected'));
    opt.classList.add('selected'); trigger.textContent = opt.textContent;
  });
});
document.addEventListener('click', e => { if(!select.contains(e.target)) select.classList.remove('open'); });

// === DUAL SLIDER with clip-path "window reveal" ===
const lower = document.getElementById('lowerSlider');
const upper = document.getElementById('upperSlider');
const track = document.querySelector('.dual-slider-wrap .slider-track');
const disp = document.getElementById('rangeVal');
const minInp = document.querySelector('.js-range-min');
const maxInp = document.querySelector('.js-range-max');

function fmt(v) { return v > 0 ? '+' + v : v; }

function updateDual() {
  let l = parseInt(lower.value), u = parseInt(upper.value);
  if (l > u) { [l, u] = [u, l]; lower.value = l; upper.value = u; }
  
  const min = -1, max = 2;
  const range = max - min; // 3
  
  // Calculate percentages for clip-path
  const leftPercent = ((l - min) / range) * 100;
  const rightPercent = 100 - ((u - min) / range) * 100;
  
  // Update clip-path via CSS custom properties
  track.style.setProperty('--clip-left', leftPercent + '%');
  track.style.setProperty('--clip-right', rightPercent + '%');
  
  disp.textContent = `${fmt(l)} – ${fmt(u)}`;
  minInp.value = l; maxInp.value = u;
}

lower.addEventListener('input', updateDual);
upper.addEventListener('input', updateDual);
minInp.addEventListener('change', e => { lower.value = Math.max(-1, Math.min(2, e.target.value)); updateDual(); });
maxInp.addEventListener('change', e => { upper.value = Math.max(-1, Math.min(2, e.target.value)); updateDual(); });

updateDual();
</script>

</body>
</html>
```

## tonnetz\js\1_utils.js

```javascript
window.Tonnetz = window.Tonnetz || {};

/* === Math Helpers === */
Tonnetz.Math = {
    bound: (value, mini, maxi) => Math.min(maxi, Math.max(mini, value)),
    mod: (value, period) => ((value % period) + period) % period,
    gcd: (a, b) => (!b ? a : Tonnetz.Math.gcd(b, a % b)),
    average: (arr) => arr.reduce((a, b) => a + b, 0) / arr.length,

    // Простой мемоизатор для чистых функций
    memo: (func) => {
        const cache = {};
        return function(...args) {
            const key = JSON.stringify(args);
            if (cache[key]) return cache[key];
            const val = func.apply(this, args);
            cache[key] = val;
            return val;
        };
    },

    arrayEquals: (a, b) => {
        if (a === b) return true;
        if (a == null || b == null || a.length !== b.length) return false;
        for (let i = 0; i < a.length; ++i) if (a[i] !== b[i]) return false;
        return true;
    }
};

/* === Geometry Constants & Transforms === */
Tonnetz.Geometry = {
    xstep: Math.sqrt(3) / 2,
    baseSize: 50,
    
    // Стандартный Тоннетц (Треугольный)
    logicalToSvgTonnetz: (node) => {
        const x = node.x * Tonnetz.Geometry.xstep * Tonnetz.Geometry.baseSize;
        const y = (node.y + node.x / 2) * Tonnetz.Geometry.baseSize;
        return { x, y };
    },

    // Новый Прямоугольный режим (Rectangular)
    // X = Квинты (7 полутонов), Y = Большие терции (4 полутона)
    logicalToSvgRect: (node) => {
        // Просто декартова сетка, немного растянутая для красоты
        const spacing = Tonnetz.Geometry.baseSize * 1.2;
        return { 
            x: node.x * spacing, 
            y: -node.y * spacing // Инвертируем Y, чтобы "вверх" было вверх
        }; 
    }
};

/* === Color & MIDI Helpers === */
Tonnetz.Music = {
    colorMap: {
        0: "#ff941f", 1: "#e66438", 2: "#cc3450", 3: "#b30469",
        4: "#822b9b", 5: "#5053cd", 6: "#1f7aff", 7: "#258dab",
        8: "#2ba058", 9: "#31b304", 10: "#76a900", 11: "#e6bd00",
    }
};
```

## tonnetz\js\2_midi.js

```javascript
/* === Simple Event Emitter & MIDI Bus === */
class MidiBus {
    constructor() {
        this.listeners = {};
        this.midiThru = null; // JZZ Widget init later
    }

    init() {
        if (window.JZZ) {
            this.midiThru = JZZ.Widget();
        }
    }

    on(event, fn) {
        if (!this.listeners[event]) this.listeners[event] = [];
        this.listeners[event].push(fn);
    }

    off(event, fn) {
        if (!this.listeners[event]) return;
        this.listeners[event] = this.listeners[event].filter(l => l !== fn);
    }

    emit(event, ...args) {
        if (this.listeners[event]) {
            this.listeners[event].forEach(fn => fn(...args));
        }
    }

    // API Wrappers
    connect(output) { if(this.midiThru) this.midiThru.connect(output); }
    disconnect(output) { if(this.midiThru) this.midiThru.disconnect(output); }
    
    sendNoteOn(pitches, velocity = 100) {
        if (!this.midiThru) return;
        pitches.forEach(p => {
            this.midiThru.noteOn(0, p, velocity);
        });
        // Уведомляем UI локально
        this.emit('local-note-on', pitches); 
    }

    sendNoteOff(pitches) {
        if (!this.midiThru) return;
        pitches.forEach(p => {
            this.midiThru.noteOff(0, p);
        });
        // Уведомляем UI локально
        this.emit('local-note-off', pitches);
    }
}

window.midiBus = new MidiBus();
```

## tonnetz\js\3_strings.js

```javascript
window.Tonnetz = window.Tonnetz || {};

Tonnetz.Strings = {
    data: {
        en: {
            title: 'The Tonnetz',
            dual: 'Rectangular Mode', // Переименовали кнопку
            rotate: 'Rotate 180°',
            translate: 'Translate',
            connected: 'Note: This Tonnetz grid is not fully connected.',
            notes: ['A', 'A♯', 'B', 'C', 'C♯', 'D', 'D♯', 'E', 'F', 'F♯', 'G', 'G♯'],
            infos: {
                tonnetz: `<h3>The Tonnetz</h3><p>Theoretical model representing harmonic relationships in a triangular grid. Diagonal axes represent minor and major thirds; vertical axes represent perfect fifths.</p>`,
                rectangular: `<h3>Rectangular Grid</h3><p>A Cartesian representation of the harmonic space. <br><b>Horizontal (X):</b> Steps by Perfect Fifths (7 semitones).<br><b>Vertical (Y):</b> Steps by Major Thirds (4 semitones).</p>`
            },
            infoClose: "Close Info",
            info: "Info"
        }
    },
    get(key, lang = 'en') {
        const path = Array.isArray(key) ? key : key.split('.');
        let result = this.data[lang];
        
        for (let p of path) {
            if (result && result[p] !== undefined) {
                result = result[p];
            } else {
                result = undefined;
                break;
            }
        }
        
        if (result === undefined && lang !== 'en') {
            return this.get(key, 'en');
        }
        
        return result !== undefined ? result : (Array.isArray(key) ? key.join('.') : key);
    }
};
```

## tonnetz\js\4_mixins.js

```javascript
/* === Grid Generation Logic === */
window.GridLogic = {
    getNodes: (bounds, mode) => {
        const nodes = [];
        const bs = Tonnetz.Geometry.baseSize;
        
        if (mode === 'tonnetz') {
            const xs = Tonnetz.Geometry.xstep;
            const xmin = Math.floor(bounds.xmin / (bs * xs));
            const xmax = Math.ceil(bounds.xmax / (bs * xs));
            const buffer = 1; 

            for (let xi = xmin - buffer; xi <= xmax + buffer; xi++) {
                const ymin = Math.floor(bounds.ymin / bs - xi / 2);
                const ymax = Math.ceil(bounds.ymax / bs - xi / 2);
                for (let yi = ymin - buffer; yi <= ymax + buffer; yi++) {
                    nodes.push({x: xi, y: yi});
                }
            }
        } else {
            // Rectangular
            const spacing = bs * 1.2;
            const xmin = Math.floor(bounds.xmin / spacing);
            const xmax = Math.ceil(bounds.xmax / spacing);
            const ymin = Math.floor(-bounds.ymax / spacing);
            const ymax = Math.ceil(-bounds.ymin / spacing);

            for (let xi = xmin - 1; xi <= xmax + 1; xi++) {
                for (let yi = ymin - 1; yi <= ymax + 1; yi++) {
                    nodes.push({x: xi, y: yi});
                }
            }
        }
        return nodes;
    },

    // ВАЖНО: Возвращает сырой MIDI номер (может быть > 127 или < 0, фильтруем позже)
    // Это сохраняет относительную высоту звука для аккордов.
    getNodePitchRaw: (node, mode) => {
        let p;
        if (mode === 'tonnetz') {
             // Tonnetz Standard: 
             // Start at 60 (Middle C)
             // X axis = Minor Third (+3)
             // Y axis = Major Third (-4 inverted or +? check standard)
             // Standard: Axis 1 = P5 (7), Axis 2 = M3 (4).
             // Original Formula from code: 81 - x*3 + y*(-7)
             // Давайте используем базу 60 для центра.
             // x * 3 (m3) + y * 4 (M3) = PLR transformation style grid
             // Оригинальный код использовал интервалы [3, 4, 5].
             // Используем оригинальную формулу, она проверена временем в этом проекте.
             p = 81 - node.x * 3 + node.y * (5 - 12); // 81 - 3x - 7y
        } else {
            // Rectangular: X=Quint(7), Y=Maj3(4)
            p = 48 + node.x * 7 + node.y * 4; // Base C3
        }
        return p;
    }
};
```

## tonnetz\js\5_components_primitives.js

```javascript
/* === SVG Element Builders === */
window.SvgBuilder = {
    
    // Вспомогательная функция для получения цвета
    getColor(midiNote) {
        const pitchClass = Tonnetz.Math.mod(midiNote, 12);
        return Tonnetz.Music.colorMap[pitchClass];
    },

    createNode(x, y, pitch, mode) {
        const pitchClass = Tonnetz.Math.mod(pitch, 12);
        const noteName = Tonnetz.Strings.get(['notes', pitchClass]);
        const color = this.getColor(pitch);
        
        // Передаем цвет через CSS переменную --item-color
        // data-pitches хранит массив для воспроизведения
        // data-pc (pitch class) для подсветки всех "До" одновременно
        return `
            <g class="tonnetz-el node" 
               style="--item-color: ${color}"
               data-pitches="[${pitch}]" 
               data-pc="${pitchClass}"
               transform="translate(${x},${y})">
                <circle r="14"></circle>
                <text dy="1">${noteName}</text>
            </g>
        `;
    },

    createDichord(x1, y1, x2, y2, pitch1, pitch2) {
        const cx = (x1 + x2) / 2;
        const cy = (y1 + y2) / 2;
        // Сортируем pitch classes для уникального ключа подсветки
        const pc1 = Tonnetz.Math.mod(pitch1, 12);
        const pc2 = Tonnetz.Math.mod(pitch2, 12);
        const key = [pc1, pc2].sort((a,b)=>a-b).join('-');
        
        return `
            <g class="tonnetz-el dichord" 
               data-pitches="[${pitch1},${pitch2}]"
               data-key="${key}">
                <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" />
                <circle cx="${cx}" cy="${cy}" />
            </g>
        `;
    },

    createTrichord(pts, pitches) {
        const pointsStr = pts.map(p => `${p.x},${p.y}`).join(' ');
        
        // Ключ для подсветки (Pitch Classes)
        const pcs = pitches.map(p => Tonnetz.Math.mod(p, 12)).sort((a,b)=>a-b).join('-');

        return `
            <polygon class="tonnetz-el trichord" 
                     data-pitches="[${pitches.join(',')}]"
                     data-key="${pcs}" 
                     points="${pointsStr}" />
        `;
    }
};
```

## tonnetz\js\6_components_layout.js

```javascript
/* === Scene Renderer === */
class TonnetzRenderer {
    constructor(svgGroup) {
        this.group = svgGroup;
    }

    render(bounds, mode) {
        const nodes = window.GridLogic.getNodes(bounds, mode);
        let html = '';

        // 1. Calculate positions and RAW pitches
        const nodeData = nodes.map(n => {
            const pos = (mode === 'tonnetz') 
                ? Tonnetz.Geometry.logicalToSvgTonnetz(n)
                : Tonnetz.Geometry.logicalToSvgRect(n);
            const pitch = window.GridLogic.getNodePitchRaw(n, mode);
            return { n, pos, pitch };
        });

        // 2. Trichords (Triangles) - FIRST (so they are behind nodes)
        if (mode === 'tonnetz') {
            nodeData.forEach(d => {
                const { n, pos, pitch } = d;
                
                // Triangle 1: (x,y), (x+1,y), (x,y+1)
                const nRight = nodeData.find(nd => nd.n.x === n.x + 1 && nd.n.y === n.y);
                const nDown = nodeData.find(nd => nd.n.x === n.x && nd.n.y === n.y + 1);
                
                if (nRight && nDown) {
                    html += window.SvgBuilder.createTrichord(
                        [pos, nRight.pos, nDown.pos],
                        [pitch, nRight.pitch, nDown.pitch]
                    );
                }
                
                // Triangle 2: (x,y), (x-1,y+1), (x,y+1)
                const nLeftDown = nodeData.find(nd => nd.n.x === n.x - 1 && nd.n.y === n.y + 1);
                if (nLeftDown && nDown) {
                    html += window.SvgBuilder.createTrichord(
                        [pos, nLeftDown.pos, nDown.pos],
                        [pitch, nLeftDown.pitch, nDown.pitch]
                    );
                }
            });
        }

        // 3. Dichords (Lines)
        nodeData.forEach(d => {
            const { n, pos, pitch } = d;
            const neighbors = [];
            
            if (mode === 'tonnetz') {
                neighbors.push({ dx: 1, dy: 0 }); // Right
                neighbors.push({ dx: 0, dy: 1 }); // Down
                neighbors.push({ dx: -1, dy: 1 }); // Diagonal
            } else {
                neighbors.push({ dx: 1, dy: 0 });
                neighbors.push({ dx: 0, dy: 1 });
            }

            neighbors.forEach(offset => {
                const neighbor = nodeData.find(nd => nd.n.x === n.x + offset.dx && nd.n.y === n.y + offset.dy);
                if (neighbor) {
                    html += window.SvgBuilder.createDichord(
                        pos.x, pos.y, neighbor.pos.x, neighbor.pos.y,
                        pitch, neighbor.pitch
                    );
                }
            });
        });

        // 4. Nodes (Circles) - LAST (on top)
        nodeData.forEach(d => {
            html += window.SvgBuilder.createNode(d.pos.x, d.pos.y, d.pitch, mode);
        });

        this.group.innerHTML = html;
    }
}

/* === Viewport Controller (Без изменений) === */
class ViewportController {
    constructor(svgElement, contentGroup) {
        this.svg = svgElement;
        this.group = contentGroup;
        this.state = { tx: 0, ty: 0, scale: 2 };
        this.isDragging = false;
        this.lastPos = { x: 0, y: 0 };
        this.viewSize = { w: 1000, h: 600 };
        this.attachEvents();
        this.updateTransform();
    }
    attachEvents() {
        this.svg.addEventListener('pointerdown', e => {
            // Если клик не попал в интерактивный элемент (.tonnetz-el), начинаем драг
            if (!e.target.closest('.tonnetz-el')) {
                this.isDragging = true;
                this.lastPos = { x: e.clientX, y: e.clientY };
                this.svg.setPointerCapture(e.pointerId);
                this.svg.style.cursor = 'grabbing';
            }
        });
        this.svg.addEventListener('pointermove', e => {
            if (!this.isDragging) return;
            const dx = e.clientX - this.lastPos.x;
            const dy = e.clientY - this.lastPos.y;
            this.state.tx += dx / this.state.scale;
            this.state.ty += dy / this.state.scale;
            this.lastPos = { x: e.clientX, y: e.clientY };
            this.updateTransform();
        });
        const stopDrag = (e) => {
            this.isDragging = false;
            if (this.svg.hasPointerCapture(e.pointerId)) this.svg.releasePointerCapture(e.pointerId);
            this.svg.style.cursor = 'grab';
        };
        this.svg.addEventListener('pointerup', stopDrag);
        this.svg.addEventListener('pointerleave', stopDrag);
        new ResizeObserver(entries => {
            for(let entry of entries) {
                this.viewSize.w = entry.contentRect.width;
                this.viewSize.h = entry.contentRect.height;
            }
        }).observe(this.svg);
    }
    updateTransform() {
        this.group.setAttribute('transform', `scale(${this.state.scale}) translate(${this.state.tx} ${this.state.ty})`);
    }
    getBounds() {
        return {
            xmin: -this.state.tx,
            ymin: -this.state.ty,
            xmax: -this.state.tx + this.viewSize.w / this.state.scale,
            ymax: -this.state.ty + this.viewSize.h / this.state.scale
        };
    }
}
```

## tonnetz\js\7_app.js

```javascript
document.addEventListener('DOMContentLoaded', () => {
    
    // === DOM References ===
    const ui = {
        app: document.getElementById('app'),
        svg: document.getElementById('main-svg'),
        svgGroup: document.getElementById('svg-content'),
        overlay: document.getElementById('start-overlay'),
        btnDual: document.getElementById('btn-dual'),
        btnInfo: document.getElementById('btn-info'),
        infoOverlay: document.getElementById('info-overlay'),
        infoContent: document.getElementById('info-text'),
        statusText: document.getElementById('status-text')
    };

    // === State ===
    const state = {
        mode: 'tonnetz',
        activePitches: new Set(), // MIDI Note Numbers (0-127)
        audioStarted: false
    };

    const viewport = new ViewportController(ui.svg, ui.svgGroup);
    const renderer = new TonnetzRenderer(ui.svgGroup);

    function renderScene() {
        const bounds = viewport.getBounds();
        renderer.render(bounds, state.mode);
        updateActiveClasses();
    }

    // === Visual Feedback Logic ===
    function updateActiveClasses() {
        // 1. Сброс (используем classList.remove('active') вместо удаления специфичных классов)
        const allActive = ui.svgGroup.querySelectorAll('.active');
        allActive.forEach(el => el.classList.remove('active'));

        // Собираем Pitch Classes (0-11) активных нот
        const activePCs = new Set();
        state.activePitches.forEach(p => activePCs.add(Tonnetz.Math.mod(p, 12)));
        const activePCArr = Array.from(activePCs).sort((a,b) => a-b);

        // 2. Подсветка Нот (по Pitch Class)
        activePCs.forEach(pc => {
            const nodes = ui.svgGroup.querySelectorAll(`.node[data-pc="${pc}"]`);
            nodes.forEach(n => n.classList.add('active'));
        });

        // 3. Подсветка Дикордов (Линий)
        // Ключ формата "pc1-pc2" (отсортирован)
        for (let i = 0; i < activePCArr.length; i++) {
            for (let j = i + 1; j < activePCArr.length; j++) {
                const key = `${activePCArr[i]}-${activePCArr[j]}`;
                const lines = ui.svgGroup.querySelectorAll(`.dichord[data-key="${key}"]`);
                lines.forEach(l => l.classList.add('active'));
            }
        }

        // 4. Подсветка Трикордов (Треугольников)
        if (state.mode === 'tonnetz') {
             for (let i = 0; i < activePCArr.length; i++) {
                for (let j = i + 1; j < activePCArr.length; j++) {
                    for (let k = j + 1; k < activePCArr.length; k++) {
                        const key = `${activePCArr[i]}-${activePCArr[j]}-${activePCArr[k]}`;
                        const polys = ui.svgGroup.querySelectorAll(`.trichord[data-key="${key}"]`);
                        polys.forEach(p => p.classList.add('active'));
                    }
                }
            }
        }
    }

    // === MIDI Setup ===
    window.midiBus.init();

    window.midiBus.on('midi-event', (msg) => {
        if (msg.isNoteOn) state.activePitches.add(msg.note);
        else if (msg.isNoteOff) state.activePitches.delete(msg.note);
        updateActiveClasses();
    });

    window.midiBus.on('local-note-on', (pitches) => {
        pitches.forEach(p => state.activePitches.add(p));
        updateActiveClasses();
    });
    
    window.midiBus.on('local-note-off', (pitches) => {
        pitches.forEach(p => state.activePitches.delete(p));
        updateActiveClasses();
    });

    // === Interaction: Click to Play ===
    let playingPitches = null;

    ui.svgGroup.addEventListener('pointerdown', (e) => {
        // Ищем ближайший элемент тоннетца (нота, линия или треугольник)
        const target = e.target.closest('.tonnetz-el');
        
        if (target && target.dataset.pitches) {
            e.stopPropagation(); // Останавливаем драг карты
            
            // Парсим массив нот из data-attribute
            const pitches = JSON.parse(target.dataset.pitches);
            
            // Нормализация в диапазон 0-127 (на всякий случай)
            const validPitches = pitches.map(p => {
                while(p < 0) p += 12;
                while(p > 127) p -= 12;
                return p;
            });

            playingPitches = validPitches;
            window.midiBus.sendNoteOn(playingPitches);
            
            // Захват указателя, чтобы отпустить ноту даже если увели мышь
            if(target.setPointerCapture) target.setPointerCapture(e.pointerId);
        }
    });

    const stopPlaying = (e) => {
        if (playingPitches) {
            window.midiBus.sendNoteOff(playingPitches);
            playingPitches = null;
            if(e.target && e.target.releasePointerCapture) {
                 // try catch на случай если элемент уже пропал или не захвачен
                 try { e.target.releasePointerCapture(e.pointerId); } catch(err){}
            }
        }
    };

    document.addEventListener('pointerup', stopPlaying);
    // document.addEventListener('pointercancel', stopPlaying); // Опционально

    // === UI Controls ===
    function initAudio() {
        if (state.audioStarted) return;
        state.audioStarted = true;
        ui.overlay.style.display = 'none';

        if (!window.JZZ) return;
        const synth = JZZ.synth.Tiny();
        window.midiBus.connect(synth);

        JZZ().or(() => { ui.statusText.textContent = "MIDI Engine Failed"; })
             .and(function() {
                const info = this.info();
                ui.statusText.textContent = (info.inputs.length > 0) ? "MIDI Active" : "No MIDI Inputs";
                ui.statusText.classList.toggle('connected', info.inputs.length > 0);
             });
             
        JZZ().openMidiIn().connect(function(msg) {
            if (msg.isNoteOn() || msg.isNoteOff()) {
                window.midiBus.emit('midi-event', {
                    isNoteOn: msg.isNoteOn(),
                    isNoteOff: msg.isNoteOff(),
                    note: msg.getNote()
                });
            }
        });
    }

    ui.overlay.addEventListener('click', initAudio);

    ui.btnDual.addEventListener('click', () => {
        state.mode = (state.mode === 'tonnetz') ? 'rectangular' : 'tonnetz';
        ui.btnDual.classList.toggle('active', state.mode === 'rectangular');
        renderScene();
    });

    ui.btnInfo.addEventListener('click', () => {
        const isHidden = ui.infoOverlay.style.display === 'none';
        ui.infoOverlay.style.display = isHidden ? 'flex' : 'none';
        if (isHidden) {
            const key = state.mode === 'tonnetz' ? 'infos.tonnetz' : 'infos.rectangular';
            ui.infoContent.innerHTML = Tonnetz.Strings.get(key);
            ui.btnInfo.textContent = Tonnetz.Strings.get('infoClose');
        } else {
            ui.btnInfo.textContent = Tonnetz.Strings.get('info');
        }
    });
    
    ui.infoOverlay.addEventListener('click', (e) => {
        if(e.target === ui.infoOverlay) ui.btnInfo.click();
    });

    ui.svg.addEventListener('pointerup', () => requestAnimationFrame(renderScene));

    // Init
    renderScene();
});
```

## tonnetz\style.css

```css
:root {
  /* === PALETTE === */
  --bg-void: hsl(225, 21.5%, 5%);
  --bg-panel: hsl(225, 24%, 8%);
  
  --color-cyan: hsla(190, 90%, 62.5%, 1);
  --color-purple: hsla(260, 85%, 67.5%, 1);
  --color-warm: hsla(35, 100%, 67.5%, 1);
  
  --text-bright: hsl(0, 0%, 100%);
  --text-main: hsl(220, 28.5%, 91%);
  --text-dim: hsl(223, 18.5%, 69%);
  
  --radius-md: 12px;
  --border-base: 1px solid hsla(0, 0%, 100%, 0.065);
  --shadow-panel: 0 15px 40px -7.5px hsla(0, 0%, 0%, 0.6);
  
  --font-ui: 'Space Grotesk', sans-serif;
  --font-mono: 'JetBrains Mono', monospace;
}

/* === RESET & LAYOUT === */
* { box-sizing: border-box; outline: none; }
[v-cloak] { display: none; }

body {
  margin: 0;
  min-height: 100vh;
  background-color: var(--bg-void);
  background-image: radial-gradient(circle at 50% -20%, hsl(225, 25%, 14.5%) 0%, var(--bg-void) 67.5%);
  color: var(--text-main);
  font-family: var(--font-ui);
  overflow: hidden;
  user-select: none;
}

.app-layout {
  display: flex;
  flex-direction: column;
  height: 100vh;
  padding: 10px;
}

.app-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0 20px 10px;
}

.app-title {
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 2px;
  color: var(--text-bright);
}

main {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 16px;
  position: relative;
}

.panel {
  background: var(--bg-panel);
  border: var(--border-base);
  border-radius: 16px;
  box-shadow: var(--shadow-panel);
}

.canvas-panel {
  flex: 1;
  overflow: hidden;
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
}

.controls-panel {
  padding: 16px 24px;
  display: flex;
  gap: 32px;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

/* === UI COMPONENTS === */
.btn-icon {
  background: hsla(0, 0%, 0%, 0.25);
  border: var(--border-base);
  color: var(--text-dim);
  padding: 8px 16px;
  border-radius: var(--radius-md);
  cursor: pointer;
  font-family: var(--font-ui);
  text-transform: uppercase;
  font-size: 11px;
  letter-spacing: 1px;
  transition: all 0.2s;
}
.btn-icon:hover { color: var(--text-bright); border-color: hsla(0,0%,100%,0.2); }

.control-group { display: flex; flex-direction: column; gap: 6px; align-items: center; }
.label { font-size: 10px; text-transform: uppercase; color: var(--text-dim); letter-spacing: 1px; font-weight: 600; }

.toggle-opt {
  display: flex;
  background: hsla(0, 0%, 0%, 0.25);
  padding: 3px;
  border-radius: var(--radius-md);
  border: var(--border-base);
  height: 36px;
  cursor: pointer;
  min-width: 120px;
}
.toggle-opt input { display: none; }
.toggle-face {
  width: 100%; 
  height: 100%;
  display: flex; 
  align-items: center; 
  justify-content: center;
  color: var(--text-dim); 
  font-size: 11.5px; 
  font-weight: 500;
  border-radius: 6px; 
  transition: all 0.2s;
}
.toggle-opt input:checked + .toggle-face {
  background: hsla(0, 0%, 100%, 0.06);
  color: var(--text-bright);
  box-shadow: 0 1px 4px rgba(0,0,0,0.3);
}

.status-text {
  font-family: var(--font-mono);
  font-size: 12px;
  color: var(--text-dim);
}
.status-text.connected { 
  color: var(--color-cyan); 
  text-shadow: 0 0 10px hsla(190, 90%, 62.5%, 0.3); 
}

/* === SVG ELEMENTS === */
svg { display: block; overflow: visible; }

/* Base SVG elements (из ver2) */
circle { 
  fill: var(--bg-panel); 
  stroke: var(--text-dim); 
  stroke-opacity: 0.3; 
  transition: all 0.1s; 
}
line { 
  stroke: var(--text-dim); 
  stroke-opacity: 0.2; 
  stroke-width: 1px; 
  transition: all 0.1s; 
}
polygon { 
  stroke: var(--text-dim); 
  stroke-opacity: 0.2; 
  fill: transparent; 
  transition: all 0.1s; 
}
text { 
  fill: var(--text-dim); 
  font-family: var(--font-ui); 
  font-size: 14px; 
  pointer-events: none; 
  text-anchor: middle; 
  dominant-baseline: central; 
  font-weight: 500;
}

.tonnetz-el { cursor: pointer; transition: all 0.1s; }

/* -- NODE (Нота) -- */
.node circle { 
  fill: var(--bg-panel); 
  stroke: hsla(0, 0%, 100%, 0.3);
  stroke-width: 1.5px;
  transition: all 0.15s;
}
.node text { 
  fill: var(--text-dim); 
  font-size: 14px; 
  font-weight: 500; 
  font-family: var(--font-ui);
  pointer-events: none; 
  text-anchor: middle; 
  dominant-baseline: central;
}

.node.active circle,
.activeNode circle { 
  fill: var(--item-color); 
  stroke: var(--item-color); 
  stroke-opacity: 1;
  stroke-width: 3px; 
}
.node.active text,
.activeNode text { 
  fill: var(--text-bright); 
  font-weight: 700; 
  text-shadow: 0 1px 3px rgba(0,0,0,0.5); 
}


/* -- DICHORD (Линия) -- */
.dichord line { 
  stroke: hsla(0, 0%, 100%, 0.15);
  stroke-width: 2px; 
  transition: all 0.1s;
}
.dichord circle { 
  fill: var(--bg-panel); 
  stroke: hsla(0, 0%, 100%, 0.3);
  stroke-width: 1px;
  r: 3; 
  pointer-events: none; 
}

.dichord.active line,
.activeDichord line { 
  stroke: var(--text-main); 
  stroke-opacity: 0.9; 
  stroke-width: 3px; 
}
.dichord.active circle,
.activeDichord circle { 
  fill: var(--text-main); 
}

/* -- TRICHORD (Треугольник) -- */
.trichord { 
  fill: transparent; 
  stroke: hsla(0, 0%, 100%, 0.1);
  stroke-width: 1px;
  transition: all 0.1s;
}

.trichord.active,
.activeTrichord { 
  fill: var(--color-purple); 
  fill-opacity: 0.15;
  stroke: var(--color-purple); 
  stroke-opacity: 0.8;
}



/* Chicken Wire specific */
.chickenTrichord circle { stroke-width: 1; }
.chickenTrichord.minorish text { font-style: italic; opacity: 0.7; }

/* === TONNETZ SELECTOR === */
.tonnetz-selector {
  display: flex; 
  gap: 8px; 
  justify-content: center; 
  margin-bottom: 20px; 
  flex-wrap: wrap;
}
.btn-select {
  background: transparent; 
  border: var(--border-base); 
  color: var(--text-dim);
  padding: 6px 12px; 
  border-radius: 6px; 
  font-family: var(--font-mono); 
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s;
}
.btn-select:hover { border-color: var(--text-main); }
.btn-select.active { 
  background: var(--color-purple); 
  color: var(--text-bright); 
  border-color: transparent; 
}
.btn-dual { 
  border-color: var(--color-cyan); 
  color: var(--color-cyan); 
}
.btn-dual.active { 
  background: var(--color-cyan); 
  color: #000; 
}

/* === MODALS === */
.start-overlay {
  position: fixed; 
  inset: 0; 
  z-index: 999;
  background: rgba(0,0,0,0.8);
  display: flex; 
  justify-content: center; 
  align-items: center;
  cursor: pointer;
}
.start-btn {
  text-align: center; 
  color: var(--text-bright);
  border: 1px solid var(--color-cyan);
  padding: 40px; 
  border-radius: 16px;
  background: radial-gradient(circle, #1a2a3a 0%, #0b0d12 100%);
  box-shadow: 0 0 30px rgba(0,255,255,0.2);
}

.info-overlay {
  position: fixed; 
  inset: 0;
  background: rgba(0,0,0,0.7);
  backdrop-filter: blur(4px);
  z-index: 100;
  display: flex; 
  justify-content: center; 
  align-items: center;
}
.info-content {
  width: 600px; 
  max-width: 90vw; 
  max-height: 80vh;
  padding: 32px;
  overflow-y: auto;
}
.info-content h2, .info-content p { 
  color: var(--text-main); 
  line-height: 1.6; 
}
.info-content a { 
  color: var(--color-cyan); 
  text-decoration: none; 
}

.fade-enter-active, .fade-leave-active { transition: opacity 0.3s; }
.fade-enter, .fade-leave-to { opacity: 0; }

.app-layout.blurred { filter: blur(5px); pointer-events: none; }
```

## Umbral Harmony\context.md

```markdown
# 🌑 Project Spec: The Umbral Harmony (Polyundertonality Generatior)

### 1. Концепция (The Core)
Генеративная система Just Intonation, основанная на принципе **обратной проекции**. Вместо классического построения "от баса вверх" (обертоны), система проецирует лады "сверху вниз" (унтертоны/субгармоники) от заданных вершин, фильтруя их через единую математическую сетку.

**Философия:** Теория "Умбральной Гармонии" соединяет множество верхних точек опоры (*Apex*) с единым скрытым фундаментом (*Depth*).

### 2. Терминология (Strict Vocabulary)
*Использовать в коде и документации.*

*   **Apex (вершина):** *input*. Верхняя точка опоры лада (числитель дроби, `1/1`, `2/1`... `N/1`).
*   **Depth (глубина):** *metric*. Глобальный фундамент системы. Определяется через `GCD` всех нот системы. Знаменатель этого GCD — и есть "глубина" (фактически `LCM` всех знаменателей).
*   **Stem (стем):** *structure*. Интервальная структура лада, соединяющая вершину и глубину.
*   **Stem Pruning (стем-прунинг):** *algo*. Метод оптимизации системы путем отсечения "шумных" знаменателей.
*   **Umbral Modes (умбральные лады):** *output*. Результирующие звукоряды (сущностно — минорные/инвертированные), нормализованные в октаву.

### 3. Алгоритм: Stem Pruning (v3.0 Logic)
Система не использует метрики попарного консонанса или эвристики сложности простых чисел (Эйлер, Мурзин и т.д.). Только структурная арифметика.

**Входные данные:**
*   `pool_size`: Количество вершин и исходный диапазон знаменателей (обычно 32-64).
*   `max_resolution`: Лимит глубины (максимально допустимый знаменатель глобального корня). Пример: `2520` (7-limit), `5040`.

**Цикл работы:**
1.  **Shadow Projection:** Генерируем "сырую массу".
    *   Для каждой *Apex* (от 1 до `pool_size`):
    *   Создаем ряд дробей `Apex / n`, где `n` от 1 до `pool_size`. (Дроби сразу сокращаются: `3/6` -> `1/2`).
2.  **Analysis:** Считаем текущий `System Root` (GCD всех нот во всех ладах).
    *   *Math:* $GCD(n_1/d_1, n_2/d_2) = \frac{gcd(n_1, n_2)}{lcm(d_1, d_2)}$.
    *   *Depth* = Знаменатель этого System Root.
    *   *Важно:* Использовать **BigInt**! Значения растут экспоненциально.
3.  **Check:** Если `Depth <= max_resolution`, вернуть систему.
4.  **Identification (The Heuristic):**
    *   Собираем все уникальные знаменатели системы.
    *   **CRITICAL:** Сортируем их по **убыванию** (`desc`). Мы обязаны удалять большие числа (шум) раньше малых (музыкальные интервалы), если они вносят одинаковый вклад в "раздувание" глубины.
    *   Для каждого кандидата вычисляем: "Какова будет `Depth`, если удалить этот знаменатель?".
    *   Выбираем "Жертву" — знаменатель, удаление которого дает **минимальную** новую глубину (максимальный GCD).
5.  **Pruning:** Удаляем ноты с этим знаменателем из *всех* ладов.
6.  **Recursion:** Повторяем с шага 2.

### 4. Технические нюансы и "Gotchas"

1.  **BigInt Necessity:** В JS нет нативного GCD для дробей, а `Math` работает с float64. Вся арифметика генерации (включая промежуточные `lcm`) должна быть строго на `BigInt`.
2.  **Rational Simplification:** Julia делает `simplify` (сокращение дробей) автоматически. В JS при создании дроби `Apex/n` необходимо сразу делать сокращение через GCD, иначе алгоритм будет видеть ложные знаменатели (например, `2/4` должно стать `1/2` до попадания в пул анализа).
3.  **"Curse of 1/1":** Лад с *Apex*=1 всегда будет самым бедным (содержит только 1/1, 1/2...). Это физическое свойство (чем выше вершина, тем богаче гармония). Не пытаться исправлять.
4.  **Empty Scales:** В процессе прунинга лад может опустеть (остаться < 3 нот). Фильтровать такие лады перед следующим шагом рекурсии.

### 5. Стек и Архитектура

*   **Core Lib:** `ji-lib-core.js` (Readonly). Используем для финальных объектов `RationalInterval` и утилит.
*   **Gen Module:** Пишем новый модуль `ji-gen-stem.js`.
    *   Внутренняя реализация `BigIntMath` (`gcd`, `lcm`).
    *   Функция `generateSystem(config)`.
    *   Функция `transformView(system, mode)`.

### 6. Режимы отображения (View Modes)

1.  **Relative (Основной):** Лад показывается относительно своей вершины, нормализованный в октаву.
    *   Показывает: "Окраску лада" (e.g., Phrygian flavor).
    *   Formula: `normalize(note / apex)`.
2.  **Harmonic (Аналитический):** Все ноты приводятся к общему знаменателю (глубине).
    *   Показывает: "Позицию на единой частотной сетке".
    *   Formula: `note / SystemRoot`.
3.  **Absolute (Сырой):** Исходные дроби `Apex/n` (сокращенные).

---
*Статус: Готов к портированию. Julia-прототип стабилизирован (v1.0).*
```

## 1_oscilloscope.html

```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Аддитивный синтезатор</title>
  <style>
    /* Определяем CSS-константы (переменные) */
    :root {
      --color-bg: hsl(100, 100%, 100%);
      --color-canvas-bg: hsla(100, 100%, 100%, 0.33);
      --color-horizontal-line: #616161;
      --color-waveform: #00BCD4;
      --color-button-bg: #303f9f;
      --color-button-hover: rgba(33, 150, 243, 0.8);
      --color-button-text: #FFFFFF;
      --text-primary: #FFFFFF;
    }

    /* Сброс стилей */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      height: 100%;
      overflow: hidden;
    }
    body {
      font-family: "Roboto", sans-serif;
      background-color: var(--color-bg);
    }
    /* Контейнер, занимающий весь экран */
    #oscillator-container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    /* Canvas занимает весь контейнер */
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: block;
    }
    #button-container {
      position: fixed;
      bottom: 0;
      left: 0;
      z-index: 2;
    }
    button {
      background-color: rgb(25, 70, 81);
      color: rgb(255, 255, 255);
      font-size: 14px;
      border: none;
      padding: 10px 20px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }
    button:hover {
      background-color: rgb(30, 85, 97);
    }
    button:active {
      background-color: rgb(20, 60, 71);
    }
    /* Оверлей "Tap to start" с изменённым стилем*/
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.66);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-primary);
      font-size: 20px;
      z-index: 1000;
      cursor: pointer;
    }
    #overlay:hover {
      background-color: rgba(0,0,0,0.50);
    }
  </style>
</head>
<script src="lib/audio-lib.js"></script>
<body>
  <div id="oscillator-container">
    <canvas></canvas>
    <div id="button-container"></div>
  </div>

  <div id="overlay">Tap to start</div>

  <script>
    // Параметры отрисовки
    const lineWidth = 12;
    const HORIZONTAL_LINE_COLOR = '#616161';
    const WAVEFORM_COLOR = '#00BCD4';

    // Инициализация аудио (используем Utils из audio-lib.js)
    const audioCtx = Utils.initAudio();
    const analyser = audioCtx.createAnalyser();
    analyser.fftSize = 4096;
    analyser.connect(audioCtx.destination);

    let base = 200;
    const oscillators = [];

    const waveformHistory = [];
    const historySize = 10;
    const waveEnd = 121;

    class SynthButton {
      constructor(freq) {
        this.freq = freq;
        this.synth = new Synth(audioCtx, {
          envelope: { attack: 0.6, decay: 1.2, sustain: 0.9, release: 0.6 }
        });
        this.synth.connect(analyser);
        this.isPlaying = false;

        this.button = document.createElement('button');
        this.button.textContent = freq + ' Hz';
        this.button.className = 'synth-button';

        this.button.addEventListener('pointerdown', this.playNote.bind(this));
        this.button.addEventListener('pointerup', this.stopNote.bind(this));
        this.button.addEventListener('pointercancel', this.stopNote.bind(this));
        this.button.addEventListener('pointerleave', this.stopNote.bind(this));

        document.getElementById('button-container').appendChild(this.button);
      }

      playNote(e) {
        e.preventDefault();
        if (this.isPlaying) return;
        this.isPlaying = true;
        this.synth.noteOn('main', this.freq, 1);
      }

      stopNote(e) {
        e.preventDefault();
        if (!this.isPlaying) return;
        this.isPlaying = false;
        this.synth.noteOff('main');
      }
    }

    function resizeCanvas(canvas) {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    function setup() {
      const oscillatorContainer = document.getElementById('oscillator-container');
      const canvas = oscillatorContainer.querySelector('canvas');
      const ctx = canvas.getContext('2d');

      resizeCanvas(canvas);
      window.addEventListener('resize', () => resizeCanvas(canvas));

      for (let i = 1; i <= 5; i++) {
        let frequency = base * i;
        oscillators.push(new SynthButton(frequency));
      }

      drawWaveform(ctx, canvas);
    }

    function map(value, inMin, inMax, outMin, outMax) {
      return outMin + (outMax - outMin) * ((value - inMin) / (inMax - inMin));
    }

    function cropWaveform(waveform) {
      let changeIndex = 0;
      let delta = 1;
      for (let i = 1; i < waveform.length - 1; i++) {
        if (Math.abs(waveform[i]) < delta && waveform[i - 1] > waveform[i + 1]) {
          delta = Math.abs(waveform[i]);
          changeIndex = i;
        }
      }
      return changeIndex !== 0 ? waveform.slice(changeIndex) : waveform;
    }

    function drawWaveform(ctx, canvas) {
      const bufferLength = analyser.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);
      analyser.getByteTimeDomainData(dataArray);

      let waveform = Array.from(dataArray).map(value => (value - 128) / 128);
      let croppedWaveform = cropWaveform(waveform);
      let waveformToDraw = croppedWaveform.slice(0, waveEnd);

      waveformHistory.push(waveformToDraw);
      if (waveformHistory.length > historySize) {
        waveformHistory.shift();
      }

      const blendedWaveform = [];
      for (let i = 0; i < waveEnd; i++) {
        let sum = 0, weightSum = 0;
        for (let j = 0; j < waveformHistory.length; j++) {
          const weight = map(j, 0, waveformHistory.length - 1, 0.2, 1);
          sum += (waveformHistory[j][i] || 0) * weight;
          weightSum += weight;
        }
        blendedWaveform.push(sum / weightSum);
      }

      // Очистка канвы (эффект trail)
      ctx.fillStyle = getComputedStyle(document.documentElement)
                        .getPropertyValue('--color-canvas-bg');
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Центральная линия
      ctx.strokeStyle = HORIZONTAL_LINE_COLOR;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, canvas.height / 2);
      ctx.lineTo(canvas.width, canvas.height / 2);
      ctx.stroke();

      // Волна
      ctx.beginPath();
      ctx.strokeStyle = WAVEFORM_COLOR;
      ctx.lineWidth = lineWidth;
      const scale = canvas.height * 0.48;
      const offset = canvas.height / 2;
      for (let i = 0; i < blendedWaveform.length; i++) {
        let x = map(i, 0, blendedWaveform.length - 1, 0, canvas.width);
        let y = blendedWaveform[i] * scale + offset;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      }
      ctx.stroke();

      requestAnimationFrame(() => drawWaveform(ctx, canvas));
    }

    document.addEventListener('DOMContentLoaded', function() {
      setup();

      const overlay = document.getElementById('overlay');
      overlay.addEventListener('pointerdown', function(e) {
        e.preventDefault();
        audioCtx.resume().then(() => {
          overlay.style.display = 'none';
        });
      });
    });
  </script>
</body>
</html>
```

## 2_harmonics.html

```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Harmonic Series</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&family=Space+Grotesk:wght@400;600;700&display=swap" rel="stylesheet">

  <style>
    :root {
      /* === PALETTE (HSL) === */
      --bg-void: hsl(230, 25%, 6%);
      --bg-void: hsl(240, 25%, 5%);

/*      --bg-panel: hsl(225, 15%, 9%);*/
      --bg-panel: hsl(222, 20%, 11%);
      
      /* Vibrant Colors */
      --hue-red: 0;
      --hue-green: 130;
      
      /* Input Colors */
      --ratio1-color: hsl(0, 100%, 80%);
      --ratio2-color: hsl(120, 100%, 80%);
      
      /* Text */
      --text-bright: hsl(0, 0%, 100%);
      --text-dim: hsl(220, 10%, 60%);

      /* UI Dimensions */
      --panel-height: 70px;
    }

    /* === RESET & LAYOUT === */
    html, body {
      margin: 0;
      height: 100vh;
      width: 100vw;
      color: var(--text-bright);
      font-family: 'Space Grotesk', sans-serif;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      touch-action: none;
      user-select: none;
    }

    /* === HEADER PANEL === */
    #row {
      background-color: var(--bg-panel);
      height: var(--panel-height);
      padding: 0 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid hsla(0, 0%, 100%, 0.1);
      z-index: 10;
      gap: 20px;
    }

    .app-title {
      font-size: 18px;
      font-weight: 700;
      color: var(--text-bright);
      text-transform: uppercase;
      letter-spacing: 1px;
      white-space: nowrap;
    }

    .controls-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }

    /* === INPUTS (STYLED FROM FIRST FILE) === */
    input {
      width: 60px;
      text-align: center;
      border: none;
      border-radius: 4px;
      padding: 8px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 16px;
      font-weight: 500;
      outline: none;
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    }

    /* Ratio 1 Styles */
    #ratio1 {
      background-color: hsla(0, 100%, 80%, 0.15);
      color: var(--ratio1-color);
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);
    }
    #ratio1:focus {
      background-color: hsla(0, 100%, 80%, 0.2);
      box-shadow:
        inset 0 1px 2px hsla(0, 0%, 0%, 0.1),
        inset -2px -6px 24px 0px hsla(0, 100%, 80%, 0.25);
    }

    /* Ratio 2 Styles */
    #ratio2 {
      background-color: hsla(120, 100%, 80%, 0.15);
      color: var(--ratio2-color);
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);
    }
    #ratio2:focus {
      background-color: hsla(120, 100%, 80%, 0.2);
      box-shadow:
        inset 0 1px 2px hsla(0, 0%, 0%, 0.1),
        inset -2px -6px 24px 0px hsla(120, 100%, 80%, 0.25);
    }

    /* Static Text & Math */
    .math-op {
      font-size: 20px;
      font-weight: 400;
      color: var(--text-bright);
      font-family: 'JetBrains Mono', monospace;
    }

    #divided, #gcd_value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 16px;
      color: var(--text-bright);
      padding: 4px 8px;
      background: transparent;
      font-weight: 300;
    }

    #gcd {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: 20px;
      color: var(--text-dim);
      font-size: 16px;
      font-weight: 500;
    }

    /* === CANVAS === */
    canvas {
      flex: 1;
      display: block;
      width: 100%;
      height: 100%;
      background-color: var(--bg-void);
      touch-action: none;
    }

    /* === OVERLAY === */
    #overlay {
      position: absolute;
      top: var(--panel-height);
      left: 0; 
      right: 0; 
      bottom: 0;
      background: rgba(0,0,0,0.8);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      cursor: pointer;
    }
    #overlay-text {
      border: 1px solid var(--text-bright);
      color: var(--text-bright);
      padding: 12px 24px;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    /* === RESPONSIVE === */
    @media (max-width: 700px) {
      #row {
        height: auto;
        padding: 15px;
        flex-direction: column;
        gap: 15px;
      }
      .controls-container {
        width: 100%;
        justify-content: space-between;
      }
      #gcd { 
        margin-left: 0; 
      }
      #overlay { 
        top: 0; 
      }
      input {
        width: 50px;
        font-size: 14px;
      }
    }
  </style>
</head>
<body>

  <div id="row">
    <div class="app-title">Harmonic Series</div>
    
    <div class="controls-container">
      <input type="text" id="ratio1" value="3/2" inputmode="decimal">
      <span class="math-op">×</span>
      <div id="divided">4/3</div>
      <span class="math-op">=</span>
      <input type="text" id="ratio2" value="2/1" inputmode="decimal">
      
      <div id="gcd">
        <span>Тоника:</span>
        <div id="gcd_value"></div>
      </div>
    </div>
  </div>

  <canvas id="myCanvas"></canvas>

  <div id="overlay">
    <div id="overlay-text">Tap to start</div>
  </div>

  <script type="text/javascript" src="lib/ji-lib.js"></script>
  <script>
    // ===== Настройка Web Audio API =====
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    audioCtx.suspend();
    
    const compressor = audioCtx.createDynamicsCompressor();
    compressor.threshold.value = -30;
    compressor.ratio.value = 12;
    compressor.attack.value = 0.03;
    compressor.release.value = 0.1;
    compressor.knee.value = 30;
    compressor.connect(audioCtx.destination);
    
    function logAttenuation(freq, cutoff, startFraction = 0.95) {
      const startFreq = cutoff * startFraction;
      if (freq <= startFreq) return 1;
      if (freq >= cutoff) return 0;
      const ratio = (Math.log(freq) - Math.log(startFreq)) / (Math.log(cutoff) - Math.log(startFreq));
      return 1 - ratio;
    }
    
    // ===== Класс простого синтезатора с огибающей =====
    class SimpleSynth {
      constructor(volumeDb, envelope) {
        this.volumeDb = volumeDb;
        this.envelope = envelope;
      }
      
      triggerAttack(freq) {
        this.oscillator = audioCtx.createOscillator();
        this.oscillator.type = 'sine';
        this.oscillator.frequency.value = freq;
        
        this.gainNode = audioCtx.createGain();
        this.gainNode.gain.value = 0;
        
        this.oscillator.connect(this.gainNode);
        this.gainNode.connect(compressor);
        
        const amp = Math.pow(10, this.volumeDb / 20);
        const now = audioCtx.currentTime;
        this.gainNode.gain.linearRampToValueAtTime(amp, now + this.envelope.attack);
        this.oscillator.start(now);
      }
      
      triggerRelease() {
        if (this.oscillator && this.gainNode) {
          const now = audioCtx.currentTime;
          const amp = Math.pow(10, this.volumeDb / 20);
          this.gainNode.gain.setValueAtTime(amp, now);
          this.gainNode.gain.linearRampToValueAtTime(0, now + this.envelope.release);
          this.oscillator.stop(now + this.envelope.release);
          this.oscillator = null;
          this.gainNode = null;
        }
      }
      
      triggerAttackRelease(freq, duration) {
        const osc = audioCtx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = freq;
        
        const gainNode = audioCtx.createGain();
        gainNode.gain.value = 0;
        
        osc.connect(gainNode);
        gainNode.connect(compressor);
        
        const amp = Math.pow(10, this.volumeDb / 20);
        const now = audioCtx.currentTime;
        gainNode.gain.linearRampToValueAtTime(amp, now + this.envelope.attack);
        const sustainStart = now + duration - this.envelope.release;
        gainNode.gain.setValueAtTime(amp, sustainStart);
        gainNode.gain.linearRampToValueAtTime(0, now + duration);
        
        osc.start(now);
        osc.stop(now + duration);
      }
    }
    
    // ===== Canvas и автомасштабирование =====
    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext("2d");
    
    let dynamicLowerLog = 0;
    let dynamicUpperLog = 1;
    
    const marginSemitones = 2;
    const smoothingFactor = 0.05;
    let targetDynamicLowerLog = dynamicLowerLog;
    let targetDynamicUpperLog = dynamicUpperLog;
    
    const topMargin = 0;
    const bottomMargin = 40;
    
    function logScale(freq) {
      return Math.log2(freq);
    }
    
    function map(value, inMin, inMax, outMin, outMax) {
      return outMin + (outMax - outMin) * ((value - inMin) / (inMax - inMin));
    }
    
    function updateCanvasSize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight - document.getElementById('row').offsetHeight;
    }
    
    function brightenColor(color, amount) {
      return {
        r: Math.min(color.r + amount, 255),
        g: Math.min(color.g + amount, 255),
        b: Math.min(color.b + amount, 255),
        a: color.a
      };
    }

    const GLOBAL_CUTOFF = 2000;
    
    let notes = [];
    let selectedNote = null;
    let dragOffsetX = 0;
    const circleR = 8;
    const rectHeight = 4;
    
    class Harmonic {
      constructor(freq, finalVol, noteLength, x, noteColor) {
        this.freq = freq;
        this.vol = finalVol;
        this.noteLength = noteLength;
        this.x = x;
        this.noteColor = noteColor;
        this.highlighted = false;
        const audioVol = finalVol * 0.7;
        const volDb = (audioVol > 0) ? 20 * Math.log10(audioVol) : -60;
        this.synth = new SimpleSynth(volDb, { attack: 0.1, release: 0.5 });
      }
      
      display() {
        let logY = map(logScale(this.freq), dynamicLowerLog, dynamicUpperLog, bottomMargin, canvas.height - topMargin);
        this.y = canvas.height - logY;
        ctx.save();
        
        if (this.highlighted) {
          const brightColor = brightenColor(this.noteColor, 80);
          let gradient = ctx.createLinearGradient(this.x, this.y, this.x + this.noteLength, this.y);
          gradient.addColorStop(0, `rgba(${brightColor.r}, ${brightColor.g}, ${brightColor.b}, ${this.vol})`);
          gradient.addColorStop(0.5, `rgba(${brightColor.r}, ${brightColor.g}, ${brightColor.b}, ${Math.min(this.vol * 1.3,1)})`);
          gradient.addColorStop(1, 'rgba(9, 9, 15, 0)');
          ctx.fillStyle = gradient;
          ctx.shadowColor = `rgba(${brightColor.r}, ${brightColor.g}, ${brightColor.b}, 0.9)`;
          ctx.shadowBlur = 30;
          ctx.fillRect(this.x, this.y, this.noteLength, rectHeight);
        } else {
          let gradient = ctx.createLinearGradient(this.x, this.y, this.x + this.noteLength, this.y);
          gradient.addColorStop(0, `rgba(${this.noteColor.r}, ${this.noteColor.g}, ${this.noteColor.b}, ${this.vol})`);
          gradient.addColorStop(1, 'rgba(9, 9, 15, 0)');
          ctx.fillStyle = gradient;
          ctx.fillRect(this.x, this.y, this.noteLength, rectHeight);
        }
        ctx.restore();
      }
    }
    
    class Note {
      constructor(freq, ratio, x, noteLength, noteColor) {
        this.freq = freq * ratio.numerator / ratio.denominator;
        this.x = x;
        this.noteLength = noteLength;
        this.noteColor = noteColor;
        this.numHarmonics = Math.max(1, Math.round(GLOBAL_CUTOFF / this.freq));
        this.harmonics = [];
        const localCutoff = this.freq * this.numHarmonics;
        for (let i = 1; i <= this.numHarmonics; i++) {
          let harmonicFreq = this.freq * i;
          let attenuation = logAttenuation(harmonicFreq, localCutoff, 0.95);
          let frequencyAttenuation = 1 / i;
          let finalVol = attenuation * frequencyAttenuation;
          this.harmonics.push(new Harmonic(harmonicFreq, finalVol, this.noteLength, this.x, this.noteColor));
        }
      }
      
      display() {
        let logY = map(logScale(this.freq), dynamicLowerLog, dynamicUpperLog, bottomMargin, canvas.height - topMargin);
        this.y = canvas.height - logY;
        ctx.save();
        ctx.fillStyle = 'white';
        if (selectedNote === this) {
          ctx.shadowColor = 'rgba(255, 255, 255, 0.9)';
          ctx.shadowBlur = 15;
        }

        for (let harmonic of this.harmonics) {
          harmonic.x = this.x;
          harmonic.display();
        }
        ctx.beginPath();
        ctx.arc(this.x, this.y + rectHeight / 2, circleR, 0, 2 * Math.PI);
        ctx.fill();
        ctx.restore();
      }
      
      playSound() {
        for (let harmonic of this.harmonics) {
          harmonic.synth.triggerAttackRelease(harmonic.freq, 0.5);
        }
      }
    }
    
    function updateDynamicBoundaries() {
      let minFreq = Infinity;
      let maxFreq = 0;
      for (let note of notes) {
        for (let harmonic of note.harmonics) {
          if (harmonic.freq < minFreq) minFreq = harmonic.freq;
          if (harmonic.freq > maxFreq) maxFreq = harmonic.freq;
        }
      }
      const newTargetLower = Math.log2(minFreq) - (marginSemitones / 12);
      const newTargetUpper = Math.log2(maxFreq) + (marginSemitones / 12);
      
      targetDynamicLowerLog = newTargetLower;
      targetDynamicUpperLog = newTargetUpper;
      
      dynamicLowerLog += (targetDynamicLowerLog - dynamicLowerLog) * smoothingFactor;
      dynamicUpperLog += (targetDynamicUpperLog - dynamicUpperLog) * smoothingFactor;
    }
    
    function setup() {
      const ratio1Input = document.getElementById('ratio1').value;
      const ratio2Input = document.getElementById('ratio2').value;
      
      let [numerator1, denominator1] = ratio1Input.split('/').map(Number);
      let [numerator2, denominator2] = ratio2Input.split('/').map(Number);
      
      const checkNumber = (number) => Number.isInteger(number) && (number >= 1 && number <= 12);
      let note1, note2;
      if (checkNumber(numerator1) && checkNumber(denominator1) &&
          checkNumber(numerator2) && checkNumber(denominator2)) {
          note1 = new jiLib.RationalInterval(numerator1, denominator1);
          note2 = new jiLib.RationalInterval(numerator2, denominator2);
      }
      
      let tonica = jiLib.gcdOfRationals(note1, note2);
      
      const color1 = { r: 128, g: 128, b: 128, a: 0.5 };
      const color2 = { r: 255, g: 0, b: 0, a: 1 };
      const color3 = { r: 0, g: 255, b: 0, a: 1 };
      
      notes = [
        new Note(100, tonica, 50, 600, color1),
        new Note(100, note1, 100, 150, color2),
        new Note(100, note2, 200, 150, color3)
      ];
      
      const divisionResult = note2.divide(note1);
      const gcdResult = jiLib.gcdOfRationals(note1, note2);

      document.getElementById('divided').innerHTML = `${divisionResult.numerator}/${divisionResult.denominator}`;
      document.getElementById('gcd_value').innerHTML = `${gcdResult.numerator}/${gcdResult.denominator}`;
    }
    
    function draw() {
      updateDynamicBoundaries();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Аддитивный режим смешивания для свечения
      // ctx.globalCompositeOperation = 'lighter';
      
      for (let note of notes) {
        note.display();
      }
      
      // Возврат к обычному режиму
      // ctx.globalCompositeOperation = 'source-over';
      
      requestAnimationFrame(draw);
    }
    
    function getCanvasCoordinates(event) {
      const rect = canvas.getBoundingClientRect();
      let clientX, clientY;
      if (event.touches && event.touches.length > 0) {
        clientX = event.touches[0].clientX;
        clientY = event.touches[0].clientY;
      } else {
        clientX = event.clientX;
        clientY = event.clientY;
      }
      return { x: clientX - rect.left, y: clientY - rect.top };
    }
    
    function handlePointerDown(event) {
      event.preventDefault();
      const pos = getCanvasCoordinates(event);

      for (let note of notes) {
        const dx = pos.x - (note.x - circleR);
        const dy = pos.y - (note.y + rectHeight / 2);
        if (Math.hypot(dx, dy) < circleR * 3) {
          selectedNote = note;
          dragOffsetX = pos.x - note.x;
          note.playSound();
          note.harmonics.forEach(h => { h.highlighted = true; });
          setTimeout(() => {
            note.harmonics.forEach(h => { h.highlighted = false; });
          }, 700);
          return;
        }
      }

      let candidates = [];
      for (let note of notes) {
        for (let harmonic of note.harmonics) {
          let hx = note.x;
          if (
            pos.x > hx &&
            pos.x < hx + harmonic.noteLength &&
            pos.y > harmonic.y - rectHeight / 2 - 8 &&
            pos.y < harmonic.y + rectHeight + 8
          ) {
            candidates.push({ note, harmonic });
          }
        }
      }
      if (candidates.length > 0) {
        let bestCandidate = candidates[0];
        for (let candidate of candidates) {
          if (candidate.note.y < bestCandidate.note.y) {
            bestCandidate = candidate;
          }
        }
        bestCandidate.harmonic.synth.triggerAttackRelease(bestCandidate.harmonic.freq, 0.5);
        bestCandidate.harmonic.highlighted = true;
        setTimeout(() => {
          bestCandidate.harmonic.highlighted = false;
        }, 700);
        return;
      }
    }
    
    function handlePointerMove(event) {
      if (!selectedNote) return;
      event.preventDefault();
      const pos = getCanvasCoordinates(event);
      selectedNote.x = pos.x - dragOffsetX;
    }
    
    function handlePointerUp(event) {
      selectedNote = null;
    }
    
    updateCanvasSize();
    setup();
    draw();
    
    window.addEventListener('resize', updateCanvasSize);
    
    canvas.addEventListener('mousedown', handlePointerDown);
    canvas.addEventListener('touchstart', handlePointerDown);
    canvas.addEventListener('mousemove', handlePointerMove);
    canvas.addEventListener('touchmove', handlePointerMove);
    canvas.addEventListener('mouseup', handlePointerUp);
    canvas.addEventListener('touchend', handlePointerUp);
    
    document.getElementById('ratio1').addEventListener('input', setup);
    document.getElementById('ratio2').addEventListener('input', setup);
    
    document.getElementById('overlay').addEventListener('click', function() {
      if (audioCtx.state !== 'running') {
        audioCtx.resume();
      }
      this.style.display = 'none';
    });
  </script>
</body>
</html>
```

## 3_entropy.html

```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Harmonic Entropy 2.0 (Original + CWHE)</title>
  <style>
    :root {
      --bg-color: #121212;
      --surface-color: #1E1E1E;
      --primary-color: #BB86FC;
      --secondary-color: #03DAC6;
      --text-primary: rgba(255,255,255,0.87);
      --text-secondary: rgba(255,255,255,0.6);
      --surface-overlay: rgba(255,255,255,0.05);
      --border-color: rgba(255,255,255,0.1);
    }
    body {
      background: var(--bg-color);
      color: var(--text-primary);
      font-family: 'Roboto', sans-serif;
      margin: 0;
      padding: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #appContainer {
      width: 90%;
      max-width: 1000px;
      display: flex;
      flex-direction: column;
      height: 80vh;
    }
    #HEPlotDiv {
      position: relative;
      flex-grow: 1;
      width: 100%;
      border-radius: 8px;
      overflow: hidden;
      background: var(--surface-color);
      padding: 0;
      box-sizing: border-box;
      cursor: pointer;
      display: flex;
    }
    #heChart { display:block; width:100%; height:100%; }
    #controls {
      background: var(--surface-color);
      border-radius: 12px;
      padding: 16px 24px;
      margin: 20px 0 0 0;
      width: 100%;
      box-shadow: 0 4px 12px rgba(0,0,0,0.25);
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
      flex-shrink: 0;
      box-sizing: border-box;
    }
    .controls-column-left, .controls-column-right { display:flex; flex-direction:column; gap:12px; }
    .controlrow { display:grid; grid-template-columns:0.8fr 2fr; align-items:center; gap:12px; }
    .label { color: var(--text-secondary); font-size:14px; text-align:right; padding-right:8px; }
    .input-group { display:flex; align-items:center; flex:1; max-width:220px; gap:8px; }
    .textinput, .selectinput {
      background: var(--surface-overlay); border:1px solid var(--border-color); color:var(--text-primary);
      padding:12px; border-radius:8px; font-size:14px; width:100%; height:44px; box-sizing:border-box;
    }
    .slider-container { height:44px; display:flex; align-items:center; min-width:180px; width:100%; gap:8px; }
    .slider {
      -webkit-appearance:none; width:100%; height:2px; background:var(--border-color); border-radius:1px; outline:none;
    }
    .slider::-webkit-slider-thumb {
      -webkit-appearance:none; width:20px; height:20px; background:var(--primary-color); border-radius:50%; cursor:pointer;
    }
    .stepper-button { background:var(--surface-color); color:var(--text-primary); border:1px solid var(--border-color);
      border-radius:6px; width:32px; height:44px; cursor:pointer; display:flex; align-items:center; justify-content:center;
    }
    #status { position:absolute; left:10px; top:10px; background:rgba(0,0,0,0.35); color:var(--text-primary);
      padding:6px 10px; border-radius:8px; font-size:12px; }
    .checkbox-inline { display:flex; align-items:center; gap:8px; justify-content:flex-start; }
    .checkbox-inline input { width:18px; height:18px; }
    /* небольшой блок для визуализации/редактирования дефолтов (скрываемые настройки) */
    #defaultsBlock { margin-top:8px; color:var(--text-secondary); font-size:13px; }
    #defaultsBlock pre { margin:0; background: rgba(255,255,255,0.02); padding:8px; border-radius:6px; overflow:auto; max-height:120px;}
    /* Dark theme for selects/options/inputs */
    .selectinput, .textinput, select, input[type="number"], input[type="text"] {
      background-color: var(--surface-overlay) !important;
      color: var(--text-primary) !important;
      border: 1px solid var(--border-color) !important;
    }
    select option {
      background-color: var(--surface-color);
      color: var(--text-primary);
    }
    .selectinput:focus, .textinput:focus, select:focus, input[type="number"]:focus, input[type="text"]:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 2px rgba(187,134,252,0.25);
    }
    select {
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      background-image:
        linear-gradient(45deg, var(--text-secondary) 50%, transparent 50%),
        linear-gradient(-45deg, var(--text-secondary) 50%, transparent 50%),
        linear-gradient(to right, transparent 0, transparent 100%);
      background-position:
        calc(100% - 18px) calc(50% - 3px),
        calc(100% - 12px) calc(50% - 3px),
        100% 0;
      background-size: 6px 6px, 6px 6px, 2.5em 100%;
      background-repeat: no-repeat;
      padding-right: 2.5em;
    }
    .selectinput:hover, select:hover, .textinput:hover, input[type="number"]:hover, input[type="text"]:hover {
      border-color: rgba(255,255,255,0.18);
    }
    select:disabled, .selectinput:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <div id="appContainer">
    <div id="HEPlotDiv">
      <canvas id="heChart"></canvas>
      <div id="status">ready</div>
    </div>

    <div id="controls">
      <div class="controls-column-left">
        <div class="controlrow">
          <span class="label">Mode:</span>
          <div class="input-group">
            <select id="modeSelect" class="selectinput">
              <option value="heClassic" selected>Classic (Paul Erlich)</option>
              <option value="euler">Euler Gradus Suavitatis (complexity)</option>
              <option value="murzin">Evgeny Murzin (% of matching overtones)</option>
              <option value="harmUtility">HarmUtility</option>
              <!-- TODO:  Здесь нужно добавить все остальные режимы из ji-lib.js. -->
            </select>
          </div>
        </div>

        <div class="controlrow">
          <span class="label">N:</span>
          <div class="input-group">
            <input id="textN" type="number" class="textinput" value="3000" />
          </div>
        </div>
        <div class="controlrow">
          <span class="label">Min (octaves):</span>
          <div class="input-group">
            <button class="stepper-button minus" data-target="textmin">-</button>
            <input id="textmin" type="number" class="textinput" value="0" step="1" />
            <button class="stepper-button plus" data-target="textmin">+</button>
          </div>
        </div>
        <div class="controlrow">
          <span class="label">Max (octaves):</span>
          <div class="input-group">
            <button class="stepper-button minus" data-target="textmax">-</button>
            <input id="textmax" type="number" class="textinput" value="1" step="1" />
            <button class="stepper-button plus" data-target="textmax">+</button>
          </div>
        </div>

        <div class="controlrow">
          <span class="label">Invert (Y):</span>
          <div class="input-group">
            <label class="checkbox-inline">
              <input type="checkbox" id="invertCheck" checked />
              <span style="color:var(--text-secondary); font-size:13px;">Инвертировать график (по умолчанию)</span>
            </label>
          </div>
        </div>
      </div>

      <div class="controls-column-right">
        <div class="controlrow">
          <span class="label" id="aval">Bandwidth (a): 2.40</span>
          <div class="slider-container">
            <!-- default min/max correspond to ORIGINAL mode (1..4). main.js будет менять при выборе CWHE -->
            <input type="range" id="slidera" class="slider" min="1" max="4" step="0.01" value="2.4" />
          </div>
        </div>
        <div class="controlrow">
          <span class="label" id="sval">Smoothing (s): 1.25%</span>
          <div class="slider-container">
            <input type="range" id="sliders" class="slider" min="0.5" max="2.1" step="0.01" value="1.25" />
          </div>
        </div>
        <div class="controlrow">
           <span class="label" id="noteDelayLabel">Note Delay: 0.15s</span>
          <div class="slider-container">
            <input type="range" id="noteDelay" class="slider" min="0" max="0.3" step="0.0001" value="0.15" />
          </div>
        </div>
      </div>
    </div>

  </div>


  </script>
  <script src="./lib/ji-lib.js"></script>
  <script src="./lib/audio-lib.js"></script>
  <script src="./lib/chart-renderer.js"></script>
  <script src="./lib/entropy.js"></script>
  <script src="entropy_main.js"></script>
  
</body>
</html>
```

## 4_intervals generator.html

```html
<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Intervals Generator</title>
<style>
:root{--bg:#121212; --surf:#1e1e1e; --acc:#00e676; --err:#cf6679; --txt:#e0e0e0; --border:#333;}
body{font-family:'Segoe UI', Roboto, monospace; margin:0; padding:1rem; background:var(--bg); color:var(--txt); height:100vh; display:flex; flex-direction:column; gap:1rem;}

/* Запрет выделения текста */
.no-select { user-select: none; -webkit-user-select: none; }

/* --- CONTROLS --- */
.controls{
    background:var(--surf); 
    padding:1rem; 
    border-radius:8px; 
    display:grid; 
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); 
    gap:1rem; 
    border:1px solid var(--border); 
    align-items: start; 
}

.col{ display:flex; flex-direction:column; gap:0.4rem; }
.input-box { height: 36px; box-sizing: border-box; display: flex; align-items: center; }

label{font-size:0.65rem; text-transform:uppercase; color:#888; font-weight:700; letter-spacing:0.5px; margin-bottom: 2px; user-select: none;}

input[type="number"], input[type="text"], select{
    background:#252525; border:1px solid #444; color:var(--txt); padding:0 0.5rem; 
    border-radius:4px; font-size:0.9rem; width: 100%; height: 100%; outline: none;
}

/* --- SLIDERS (Unified Style) --- */
.range-wrap {
    position: relative; width: 100%; height: 100%; display: flex; align-items: center; z-index: 1;
}
/* Линия фона */
.range-bg { position: absolute; width: 100%; height: 4px; background: #333; border-radius: 2px; z-index: 1; }
/* Активная заливка */
.range-fill { position: absolute; height: 4px; background: var(--acc); border-radius: 2px; z-index: 2; pointer-events: none; }

input[type="range"] {
    -webkit-appearance: none; appearance: none; background: transparent; margin: 0; border: none; width: 100%; height: 100%;
    position: absolute; z-index: 3; cursor: pointer;
}
input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none; width: 14px; height: 14px;
    border-radius: 50%; background: #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.5); margin-top: -5px;
}
/* Хак для центровки Thumb в Chrome/Webkit */
.range-wrap input[type="range"]::-webkit-slider-thumb { margin-top: 0; }

/* --- TABLE --- */
.table-wrap{flex:1; overflow:auto; border:1px solid var(--border); border-radius:8px; background:var(--surf); position:relative;}
table{width:100%; border-collapse:collapse; font-size:0.85rem;}
th{
    position:sticky; top:0; background:#222; text-align:left; padding:0.7rem 1rem; 
    color:var(--acc); font-weight:600; border-bottom:2px solid var(--border); z-index:2; 
    cursor: pointer;
}
th:hover { background: #2a2a2a; }

td{padding:0.5rem 1rem; border-bottom:1px solid #2a2a2a; font-family:'Consolas', monospace; transition: background 0.1s, color 0.1s;}
tr:hover td{background:#252525;}

/* Подсветка строки */
tr.playing td { background: #2c2c2c; color: #eee; }

/* Вспышка конкретной ячейки */
@keyframes pulse-cell {
    0% { color: #fff; text-shadow: 0 0 5px var(--acc); transform: scale(1); }
    50% { color: var(--acc); text-shadow: 0 0 15px var(--acc); transform: scale(1.15); }
    100% { color: var(--acc); text-shadow: none; transform: scale(1); }
}
td.active-pulse {
    animation: pulse-cell 0.3s ease-out forwards;
    font-weight: bold;
    color: var(--acc) !important;
}

/* Интерактивные ячейки */
td.clickable { cursor: pointer; }
td.clickable:hover { background: #333; color: var(--acc); }

.bar-ctn{width:80px; height:4px; background:#333; border-radius:2px; display:inline-block; margin-right:8px; vertical-align:middle; overflow: hidden;}
.bar-fill{height:100%; background:var(--acc); border-radius:2px; }
.desc-box{font-size:0.85rem; color:#bbb; padding:0.8rem; background:#1a1a1a; border-left: 3px solid var(--acc); border-radius:0 4px 4px 0; line-height: 1.4;}
.val-disp { float: right; color: var(--acc); font-weight: normal; }
.prime-inputs { display: flex; gap: 4px; height: 100%; width: 100%; }
.prime-inputs input { text-align: center; padding: 0; }
</style>
</head>
<body>

<!-- CONTROLS -->
<div class="controls no-select">
    <div class="col" style="grid-column: span 2;">
        <label>Metric Model</label>
        <div class="input-box">
            <select id="method">
                <option value="euler">Euler (Gradus Suavitatis)</option>
                <option value="murzin">Murzin (Periodicity)</option>
                <option value="sopfr">SOPFR (Sum of Primes)</option>
                <option value="barlow">Barlow (Indigestibility)</option>
                <option value="harmUtility">HarmUtility (Log Weighted Sum)</option>
            </select>
        </div>
    </div>
        
    <div class="col">
        <label>Max Denom</label>
        <div class="input-box"><input type="number" id="maxDenom" value="15"></div>
    </div>
    
    <!-- OCTAVE RANGE -->
    <div class="col">
        <label>Octaves Range <span id="octDisp" class="val-disp">0 : 1</span></label>
        <div class="input-box">
            <div class="range-wrap">
                <div class="range-bg"></div>
                <div class="range-fill" id="octFill"></div>
                <input type="range" id="octMin" min="-1" max="2" step="1" value="0">
                <input type="range" id="octMax" min="-1" max="2" step="1" value="1">
            </div>
        </div>
    </div>

    <!-- CONSONANCE SLIDER -->
    <div class="col">
        <label>Consonance (Min) <span id="consDisp" class="val-disp">0.22</span></label>
        <div class="input-box">
            <div class="range-wrap">
                <div class="range-bg"></div>
                <div class="range-fill" id="consFill" style="width: 42%"></div>
                <input type="range" id="consMin" min="0" max="1" step="0.01" value="0.22">
            </div>
        </div>
    </div>

    <div class="col">
        <label>Limits (3/5/7/Big)</label>
        <div class="input-box">
            <div class="prime-inputs">
                <input type="text" id="l3" value="4">
                <input type="text" id="l5" value="2">
                <input type="text" id="l7" value="1">
                <input type="text" id="lBig" value="1" title="Max count of primes > 7">
            </div>
        </div>
    </div>
</div>

<div class="desc-box" id="desc"></div>

<div class="table-wrap">
    <table id="tbl" class="no-select">
        <thead><tr>
            <th onclick="setSort('ratio')">Ratio (JI)</th>
            <th onclick="setSort('cents')">Cents</th>
            <th onclick="setSort('step')" title="12-TET Semitones">Semitones</th>
            <th>Factors</th>
            <th onclick="setSort('score')">Consonance</th>
            <th onclick="setSort('raw')">Raw Value</th>
        </tr></thead>
        <tbody></tbody>
    </table>
</div>

<script src="lib/audio-lib.js"></script>
<script src="lib/ji-lib.js"></script>
<script>

if(typeof Synth === 'undefined'){
    window.Synth = class { constructor(){ console.warn('Synth lib missing'); } connect(){} triggerAttackRelease(){} }
}

const ctx = Utils.initAudio();

const PIANO = {
  harmonics: 16,
  envelope: { attack: 0.005, decay: 0.4, sustain: 0.2, release: 0.8 }
};

const pianoPartials = (freq) => 
  Array.from({ length: PIANO.harmonics }, (_, i) => {
    const n = i + 1;
    const oddBoost = (n % 2 === 1) ? 1.2 : 0.8;
    const gain = oddBoost / Math.pow(n, 1.8); 
    return {
      ratio: n,
      amp: gain,
      startDelay: 0,
      attack: PIANO.envelope.attack,
      decay: PIANO.envelope.decay + (n * 0.05),
      sustain: Math.max(PIANO.envelope.sustain - (n * 0.02), 0.1),
      release: PIANO.envelope.release
    };
  });

const synth = new Synth(ctx, {
  partials: pianoPartials,
  type: 'sine'
});
synth.connect(ctx.destination);

function playInterval(n, d, duration = 0.5) {
  if (ctx.state === 'suspended') ctx.resume();
  const baseFreq = 220;
  const ratio = n / d;
  const intervalFreq = baseFreq * ratio;
  
  // Если интервал уходит сильно вниз (например 1/2), поднимаем базовую ноту
  let octaveShift = 0;
  if (ratio < 0.5) octaveShift = 1;
  // Если сильно вверх
  if (ratio > 4) octaveShift = -1;

  const f1 = baseFreq * Math.pow(2, octaveShift);
  const f2 = intervalFreq * Math.pow(2, octaveShift);

  synth.triggerAttackRelease('voice_root', f1, duration, 0.4);
  synth.triggerAttackRelease('voice_interval', f2, duration, 0.4);
}

// Обертка для визуала и вызова аудио
function handlePlay(n, d, cell) {
    // Сброс подсветки
    document.querySelectorAll('tr.playing').forEach(tr=>tr.classList.remove('playing'));
    document.querySelectorAll('td.active-pulse').forEach(td=>td.classList.remove('active-pulse'));
    
    // Новая подсветка
    cell.parentElement.classList.add('playing');
    cell.classList.add('active-pulse');

    // Звук
    playInterval(n, d);
}


/* --- APP STATE --- */
const $ = id => document.getElementById(id);
let currentData = [];
let currentSort = 'score'; 

function setSort(type){
    currentSort = type;
    render(false);
}

function render(recalc = true){
    const mKey = $('method').value;
    
    if(recalc){
        const method = Methods[mKey];
        const maxD = parseInt($('maxDenom').value);
        
        // Octave Slider Logic
        let oMin = parseInt($('octMin').value);
        let oMax = parseInt($('octMax').value);
        if(oMin > oMax) { 
            if(document.activeElement === $('octMin')) { oMax = oMin; $('octMax').value = oMax; }
            else { oMin = oMax; $('octMin').value = oMin; }
        }
        $('octDisp').innerText = `${oMin} : ${oMax}`;

        const minVal = -1, maxVal = 2;
        const total = maxVal - minVal;
        const left = ((oMin - minVal) / total) * 100;
        const width = (((oMax - minVal) / total) * 100) - left;
        const fill = document.getElementById('octFill');
        if(fill) { fill.style.left = left + '%'; fill.style.width = width + '%'; }

        // Consonance Slider
        const consSlider = $('consMin');
        const sliderVal = parseFloat(consSlider.value);
        const consThreshold = Math.pow(sliderVal, 2);
        $('consDisp').innerText = consThreshold.toFixed(3);

        const consFill = $('consFill');
        if(consFill) { consFill.style.width = (sliderVal * 100) + '%'; }

        const l3=$('l3').value, l5=$('l5').value, l7=$('l7').value, lBig=$('lBig').value;

        $('desc').innerHTML = method.desc;
        currentData = [];
        let seen = new Set();

        for(let d=1; d<=maxD; d++){
            let minN = Math.ceil(d * Math.pow(2, oMin));
            let maxN = Math.floor(d * Math.pow(2, oMax));

            for(let n=minN; n<=maxN; n++){
                let g = jiLib.gcd(n,d);
                let sn=n/g, sd=d/g;
                let key = sn+'/'+sd;
                
                if(seen.has(key)) continue; seen.add(key);

                let fn=jiLib.primeFactors(sn), fd=jiLib.primeFactors(sd);
                let c3=0,c5=0,c7=0,cBig=0;
                [fn,fd].forEach(o=>{ for(let k in o){
                    let p=Number(k), c=o[k];
                    if(p===3)c3+=c; else if(p===5)c5+=c; else if(p===7)c7+=c; else if(p>7)cBig+=c;
                }});
                if(c3>l3 || c5>l5 || c7>l7 || cBig>lBig) continue;

                let raw = method.calc(sn, sd); 
                let ratioVal = sn/sd;
                let cents = 1200 * Math.log2(ratioVal);
                let step = jiLib.toSemitones(sn, sd); // Используем новую логику

                currentData.push({n:sn, d:sd, key, cents, step, raw, ratioVal});
            }
        }

        // Normalize Score
        let min = Infinity, max = -Infinity;
        currentData.forEach(i => { if(i.raw<min)min=i.raw; if(i.raw>max)max=i.raw; });
        if(Math.abs(max-min)<1e-9) max=min+1;

        currentData.forEach(i => {
            i.score = i.raw; 
            i.normScore = (i.raw - min) / (max - min); 
        });

        // Filter
        currentData = currentData.filter(i => i.normScore >= consThreshold);
    }

    // Sorting
    if(currentSort === 'score') currentData.sort((a,b) => b.score - a.score);
    else if(currentSort === 'raw') currentData.sort((a,b) => b.raw - a.raw); 
    else if(currentSort === 'cents') currentData.sort((a,b) => a.cents - b.cents);
    else if(currentSort === 'step') currentData.sort((a,b) => a.step - b.step || a.cents - b.cents);
    else if(currentSort === 'ratio') currentData.sort((a,b) => a.ratioVal - b.ratioVal);

    // Render HTML
    const tbody = $('tbl').querySelector('tbody');
    let html = '';
    const displaySet = currentData.slice(0, 300);

    if(displaySet.length === 0) {
        html = '<tr><td colspan="6" style="text-align:center; padding:2rem; color:#666">No intervals match current filters</td></tr>';
    } else {
        displaySet.forEach(i => {
            let factors = (x) => {
                let f = jiLib.primeFactors(x);
                return Object.keys(f).map(k => f[k]>1 ? k+'<sup>'+f[k]+'</sup>' : k).join('.');
            };
            let hue = i.normScore * 120; 
            
            // JI клик: передаем натуральную дробь
            const jiClick = `onclick="handlePlay(${i.n}, ${i.d}, this)" class="clickable"`;
            
            // TET клик: передаем искусственно созданную дробь (2^(step/12) / 1)
            const tetRatio = Math.pow(2, i.step/12);
            const tetClick = `onclick="handlePlay(${tetRatio}, 1, this)" class="clickable"`;
            
            const noClick = `style="color:#888"`;

            html += `<tr>
                <td ${jiClick}><b>${i.key}</b></td>
                <td ${jiClick}>${i.cents.toFixed(1)}</td>
                <td ${tetClick}>${i.step}</td>
                <td ${noClick} style="font-size:0.8em">${factors(i.n)}:${factors(i.d)}</td>
                <td ${noClick}>
                    <div class="bar-ctn"><div class="bar-fill" style="width:${i.normScore*100}%; background:hsl(${hue},70%,50%)"></div></div> 
                    ${i.score.toFixed(3)}
                </td>
                <td ${noClick} style="color:#666; font-size:0.8em">${i.raw.toFixed(4)}</td>
            </tr>`;
        });
    }
    tbody.innerHTML = html;
}

document.querySelectorAll('input, select').forEach(e => e.addEventListener('input', ()=>render(true)));
render(true);
</script>
</body>
</html>
```

## 5_urmavi_scales.html

```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Генератор Ладов JI</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&family=Space+Grotesk:wght@300;400;500;600;700&display=swap" rel="stylesheet">

<style>
:root {
  --bg-void: hsl(225, 21.5%, 5%);
  --bg-panel: hsl(225, 24%, 8%);
  
  --color-cyan: hsla(190, 90%, 62.5%, 1);
  --color-purple: hsla(260, 85%, 67.5%, 1);
  --color-warm: hsla(35, 100%, 67.5%, 1);
  
  --text-bright: hsl(0, 0%, 100%);
  --text-main: hsl(220, 28.5%, 91%);
  --text-dim: hsl(223, 18.5%, 69%);
  
  --radius-sm: 4px;
  --radius-md: 8px;
  
  --ease-out: cubic-bezier(0.2, 0.8, 0.2, 1);
  
  --shadow-input: inset 0 2px 4px hsla(0, 0%, 0%, 0.45);
  --border-base: 1px solid hsla(0, 0%, 100%, 0.065);
  
  --glow-cyan-inner: inset 0 0 0 1px hsla(190, 80%, 65%, 0.35), inset -1px -3px 20px hsla(190, 80%, 62.5%, 0.1);
  --glow-purple-inner: inset 0 0 0 1px hsla(260, 80%, 65%, 0.35), inset -1px -3px 20px hsla(260, 80%, 67.5%, 0.1);

  --scrollbar-track: var(--bg-void);
  --scrollbar-thumb: hsla(0, 0%, 100%, 0.15);
}

* { box-sizing: border-box; outline: none; -webkit-tap-highlight-color: transparent; }

html, body {
  margin: 0; padding: 0;
  height: 100%; width: 100%;
  overflow: hidden;
}

body {
  background-color: var(--bg-void);
  background-image: radial-gradient(circle at 50% -20%, hsl(225, 25%, 12%) 0%, var(--bg-void) 70%);
  color: var(--text-main);
  font-family: 'Space Grotesk', sans-serif;
  
  display: grid;
  grid-template-rows: 1fr auto;
}

/* === SCROLLBARS === */
::-webkit-scrollbar { width: 5px; height: 5px; }
::-webkit-scrollbar-track { background: var(--scrollbar-track); }
::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px; }

/* === VISUALIZATION === */
#visualization-panel {
  position: relative; 
  width: 100%; 
  height: 100%;
  min-height: 80px;
  overflow: hidden;
  background: radial-gradient(circle at center, hsla(225, 25%, 10%, 0.5) 0%, transparent 80%);
}
#visualization-panel canvas { width: 100%; height: 100%; display: block; }

/* === CONTROL PANEL === */
#control-panel {
  background: var(--bg-panel);
  border-top: var(--border-base);
  box-shadow: 0 -10px 30px rgba(0,0,0,0.5);
  
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 12px;
  padding: 12px;
  
  height: 42vh;
  min-height: 200px;
  max-height: 350px;
}

/* === TABLE (FIXED LAYOUT - NO HORIZONTAL SCROLL) === */
.scales-table-container {
  background: hsla(0, 0%, 0%, 0.2);
  border: var(--border-base);
  border-radius: var(--radius-md);
  overflow: hidden; /* Vertical scroll only via tbody */
  min-width: 0;
  display: flex;
  flex-direction: column;
}

.scales-table {
  width: 100%; 
  table-layout: fixed; /* Ключ: фиксированная ширина колонок */
  border-collapse: collapse;
  font-family: 'JetBrains Mono', monospace; 
  font-size: clamp(9px, 1.3vh, 12px);
}

/* Фиксированные пропорции колонок */
.scales-table th:nth-child(1),
.scales-table td:nth-child(1) { width: 7%; }  /* N */

.scales-table th:nth-child(2),
.scales-table td:nth-child(2) { width: 13%; } /* Конс */

.scales-table th:nth-child(3),
.scales-table td:nth-child(3) { width: 28%; } /* Название */

.scales-table th:nth-child(4),
.scales-table td:nth-child(4) { width: 52%; } /* Состав */

.scales-table thead {
  display: table;
  width: 100%;
  table-layout: fixed;
}

.scales-table tbody {
  display: block;
  overflow-y: auto;
  max-height: calc(42vh - 60px); /* Высота панели минус header и padding */
}

.scales-table tbody tr {
  display: table;
  width: 100%;
  table-layout: fixed;
}

.scales-table th {
  background: var(--bg-panel);
  color: var(--text-dim); 
  font-size: clamp(7px, 1vh, 10px); 
  text-transform: uppercase; 
  letter-spacing: 0.3px;
  padding: clamp(5px, 1vh, 8px) clamp(4px, 0.6vh, 6px);
  text-align: left;
  border-bottom: 1px solid hsla(0, 0%, 100%, 0.1);
  cursor: pointer;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.scales-table th:hover { color: var(--text-bright); }

.scales-table td {
  padding: clamp(4px, 0.7vh, 7px) clamp(4px, 0.6vh, 6px);
  border-bottom: 1px solid hsla(0, 0%, 100%, 0.03);
  color: var(--text-main);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.scales-table tr:hover td { background: hsla(0, 0%, 100%, 0.03); color: var(--text-bright); }
.scales-table tr.selected td {
  background: hsla(260, 85%, 67.5%, 0.1);
  color: var(--color-purple);
}
.scales-table td.consonance { color: var(--color-cyan); }

/* === CONFIG PANEL === */
#generation-parameters {
  width: clamp(200px, 26vh, 300px);
  
  display: flex; 
  flex-direction: column;
  gap: clamp(6px, 1.2vh, 10px);
  overflow-y: auto;
  overflow-x: hidden;
}

.panel-header {
  font-size: clamp(8px, 1.2vh, 10px);
  text-transform: uppercase; 
  color: var(--text-dim);
  font-weight: 600; 
  letter-spacing: 0.8px;
  padding-bottom: clamp(4px, 0.7vh, 6px);
  border-bottom: var(--border-base);
  flex-shrink: 0;
}

.param-group {
  display: flex; 
  flex-direction: column; 
  gap: clamp(4px, 0.8vh, 7px);
  padding: clamp(6px, 1vh, 10px);
  background: hsla(0,0,0,0.15); 
  border-radius: var(--radius-md); 
  border: var(--border-base);
  flex-shrink: 0;
}

.param-row {
  display: flex; 
  justify-content: space-between; 
  align-items: center;
  gap: 6px;
}

.param-row label {
  font-size: clamp(9px, 1.2vh, 12px);
  color: var(--text-dim);
  white-space: nowrap;
  flex-shrink: 0;
}

/* === INPUTS === */
input[type="number"] {
  background-color: hsla(0, 0%, 0%, 0.25);
  border: var(--border-base); 
  border-radius: var(--radius-sm);
  color: var(--text-bright); 
  font-family: 'JetBrains Mono', monospace;
  text-align: center; 
  padding: clamp(3px, 0.6vh, 6px) 2px;
  width: clamp(45px, 45%, 70px);
  box-shadow: var(--shadow-input); 
  font-size: clamp(10px, 1.2vh, 13px);
  transition: all 0.2s;
}
input[type="number"]:focus { border-color: transparent; }

.group-cyan input:focus { box-shadow: var(--glow-cyan-inner); }
.group-cyan input:hover { border-color: hsla(190, 90%, 62.5%, 0.3); }

.group-purple input:focus { box-shadow: var(--glow-purple-inner); }
.group-purple input:hover { border-color: hsla(260, 85%, 67.5%, 0.3); }

/* === CUSTOM SELECT === */
.select-group {
  flex-shrink: 0;
}
.select-group > label {
  font-size: clamp(7px, 1vh, 9px);
  color: var(--text-dim); 
  display: block;
  margin-bottom: clamp(2px, 0.4vh, 4px);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.custom-select { 
  position: relative; 
  font-family: 'Space Grotesk', sans-serif; 
}

.select-trigger {
  background: hsla(0, 0%, 0%, 0.25);
  color: var(--text-main); 
  padding: clamp(6px, 1vh, 10px) clamp(8px, 1.2vh, 12px);
  border-radius: var(--radius-md); 
  cursor: pointer;
  display: flex; 
  justify-content: space-between; 
  align-items: center;
  border: var(--border-base); 
  box-shadow: var(--shadow-input);
  font-size: clamp(9px, 1.1vh, 12px);
  font-weight: 500; 
  transition: border-color 0.2s;
}
.select-trigger:hover { border-color: hsla(0, 0%, 100%, 0.15); }

.custom-select.open .select-trigger {
  background-color: hsla(260, 75%, 50%, 0.05);
  box-shadow: var(--glow-purple-inner); 
  border-color: transparent; 
  color: var(--text-bright);
}

.select-arrow { 
  font-size: clamp(7px, 0.9vh, 9px);
  color: var(--text-dim); 
  transition: transform 0.2s; 
}
.custom-select.open .select-arrow { 
  transform: rotate(180deg); 
  color: var(--color-purple); 
}

.select-options {
  position: absolute; 
  bottom: calc(100% + 4px); 
  left: 0; 
  right: 0;
  background: #0b0d12; 
  border: var(--border-base);
  border-radius: var(--radius-md); 
  overflow: hidden;
  max-height: 0; 
  opacity: 0; 
  z-index: 100;
  transition: all 0.2s var(--ease-out); 
  box-shadow: 0 -8px 25px rgba(0,0,0,0.8);
}
.custom-select.open .select-options { 
  max-height: 180px; 
  opacity: 1; 
}

.option {
  padding: clamp(7px, 1vh, 10px) clamp(8px, 1.2vh, 12px);
  cursor: pointer; 
  font-size: clamp(9px, 1.1vh, 11px);
  color: var(--text-dim);
  border-left: 2px solid transparent; 
  transition: all 0.15s;
}
.option:hover { 
  color: var(--text-bright); 
  background: hsla(0, 0%, 100%, 0.04); 
}
.option.selected {
  color: var(--text-bright); 
  border-left-color: var(--color-purple);
  background: linear-gradient(90deg, hsla(260, 85%, 67.5%, 0.08), transparent);
}

/* === BUTTON === */
#genScalesBtn {
  flex-shrink: 0;
  margin-top: auto;
  width: 100%; 
  padding: clamp(8px, 1.3vh, 12px);
  background: linear-gradient(180deg, hsl(225, 20%, 15%), hsl(225, 20%, 9%));
  border: 1px solid hsla(0, 0%, 100%, 0.08);
  border-radius: var(--radius-md);
  color: var(--text-main); 
  font-family: 'Space Grotesk', sans-serif; 
  font-weight: 600; 
  text-transform: uppercase; 
  letter-spacing: 0.8px; 
  font-size: clamp(8px, 1.1vh, 10px);
  cursor: pointer; 
  overflow: hidden; 
  transition: all 0.2s var(--ease-out); 
  position: relative;
  box-shadow: 0 3px 12px rgba(0,0,0,0.3);
}

#genScalesBtn:hover {
  border-color: hsla(0, 0%, 100%, 0.2);
  color: var(--text-bright);
  background: linear-gradient(180deg, hsl(225, 20%, 17%), hsl(225, 20%, 11%));
}

#genScalesBtn::after {
  content: ''; 
  position: absolute; 
  bottom: 0; left: 0; 
  width: 100%; height: 2px;
  background: var(--color-cyan); 
  transform: scaleX(0.5); 
  opacity: 0.6;
  transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
  box-shadow: 0 -1px 5px hsla(190, 90%, 62.5%, 0.2);
}
#genScalesBtn:hover::after { 
  transform: scaleX(1); opacity: 1; height: 2px; 
  box-shadow: 0 0 12px var(--color-cyan); 
}
#genScalesBtn:active { transform: translateY(1px); opacity: 0.9; }

/* === OVERLAY === */
#generation-overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(5, 7, 15, 0.85); backdrop-filter: blur(5px);
  display: none; align-items: center; justify-content: center;
  font-size: clamp(14px, 2.5vmin, 20px); 
  letter-spacing: 2px;
  color: var(--color-cyan); z-index: 1500;
  text-transform: uppercase;
}

/* ============================================
   PORTRAIT MODE
   ============================================ */
@media (max-aspect-ratio: 3/4) {
  #control-panel {
    grid-template-columns: 1fr;
    grid-template-rows: 1fr auto;
    gap: 8px;
    padding: 8px;
    
    height: 58vh;
    min-height: 260px;
    max-height: 480px;
  }
  
  .scales-table tbody {
    max-height: calc(35vh - 40px);
  }
  
  #generation-parameters {
    width: 100%;
    flex-direction: row;
    flex-wrap: wrap;
    gap: 6px;
    overflow: visible;
  }
  
  .panel-header {
    width: 100%;
    padding-bottom: 4px;
    margin-bottom: 2px;
  }
  
  .param-group {
    flex: 1 1 calc(50% - 3px);
    min-width: 120px;
    padding: 6px 8px;
    gap: 4px;
  }
  
  /* Имена ВСЕГДА на одной строке с инпутами */
  .param-row {
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
  }
  
  .param-row label {
    font-size: clamp(8px, 1.8vw, 11px);
  }
  
  .param-row input[type="number"] {
    width: clamp(40px, 35%, 60px);
    font-size: clamp(9px, 1.8vw, 12px);
    padding: 4px 2px;
  }
  
  .select-group {
    flex: 1 1 100%;
    order: 10;
  }
  
  .select-group > label {
    font-size: 8px;
  }
  
  .select-trigger {
    padding: 8px 10px;
    font-size: 10px;
  }
  
  #genScalesBtn {
    flex: 0 0 100%;
    order: 20;
    margin-top: 4px;
    padding: 10px;
    font-size: 9px;
  }
  
  .select-options {
    bottom: calc(100% + 3px);
  }
}

/* Очень узкий экран */
@media (max-aspect-ratio: 1/2) {
  #control-panel {
    height: 62vh;
    max-height: 520px;
  }
  
  .param-group {
    flex: 1 1 100%;
  }
  
  .scales-table tbody {
    max-height: calc(28vh - 30px);
  }
}
</style>
</head>
<body>

  <div id="generation-overlay">Идет расчет...</div>

  <div id="visualization-panel">
    <canvas id="myCanvas"></canvas>
  </div>

  <div id="control-panel">
    
    <div class="scales-table-container">
      <table class="scales-table">
        <thead>
          <tr>
            <th data-sort="N">N</th>
            <th data-sort="consonance">Конс.</th>
            <th data-sort="scalename">Название</th>
            <th data-sort="scale">Состав</th>
          </tr>
        </thead>
        <tbody id="scales-table-body"></tbody>
      </table>
    </div>

    <div id="generation-parameters">
      <div class="panel-header">Настройки</div>

      <div class="param-group group-cyan">
        <div class="param-row">
          <label for="minNotes">Мин. нот</label>
          <input type="number" id="minNotes" value="5" min="3" max="12">
        </div>
        <div class="param-row">
          <label for="maxNotes">Макс. нот</label>
          <input type="number" id="maxNotes" value="8" min="3" max="12">
        </div>
      </div>

      <div class="param-group group-purple">
        <div class="param-row">
          <label for="searchLimit">Глубина поиска</label>
          <input type="number" id="searchLimit" value="32" min="1" max="100">
        </div>
        <div class="param-row">
          <label for="minConsonance">Мин. конс.</label>
          <input type="number" id="minConsonance" step="0.01" value="0.2" min="0" max="1">
        </div>
      </div>

      <div class="select-group">
        <label>Метод</label>
        <div class="custom-select" id="methodSelect">
          <input type="hidden" id="consonanceMethod" value="murzin">
          <div class="select-trigger">
            <span class="trigger-text">Murzin</span>
            <span class="select-arrow">▼</span>
          </div>
          <div class="select-options">
            <div class="option selected" data-value="murzin">Murzin</div>
            <div class="option" data-value="euler">Euler</div>
            <div class="option" data-value="harmUtility">Harmonic Utility</div>
          </div>
        </div>
      </div>

      <button id="genScalesBtn">Генерировать</button>
    </div>
  </div>

  <script src="lib/ji-lib.js"></script>
  <script src="lib/generate_modes.js"></script>
  <script src="lib/audio-lib.js"></script>
  <script src="lib/additivepiano.js"></script>
  <script src="scales.js"></script>

  <script>
  function setupCustomSelect() {
    const sel = document.getElementById('methodSelect');
    const trigger = sel.querySelector('.select-trigger');
    const triggerText = sel.querySelector('.trigger-text');
    const input = document.getElementById('consonanceMethod');
    const options = sel.querySelectorAll('.option');

    trigger.addEventListener('click', e => {
      e.stopPropagation();
      sel.classList.toggle('open');
    });
    
    options.forEach(opt => {
      opt.addEventListener('click', e => {
        e.stopPropagation();
        options.forEach(o => o.classList.remove('selected'));
        opt.classList.add('selected');
        input.value = opt.dataset.value;
        triggerText.textContent = opt.textContent;
        sel.classList.remove('open');
      });
    });
    
    document.addEventListener('click', () => sel.classList.remove('open'));
  }

  let currentScale = null;
  let generatedScalesArray = [];
  let currentSortColumn = 'default';
  let currentSortOrder = 'desc';
  let headersAttached = false;

  // Для интерактивности
  let hitAreas = { notes: [], intervals: [] };
  let hoveredItem = null;
  let canvasRect = null;

  const canvas = document.getElementById("myCanvas");
  const context = canvas.getContext("2d");
  const overlay = document.getElementById("generation-overlay");

  const { RationalInterval } = window.jiLib || {};
  const { generateScales, flattenScales, generateScaleName, intervalConsonance } = window.ModeGenerator || {};

  function getSelectedMethod() {
    return document.getElementById('consonanceMethod').value || 'murzin';
  }

  function consonanceUsingSelectedMethod(r) {
    return intervalConsonance(r, getSelectedMethod());
  }

  class FractionLabel {
    constructor(n, d) { this.n = n; this.d = d; }
    draw(ctx, x, y, size) {
      ctx.save();
      ctx.font = `500 ${size}px 'JetBrains Mono'`;
      ctx.textAlign = "center";
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.fillText(this.n, x, y - size * 0.4);
      ctx.beginPath();
      ctx.moveTo(x - size * 0.4, y);
      ctx.lineTo(x + size * 0.4, y);
      ctx.strokeStyle = "rgba(255,255,255,0.4)";
      ctx.lineWidth = size * 0.08;
      ctx.stroke();
      ctx.fillText(this.d, x, y + size);
      ctx.restore();
    }
  }

  function getColorFromConsonance(cons) {
    const normalized = cons / 1.6;
    const hue = normalized * 60;
    const alpha = 0.3 + 0.7 * normalized;
    return `hsla(${hue}, 85%, 55%, ${alpha})`;
  }

  function getColorFromConsonanceHighlight(cons, highlight = false) {
    const normalized = cons / 1.6;
    const hue = normalized * 60;
    const alpha = highlight ? 1 : (0.3 + 0.7 * normalized);
    const lightness = highlight ? 65 : 55;
    return `hsla(${hue}, 85%, ${lightness}%, ${alpha})`;
  }

  function cubicBezierPoint(t, p0, p1, p2, p3) {
    const mt = (1 - t);
    return {
      x: mt * mt * mt * p0.x + 3 * mt * mt * t * p1.x + 3 * mt * t * t * p2.x + t * t * t * p3.x,
      y: mt * mt * mt * p0.y + 3 * mt * mt * t * p1.y + 3 * mt * t * t * p2.y + t * t * t * p3.y
    };
  }

  function pointNearCurve(mx, my, p0, p1, p2, p3, threshold = 12) {
    for (let t = 0; t <= 1; t += 0.02) {
      const pt = cubicBezierPoint(t, p0, p1, p2, p3);
      const dist = Math.hypot(mx - pt.x, my - pt.y);
      if (dist < threshold) return true;
    }
    return false;
  }

  function pointNearLabel(mx, my, x, y, size) {
    return Math.abs(mx - x) < size * 1.2 && Math.abs(my - y) < size * 1.8;
  }

  function drawScale(scale) {
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    canvasRect = rect;

    context.setTransform(1, 0, 0, 1, 0, 0);
    context.scale(dpr, dpr);

    const w = rect.width, h = rect.height;

    context.clearRect(0, 0, w, h);
    
    const u = Math.min(w, h);
    const marginX = w * 0.06;
    const axisY = h * 0.82;
    const plotHeight = h * 0.9;
    const fontSize = u * 0.035;
    const curveWidth = u * 0.006;
    
    context.beginPath();
    context.moveTo(0, axisY);
    context.lineTo(w, axisY);
    context.strokeStyle = "rgba(255,255,255,0.1)";
    context.stroke();

    // Очистка hit areas
    hitAreas = { notes: [], intervals: [] };

    if (!scale) return;

    function getX(ratio) {
      return marginX + (ratio.toDecimal() - 1) * (w - 2 * marginX);
    }

    scale.forEach((note, idx) => {
      const x = getX(note);
      context.beginPath();
      context.moveTo(x, axisY - u * 0.015);
      context.lineTo(x, axisY + u * 0.015);
      context.strokeStyle = "rgba(255,255,255,0.5)";
      context.lineWidth = 2;
      context.stroke();
      
      const labelY = axisY + fontSize * 1.8;
      const isHovered = hoveredItem && hoveredItem.type === 'note' && hoveredItem.index === idx;
      
      context.save();
      if (isHovered) {
        context.shadowColor = 'rgba(255,255,255,0.5)';
        context.shadowBlur = 10;
      }
      new FractionLabel(note.numerator, note.denominator).draw(context, x, labelY, fontSize * (isHovered ? 1.15 : 1));
      context.restore();
      
      // Сохраняем область для клика
      hitAreas.notes.push({
        x, y: labelY,
        size: fontSize,
        note,
        index: idx
      });
    });

    for (let i = 0; i < scale.length; i++) {
      for (let j = i + 1; j < scale.length; j++) {
        const xStart = getX(scale[i]), xEnd = getX(scale[j]);
        if (xEnd <= xStart) continue;
        
        const interval = scale[j].divide(scale[i]).normalize();
        const hArc = plotHeight * Math.log2(interval.toDecimal());
        
        const bend = 0.22;
        const p0 = { x: xStart, y: axisY };
        const p1 = { x: xStart + (xEnd - xStart) * bend, y: axisY - hArc };
        const p2 = { x: xEnd - (xEnd - xStart) * bend, y: axisY - hArc };
        const p3 = { x: xEnd, y: axisY };
        
        const intervalKey = `${i}-${j}`;
        const isHovered = hoveredItem && hoveredItem.type === 'interval' && hoveredItem.key === intervalKey;
        
        context.beginPath();
        context.moveTo(p0.x, p0.y);
        context.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
        context.lineCap = 'round';
        context.lineWidth = isHovered ? curveWidth * 1.8 : curveWidth;
        context.strokeStyle = getColorFromConsonanceHighlight(consonanceUsingSelectedMethod(interval), isHovered);
        
        if (isHovered) {
          context.shadowColor = context.strokeStyle;
          context.shadowBlur = 15;
        }
        context.stroke();
        context.shadowBlur = 0;

        const top = cubicBezierPoint(0.5, p0, p1, p2, p3);
        
        context.save();
        if (isHovered) {
          context.shadowColor = 'rgba(255,255,255,0.6)';
          context.shadowBlur = 12;
        }
        new FractionLabel(interval.numerator, interval.denominator)
          .draw(context, top.x, top.y - fontSize * 0.3, fontSize * (isHovered ? 1.05 : 0.9));
        context.restore();
        
        // Сохраняем область интервала
        hitAreas.intervals.push({
          p0, p1, p2, p3,
          labelX: top.x,
          labelY: top.y - fontSize * 0.3,
          size: fontSize * 0.9,
          noteA: scale[i],
          noteB: scale[j],
          interval,
          key: intervalKey
        });
      }
    }
  }

  // === ОБРАБОТКА СОБЫТИЙ МЫШИ ===
  
  function getMousePos(e) {
    if (!canvasRect) canvasRect = canvas.getBoundingClientRect();
    return {
      x: e.clientX - canvasRect.left,
      y: e.clientY - canvasRect.top
    };
  }

  function findHoveredItem(mx, my) {
    // Проверяем подписи нот
    for (const note of hitAreas.notes) {
      if (pointNearLabel(mx, my, note.x, note.y, note.size)) {
        return { type: 'note', ...note };
      }
    }
    
    // Проверяем интервалы (подписи + кривые)
    for (const int of hitAreas.intervals) {
      if (pointNearLabel(mx, my, int.labelX, int.labelY, int.size)) {
        return { type: 'interval', ...int };
      }
      if (pointNearCurve(mx, my, int.p0, int.p1, int.p2, int.p3, 10)) {
        return { type: 'interval', ...int };
      }
    }
    
    return null;
  }

  canvas.addEventListener('mousemove', (e) => {
    const pos = getMousePos(e);
    const item = findHoveredItem(pos.x, pos.y);
    
    const changed = (
      (!hoveredItem && item) ||
      (hoveredItem && !item) ||
      (hoveredItem && item && (hoveredItem.type !== item.type || hoveredItem.key !== item.key || hoveredItem.index !== item.index))
    );
    
    if (changed) {
      hoveredItem = item;
      canvas.style.cursor = item ? 'pointer' : 'default';
      if (currentScale) requestAnimationFrame(() => drawScale(currentScale));
    }
  });

  canvas.addEventListener('mouseleave', () => {
    if (hoveredItem) {
      hoveredItem = null;
      canvas.style.cursor = 'default';
      if (currentScale) requestAnimationFrame(() => drawScale(currentScale));
    }
  });

  canvas.addEventListener('click', (e) => {
    const pos = getMousePos(e);
    const item = findHoveredItem(pos.x, pos.y);
    
    if (!item) return;
    
    if (typeof PianoSynth !== 'undefined') {
      if (item.type === 'note') {
        PianoSynth.playNote(item.note);
      } else if (item.type === 'interval') {
        PianoSynth.playInterval(item.noteA, item.noteB);
      }
    }
    
    // Визуальный "пульс" при клике
    pulseItem(item);
  });

  function pulseItem(item) {
    // Простой эффект - временное усиление hover
    const originalHovered = hoveredItem;
    hoveredItem = item;
    if (currentScale) drawScale(currentScale);
    
    setTimeout(() => {
      hoveredItem = originalHovered;
      if (currentScale) drawScale(currentScale);
    }, 150);
  }

  function sortScales(scales) {
    let sorted = scales.slice();
    if (currentSortColumn === 'default') {
      sorted.sort((a, b) => b.consonance !== a.consonance ? b.consonance - a.consonance : a.n - b.n);
    } else {
      sorted.sort((a, b) => {
        let valA, valB;
        if (currentSortColumn === 'N') { valA = a.n; valB = b.n; }
        else if (currentSortColumn === 'consonance') { valA = a.consonance; valB = b.consonance; }
        else if (currentSortColumn === 'scalename') { valA = generateScaleName(a.scale); valB = generateScaleName(b.scale); }
        else { valA = a.scale.toString(); valB = b.scale.toString(); }
        if (valA < valB) return currentSortOrder === 'asc' ? -1 : 1;
        if (valA > valB) return currentSortOrder === 'asc' ? 1 : -1;
        return 0;
      });
    }
    return sorted;
  }

  function renderScalesTable() {
    const tableBody = document.getElementById("scales-table-body");
    tableBody.innerHTML = "";
    let sortedScales = sortScales(generatedScalesArray);
    
    sortedScales.forEach(entry => {
      const tr = document.createElement("tr");
      const tdN = document.createElement("td"); tdN.textContent = entry.n;
      const tdCons = document.createElement("td"); tdCons.textContent = entry.consonance.toFixed(3); tdCons.className = "consonance";
      const tdName = document.createElement("td"); tdName.textContent = generateScaleName(entry.scale);
      const tdScale = document.createElement("td"); tdScale.textContent = entry.scale.map(r => r.toString()).join(", ");

      tr.append(tdN, tdCons, tdName, tdScale);
      tr.addEventListener("click", () => {
        document.querySelectorAll(".scales-table tr").forEach(row => row.classList.remove("selected"));
        tr.classList.add("selected");
        currentScale = entry.scale;
        requestAnimationFrame(() => drawScale(currentScale));
      });
      tableBody.appendChild(tr);
    });
    
    if (tableBody.firstChild) {
      tableBody.firstChild.classList.add("selected");
      currentScale = sortedScales[0].scale;
      requestAnimationFrame(() => drawScale(currentScale));
    }
    
    if (!headersAttached) {
      document.querySelectorAll(".scales-table th").forEach(th => {
        th.addEventListener("click", () => {
          const key = th.dataset.sort;
          if (currentSortColumn === key) currentSortOrder = currentSortOrder === 'asc' ? 'desc' : 'asc';
          else { currentSortColumn = key; currentSortOrder = 'asc'; }
          renderScalesTable();
        });
      });
      headersAttached = true;
    }
  }

  document.getElementById("genScalesBtn").addEventListener("click", () => {
    overlay.style.display = "flex";
    setTimeout(async () => {
      try {
        const db = await generateScales({
          minNotes: +document.getElementById("minNotes").value,
          maxNotes: +document.getElementById("maxNotes").value,
          searchLimit: +document.getElementById("searchLimit").value,
          minConsonance: +document.getElementById("minConsonance").value,
          method: getSelectedMethod(),
          onProgress: c => overlay.textContent = `Расчет... [${c}]`
        });
        generatedScalesArray = flattenScales(db, +document.getElementById("minNotes").value);
        renderScalesTable();
      } catch(e) { console.error(e); } 
      finally { overlay.style.display = "none"; }
    }, 50);
  });

  window.addEventListener("resize", () => {
    if(currentScale) requestAnimationFrame(() => drawScale(currentScale));
  });
  
  window.addEventListener("load", () => {
    setupCustomSelect();
    document.getElementById("genScalesBtn").click();
  });
  </script>
</body>
</html>
```

## 6_circle_of_fifth.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Сircle of fifth</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap">
  <style>
    :root {
      --bg-color: hsl(231, 15%, 19%);
      --header-color: #ffffff;
      --canvas-bg-color: hsl(210, 8%, 12%);
      --button-bg-color: hsl(220, 87%, 80%);
      --button-hover-bg-color: hsl(220, 97%, 90%);
      --button-text-color: hsl(231, 15%, 19%);
      --text-color: hsl(60, 8%, 96%);
      --central-text-color: hsl(0, 0%, 100%);
      --active-sector-color: hsla(210, 84%, 75%, 0.2);
      --stroke-color: hsla(210, 84%, 75%, 0.5);
      --active-stroke-color: hsl(210, 84%, 75%);
      --sector-divider-color: hsl(231, 14%, 31%);
      --cents-text-color: hsl(0, 0%, 72%);
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: 'Roboto', sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      margin: 0;
      padding: 20px;
    }

    h1 {
      color: var(--header-color);
      font-size: 28px;
      font-weight: 200;
      text-align: center;
      margin-bottom: 20px;
      letter-spacing: 0.5px;
      text-transform: uppercase;
      font-family: 'Roboto', sans-serif;
      background: none;
      border: none;
      box-shadow: none;
      cursor: default;
    }

    .container {
      position: relative;
      width: 400px;
      height: 400px;
      margin-bottom: 30px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      border-radius: 50%;
    }

    canvas {
      background-color: var(--canvas-bg-color);
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    canvas:hover {
      transform: scale(1.03);
    }

    #centralText {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 42px;
      font-weight: bold;
      color: var(--central-text-color);
      text-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
      pointer-events: none;
      opacity: 0.9;
    }

    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }

    .controls button {
      background-color: var(--button-bg-color);
      color: var(--button-text-color);
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-family: 'Roboto', sans-serif;
    }

    .controls button:hover {
      background-color: var(--button-hover-bg-color);
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    /* Класс для текста центов был в стилях, но не использовался. Оставим его */
    .cents-text {
      font-size: 11px;
      color: var(--cents-text-color);
      margin-top: 2px;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <h1>Circle of fifth</h1>

  <div class="container">
    <canvas id="circleCanvas" width="400" height="400"></canvas>
    <div id="centralText"></div>
  </div>

  <div class="controls">
    <button id="equalTemperament">Equal Temperament</button>
    <button id="pythagoreanScale">Pythagorean Scale</button>
    <button id="justIntonation">Just Intonation</button>
  </div>
  <script src="lib/audio-lib.js"></script>

  <script>
    const ctx = Utils.initAudio();

    // Flute synthesis parameters
    const FLUTE = {
      harmonics: 12,
      vibrato: { rate: 5, depth: 0.001 },
      envelope: { attack: 0.15, decay: 0.25, sustain: 0.7, release: 0.6 }
    };

    // Generate additive synthesis partials with staggered envelopes
    const flutePartials = (freq) => 
      Array.from({ length: FLUTE.harmonics }, (_, i) => {
        const n = i + 1;
        const gain = (n % 2 === 0 ? 0.5 : 0.15) / (n * 1.2);
        
        return {
          ratio: n,
          amp: gain,
          startDelay: i * 0.005,
          attack: FLUTE.envelope.attack + i * 0.01,
          decay: FLUTE.envelope.decay,
          sustain: FLUTE.envelope.sustain,
          release: Math.max(FLUTE.envelope.release - i * 0.03, 0.1)
        };
      });

    // Create and connect synthesizer
    const synth = new Synth(ctx, {
      partials: flutePartials,
      vibrato: FLUTE.vibrato
    });
    synth.connect(ctx.destination);

    // Polyphonic note tracking
    const activeNotes = new Map(); // freq -> Set<noteId>
    let noteId = 0;

    function playNote(freq) {
      const id = noteId++;
      if (!activeNotes.has(freq)) activeNotes.set(freq, new Set());
      activeNotes.get(freq).add(id);
      synth.noteOn(id, freq);
    }

    function stopNote(freq) {
      const ids = activeNotes.get(freq);
      if (!ids?.size) return;
      
      const oldest = Math.min(...ids);
      synth.noteOff(oldest);
      ids.delete(oldest);
      if (!ids.size) activeNotes.delete(freq);
    }


    // ===== Класс для рациональных чисел (дополненный) =====
    class Rational {
      constructor(numerator, denominator = 1) {
        if (denominator === 0) {
          throw new Error("Denominator cannot be zero.");
        }
        // Обработка знака: знак хранится в числителе, знаменатель всегда положительный
        const sign = Math.sign(numerator) * Math.sign(denominator);
        this.numerator = Math.abs(numerator);
        this.denominator = Math.abs(denominator);
        if (sign < 0) {
            this.numerator = -this.numerator;
        }
        this.reduce();
      }

      reduce() {
        if (this.numerator === 0) {
            this.denominator = 1;
            return;
        }
        const commonDivisor = Rational.gcd(Math.abs(this.numerator), this.denominator);
        this.numerator /= commonDivisor;
        this.denominator /= commonDivisor;
      }

      toDecimal() {
        return this.numerator / this.denominator;
      }

      // Метод для вычисления абсолютных центов относительно 1/1
      toAbsoluteCents() {
        const decimal = this.toDecimal();
        if (decimal <= 0) return -Infinity; // Логарифм от неположительных чисел не определен
        const log2 = Math.log2 ? Math.log2 : (val) => Math.log(val) / Math.LN2; // Полифилл для log2
        return 1200 * log2(decimal);
      }

      // Представление в виде строки "num/den"
      toString() {
        return `${this.numerator}/${this.denominator}`;
      }

      // Умножение
      multiply(other) {
        return new Rational(this.numerator * other.numerator, this.denominator * other.denominator);
      }

      // Деление
      divide(other) {
        if (other.numerator === 0) {
          throw new Error("Division by zero (rational).");
        }
        return new Rational(this.numerator * other.denominator, this.denominator * other.numerator);
      }

      // Возведение в целую степень (включая отрицательные и 0)
      pow(exponent) {
          if (!Number.isInteger(exponent)) {
              throw new Error("Exponent must be an integer for Rational.pow");
          }
          if (exponent === 0) {
              return new Rational(1, 1); // Любое число в степени 0 равно 1
          }
          if (this.numerator === 0 && exponent < 0) {
               throw new Error("Cannot raise zero to a negative power.");
          }

          let resultNum, resultDen;
          if (exponent > 0) {
              resultNum = Math.pow(this.numerator, exponent);
              resultDen = Math.pow(this.denominator, exponent);
          } else { // exponent < 0
              // (a/b)^(-n) = (b/a)^n
               if (this.numerator === 0) throw new Error("Cannot raise zero to a negative power"); // Уже проверено, но для ясности
               // Меняем числитель и знаменатель местами (учитывая знак)
               const baseNum = this.denominator * Math.sign(this.numerator);
               const baseDen = Math.abs(this.numerator);

               resultNum = Math.pow(baseNum, -exponent);
               resultDen = Math.pow(baseDen, -exponent);
          }

         // Math.pow может давать неточные результаты для больших целых,
         // но для степеней 3 и 2 в пределах пифагорейского круга должно быть нормально.
         // Для супер-точности потребовалась бы библиотека BigInt или своя реализация возведения в степень.
          return new Rational(resultNum, resultDen);
      }


      // Нормализация: приведение дроби к диапазону [1, 2) умножением/делением на 2
      normalize() {
          let current = new Rational(this.numerator, this.denominator); // Создаем копию
          const two = new Rational(2, 1);
          if (current.toDecimal() <= 0) return current; // Не нормализуем ноль или отрицательные

          while (current.toDecimal() >= 2) {
              current = current.divide(two);
          }
          while (current.toDecimal() < 1) {
              current = current.multiply(two);
          }
          // Присваиваем нормализованные значения обратно this
          this.numerator = current.numerator;
          this.denominator = current.denominator;
          this.reduce(); // Убедимся, что дробь сокращена после нормализации
      }


      // НОД (Greatest Common Divisor) - Алгоритм Евклида
      static gcd(n, m) {
        // Работаем с абсолютными значениями
        n = Math.abs(n);
        m = Math.abs(m);
        while (m) {
            let temp = m;
            m = n % m;
            n = temp;
        }
        return n;
      }

       // НОК не нужен для текущей задачи, но оставим если потребуется
      static nok(n, m) {
        return (n * m) / Rational.gcd(n, m);
      }
    }

    // ===== Базовая частота =====
    const baseFrequency = 261.63; // C4

    // ===== Определение данных для нот =====
    class NoteData {
      constructor(definition) {
        this.definition = definition;
        this.name = '';
        this.frequency = 0;
        this.absoluteCents = 0; // Центы относительно 1/1
        this.centsDifference = 0; // Разница в центах с ET
        this.displayCents = ''; // Форматированная строка для отображения

        this._calculate();
      }

      _calculate() {
        const etSteps = [0, 7, 2, 9, 4, 11, 6, 1, 8, 3, 10, 5]; // Эталонные шаги ET для сравнения (порядок круга квинт)
        let ratioDecimal = 1.0;
        let ratio = null; // Объект Rational

        // --- Вычисляем имя, отношение (если применимо) и абсолютные центы ---
        try { // Обернем вычисления в try...catch для надежности
            if (this.definition.type === 'ET') {
              this.name = this.definition.name;
              ratioDecimal = Math.pow(2, this.definition.step / 12);
              this.absoluteCents = this.definition.step * 100;

            } else if (this.definition.type === 'Pythagorean') {
              const power = this.definition.power;
              ratio = new Rational(3, 2).pow(power);
              ratio.normalize(); // Приводим к базовой октаве [1, 2)
              this.name = ratio.toString();
              ratioDecimal = ratio.toDecimal();
              this.absoluteCents = ratio.toAbsoluteCents();

            } else if (this.definition.type === 'JI') {
              const ratioString = this.definition.ratioString;
              const parts = ratioString.split('/');
              if (parts.length !== 2) throw new Error(`Invalid JI ratio format: ${ratioString}`);
              const n = parseInt(parts[0], 10);
              const d = parseInt(parts[1], 10);
              if (isNaN(n) || isNaN(d) || d === 0) throw new Error(`Invalid numbers in JI ratio: ${ratioString}`);

              ratio = new Rational(n, d);
              // Предполагаем, что JI дроби уже нормализованы или их не нужно нормализовать для отображения
              this.name = ratio.toString();
              ratioDecimal = ratio.toDecimal();
              this.absoluteCents = ratio.toAbsoluteCents();
            }
         } catch (error) {
            console.error("Error calculating note data:", error, "Definition:", this.definition);
            this.name = "Error";
            this.frequency = baseFrequency; // Возвращаем базовую частоту при ошибке
            this.absoluteCents = 0;
            this.centsDifference = 0;
            this.displayCents = "Error";
            return; // Прерываем дальнейшие вычисления при ошибке
        }

        // --- Вычисляем частоту ---
        this.frequency = baseFrequency * ratioDecimal;

        // --- Вычисляем разницу с ET ---
        if (typeof this.definition.circleIndex === 'number' && this.definition.circleIndex >= 0 && this.definition.circleIndex < 12) {
            const etEquivalentStep = etSteps[this.definition.circleIndex];
            const etEquivalentCents = etEquivalentStep * 100;
            this.centsDifference = this.absoluteCents - etEquivalentCents;
        } else {
             console.warn("NoteData missing or invalid circleIndex. Cannot calculate precise centsDifference vs ET.", this.definition);
             // Как запасной вариант, считаем разницу до ближайшего полутона ET
             const closestEtCents = Math.round(this.absoluteCents / 100) * 100;
             this.centsDifference = this.absoluteCents - closestEtCents;
             // Или установить в NaN, если это значение не должно отображаться без индекса
             // this.centsDifference = NaN;
        }


        // --- Форматируем строку displayCents ---
        // Проверяем на NaN перед форматированием
        if (isNaN(this.centsDifference)) {
             this.displayCents = "N/A";
        } else {
            const roundedDiff = Math.round(this.centsDifference * 100) / 100;
            const sign = roundedDiff > 0 ? '+' : '';
            // Используем небольшую погрешность для сравнения с нулем
            this.displayCents = (Math.abs(roundedDiff) < 0.005)
                                ? '0.00 cents'
                                : `${sign}${roundedDiff.toFixed(2)} cents`;
         }
      }
    }

    // ===== Класс для представления строя (схемы) =====
    class Scheme {
      constructor(type) { // Принимает 'ET', 'Pythagorean', 'JI'
        this.type = type;
        this.notes = this._generateNotes(); // Массив объектов NoteData
      }

      _generateNotes() {
        const notesArray = [];
        // Определения нот в порядке круга квинт (C, G, D, A, E, B, F#, C#, G#, D#, A#, F)
        const etNoteNames = ['C', 'G', 'D', 'A', 'E', 'B', 'F♯', 'C♯', 'G♯', 'D♯', 'A♯', 'F'];
        const etSteps =      [0,   7,   2,   9,   4,  11,   6,    1,    8,    3,   10,   5]; // Шаги в полутонах от C
        const pythagoreanPowers = [0, 1, 2, 3, 4, 5, 6, -5, -4, -3, -2, -1]; // Степени для (3/2)^n
        const jiRatios = [ // Дроби для Just Intonation в том же порядке круга квинт
            '1/1',   // C
            '3/2',   // G
            '9/8',   // D (3/2)^2 нормализованное
            '5/3',   // A (Не пифагорейское, частый вариант JI) - было 27/16
            '5/4',   // E (Не пифагорейское, частый вариант JI) - было 81/64
            '15/8',  // B (5/4 * 3/2) - было 243/128
            '45/32', // F# (5/4 * 9/8) - было 729/512
            '16/15', // C# (Не пифагорейское, часто как обращение 15/8 или др.) - было 256/243 - !!! ВАЖНО: Твой исходный JI имел здесь 16/15
            '8/5',   // G# (Обращение 5/3?) - было 128/81 - !!! ВАЖНО: Твой исходный JI имел здесь 8/5
            '6/5',   // D# (Обращение 5/3?) - было 32/27 - !!! ВАЖНО: Твой исходный JI имел здесь 6/5
            '16/9',  // A# (Обращение 9/8 * 2) - было 16/9 (совпадает)
            '4/3'    // F (Обращение 3/2) - было 4/3 (совпадает)
            // --- Используем дроби из ТВОЕГО ИСХОДНОГО примера Just Intonation ---
         ];
        const originalJiRatios = ['1/1', '3/2', '9/8', '5/3', '5/4', '15/8', '45/32', '16/15', '8/5', '6/5', '16/9', '4/3'];


        for (let i = 0; i < 12; i++) {
          let definition = { circleIndex: i, type: this.type }; // Передаем индекс и тип

          if (this.type === 'ET') {
            definition.step = etSteps[i];
            definition.name = etNoteNames[i];
          } else if (this.type === 'Pythagorean') {
            definition.power = pythagoreanPowers[i];
            // Имя будет сгенерировано в NoteData как дробь
          } else if (this.type === 'JI') {
            definition.ratioString = originalJiRatios[i]; // Используем дроби из твоего исходного примера
             // Имя будет сгенерировано в NoteData как дробь
          }
          notesArray.push(new NoteData(definition));
        }
        return notesArray;
      }
    }

    // ===== Инициализация строев =====
    const schemes = [
      new Scheme('ET'),
      new Scheme('Pythagorean'),
      new Scheme('JI')
    ];

    // ===== Глобальные переменные для состояния =====
    let currentScheme = 0; // Индекс текущего строя в массиве schemes
    let selectedSector = null; // Индекс выделенного сектора (0-11)

    // ===== Получение элементов DOM =====
    const canvas = document.getElementById('circleCanvas');
    const ctxCanvas = canvas.getContext('2d');
    const centralText = document.getElementById('centralText');

    // ===== Параметры отрисовки =====
    const radius = canvas.width / 2;
    const innerRadius = radius * 0.66;
    const outerRadius = radius;
    const sectorAngle = (2 * Math.PI) / 12;

    // ===== Функция отрисовки круга =====
    function drawCircle() {
      const rootStyles = getComputedStyle(document.documentElement);
      const colors = {
        sectorDivider: rootStyles.getPropertyValue('--sector-divider-color').trim(),
        activeStroke: rootStyles.getPropertyValue('--active-stroke-color').trim(),
        stroke: rootStyles.getPropertyValue('--stroke-color').trim(),
        text: rootStyles.getPropertyValue('--text-color').trim(),
        cents: rootStyles.getPropertyValue('--cents-text-color').trim(),
        activeSector: rootStyles.getPropertyValue('--active-sector-color').trim()
      };

      ctxCanvas.clearRect(0, 0, canvas.width, canvas.height);

      // Получаем текущий активный строй
      const activeScheme = schemes[currentScheme];

      activeScheme.notes.forEach((note, i) => {
        const startAngle = i * sectorAngle - Math.PI / 2 - sectorAngle / 2;
        const endAngle = (i + 1) * sectorAngle - Math.PI / 2 - sectorAngle / 2;

        ctxCanvas.beginPath();
        ctxCanvas.arc(radius, radius, outerRadius, startAngle, endAngle);
        ctxCanvas.arc(radius, radius, innerRadius, endAngle, startAngle, true);
        ctxCanvas.closePath();
        ctxCanvas.fillStyle = i === selectedSector ? colors.activeSector : 'transparent';
        ctxCanvas.fill();
        ctxCanvas.strokeStyle = colors.sectorDivider;
        ctxCanvas.lineWidth = 1;
        ctxCanvas.stroke(); // Рисуем основной разделитель

        // Логика обводки как в оригинале
        if (selectedSector !== null) {
            // Сначала проверяем, нужно ли применить специальную обводку
             if (i === selectedSector) {
                ctxCanvas.strokeStyle = colors.activeStroke;
                ctxCanvas.lineWidth = 3;
                ctxCanvas.stroke(); // Рисуем активную обводку
             } else if (i === (selectedSector + 1) % 12 || i === (selectedSector + 11) % 12) {
                ctxCanvas.strokeStyle = colors.stroke;
                ctxCanvas.lineWidth = 2;
                ctxCanvas.stroke(); // Рисуем обводку соседей
             }
        }


        const textAngle = startAngle + sectorAngle / 2;
        const textRadius = (innerRadius + outerRadius) / 2;
        const x = radius + textRadius * Math.cos(textAngle);
        const y = radius + textRadius * Math.sin(textAngle);

        // Рисуем текст как в оригинале
        ctxCanvas.fillStyle = colors.text;
        ctxCanvas.font = '16px Roboto'; // Оригинальный шрифт/размер
        ctxCanvas.textAlign = 'center';
        ctxCanvas.textBaseline = 'bottom';
        ctxCanvas.fillText(note.name, x, y - 4); // Оригинальное смещение

        ctxCanvas.fillStyle = colors.cents;
        ctxCanvas.font = '11px Roboto'; // Оригинальный шрифт/размер
        ctxCanvas.textBaseline = 'top';
        ctxCanvas.fillText(note.displayCents, x, y + 4); // Используем displayCents и оригинальное смещение
      });
    }

    // ===== Функция определения сектора по координатам =====
    function getSector(x, y) {
      const dx = x - radius;
      const dy = y - radius;
      const distance = Math.sqrt(dx * dx + dy * dy);

      // Проверяем, попадает ли клик в кольцо
      if (distance < innerRadius || distance > outerRadius) return null;

      // Вычисляем угол и нормализуем его
      let angle = Math.atan2(dy, dx); // Угол в радианах от положительной оси X
      // Скорректируем угол, чтобы 0 радиан соответствовал верху круга (12 часов)
      // и учтем смещение секторов (первый сектор центрирован наверху)
      angle += Math.PI / 2 + sectorAngle / 2;

      // Нормализуем угол к диапазону [0, 2*PI)
      if (angle < 0) angle += 2 * Math.PI;
      if (angle >= 2 * Math.PI) angle -= 2 * Math.PI; // На всякий случай

      // Определяем индекс сектора
      return Math.floor(angle / sectorAngle) % 12;
    }

    // ===== Обработчик клика по канвасу =====
    canvas.addEventListener('click', (event) => {
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const sector = getSector(x, y);

      if (sector !== null) {
        // Если кликнули по тому же сектору, отменяем выбор
        if (selectedSector === sector) {
            selectedSector = null;
            centralText.textContent = ''; // Очищаем центральный текст
            drawCircle(); // Перерисовываем без выделения
            // Можно добавить остановку звука, если он еще звучит
        } else {
            selectedSector = sector;
            const selectedNote = schemes[currentScheme].notes[sector];
            centralText.textContent = selectedNote.name; // Показываем имя (ноту или дробь)
            drawCircle(); // Перерисовываем с выделением

            // Воспроизводим ноту
            const freq = selectedNote.frequency;
            playNote(freq);
            // Останавливаем через короткое время (как и было)
            setTimeout(() => {
              stopNote(freq);
            }, 450); // Чуть дольше, чтобы услышать атаку
        }
      } else {
        // Клик вне секторов - сбрасываем выделение
        selectedSector = null;
        centralText.textContent = '';
        drawCircle();
      }
    });

    // ===== Обработчики кнопок переключения строя =====
    document.getElementById('equalTemperament').addEventListener('click', () => {
      if (currentScheme !== 0) { // Переключаем только если не текущий
          currentScheme = 0;
          selectedSector = null; // Сбрасываем выделение при смене строя
          centralText.textContent = '';
          drawCircle();
      }
    });

    document.getElementById('pythagoreanScale').addEventListener('click', () => {
       if (currentScheme !== 1) {
           currentScheme = 1;
           selectedSector = null;
           centralText.textContent = '';
           drawCircle();
       }
    });

    document.getElementById('justIntonation').addEventListener('click', () => {
        if (currentScheme !== 2) {
            currentScheme = 2;
            selectedSector = null;
            centralText.textContent = '';
            drawCircle();
        }
    });

    // ===== Первичная отрисовка круга при загрузке =====
    drawCircle();

  </script>

</body>
</html>
```

## 7_tonnetz.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Tonnetz — Pure JS</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Space+Grotesk:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="./tonnetz/style.css">
</head>
<body>

    <div id="app">
        <!-- Audio Start Overlay -->
        <div id="start-overlay" class="start-overlay">
            <div class="start-btn">
                <h1>The Tonnetz</h1>
                <p>Click to Start Audio Engine</p>
            </div>
        </div>

        <div class="app-layout">
            <header class="app-header">
                <div class="app-title">Tonnetz Environment</div>
                <div class="header-controls">
                    <button id="btn-info" class="btn-icon">Info</button>
                </div>
            </header>

            <main>
                <div class="panel canvas-panel">
                    <!-- Pure SVG Container -->
                    <svg id="main-svg" viewBox="0 0 1000 600" style="width:100%; height:100%; touch-action:none; background: transparent; cursor: grab;">
                        <g id="svg-content" transform="scale(2) translate(0 0)"></g>
                    </svg>
                </div>

                <!-- Control Panel -->
                <div class="panel controls-panel">
                    <div class="tonnetz-selector">
                        <button id="btn-dual" class="btn-select btn-dual">
                            Rectangular Mode
                        </button>
                    </div>
                    
                    <div style="width:1px; background:var(--border-base); height: 24px;"></div>

                    <div class="control-group">
                        <span class="label">Status</span>
                        <div id="status-text" class="status-text">
                            No MIDI Device
                        </div>
                    </div>
                </div>
            </main>

            <!-- Info Modal -->
            <div id="info-overlay" class="info-overlay" style="display: none;">
                <div class="info-content panel">
                    <div class="info-body">
                        <h2 class="app-title" style="color:white; margin-bottom:1rem;">Information</h2>
                        <div id="info-text" style="color: var(--text-dim); text-align: justify; font-family: var(--font-ui); font-size: 14px;">
                            <!-- Content injected via JS -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- External Libs -->
    <script src="https://cdn.jsdelivr.net/npm/jzz@0.8.8/javascript/JZZ.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jzz-synth-tiny"></script>

    <!-- Application Modules (Ordered strictly for dependency) -->
    <script src="./tonnetz/js/1_utils.js"></script>
    <script src="./tonnetz/js/2_midi.js"></script>
    <script src="./tonnetz/js/3_strings.js"></script>
    <script src="./tonnetz/js/4_mixins.js"></script> <!-- Now GridLogic -->
    <script src="./tonnetz/js/5_components_primitives.js"></script> <!-- Now SvgBuilder -->
    <script src="./tonnetz/js/6_components_layout.js"></script> <!-- Now Renderer/Controller -->
    <script src="./tonnetz/js/7_app.js"></script>

</body>
</html>
```

## 8_ji_keyboard.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>JI Analyzer</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="style.css" />
</head>
<body>

<main class="app-compact">
  
  <!-- Controls Row -->
  <div class="controls-bar">
    <div class="control-group">
      <label class="control-label">Odd Limit</label>
      <input type="number" id="maxDenom" value="45" min="1" max="256" class="inp-small">
    </div>
    
    <div class="toggles-row">
      <label class="toggle-compact" title="Floating 1/1 center">
        <input type="checkbox" id="flagAutoTonic" checked>
        <span>Auto 1/1</span>
      </label>
      <label class="toggle-compact" title="Minimize Grid Cover">
        <input type="checkbox" id="flagLCM" checked>
        <span>LCM</span>
      </label>
      <label class="toggle-compact" title="Deep Fundamental">
        <input type="checkbox" id="flagGCD" checked>
        <span>GCD</span>
      </label>
    </div>
    
    <div class="slider-group">
      <label class="slider-label">
        GCD Weight: <span id="gcdWeightVal">1.5</span>
      </label>
      <input type="range" id="gcdWeight" min="0.5" max="3" step="0.1" value="1.5" class="slider-small">
    </div>
    
    <div class="slider-group">
      <label class="slider-label">
        Hysteresis: <span id="hysteresisVal">20%</span>
      </label>
      <input type="range" id="hysteresis" min="0" max="0.5" step="0.05" value="0.2" class="slider-small">
    </div>
  </div>

  <!-- Keyboard -->
  <div class="canvas-container">
    <canvas id="keyboard-canvas"></canvas>
  </div>

  <!-- Analysis Bar -->
  <div class="analysis-bar">
    <div class="analysis-item">
      <span class="analysis-label">Cover (LCM)</span>
      <span id="lcmValue" class="analysis-value">—</span>
    </div>
    <div class="analysis-item">
      <span class="analysis-label">Fundamental (GCD)</span>
      <span id="gcdValue" class="analysis-value">—</span>
      <span id="fundamentalInfo" class="analysis-hz"></span>
    </div>
    <div class="analysis-item interpretation-text">
      <pre id="playedNotes">Click keys or use MIDI</pre>
    </div>
  </div>

  <div class="footer-row">
    <button id="perfButton" class="btn-small">Benchmark</button>
    <span id="perfResult" class="perf-result"></span>
  </div>
  
</main>

<script src="ji-lib.js"></script>
<script src="keyboard.js"></script>
<script src="ji-interpretations.js"></script>
</body>
</html>
```

## applydiff_win.py

```python
#!/usr/bin/env python3
# applydiff_win.py — Windows-only минималистичный "patch" для unified diff
# Консольное приложение: можно просто вставить текст diff и завершить точкой на отдельной строке.
# Работает в папке, где лежит сам скрипт (root по умолчанию = каталог скрипта).
#
# Возможности:
# - Unified diff (---/+++; @@ хунки; + - ' ' строки)
# - Создание/удаление файлов через /dev/null
# - Сохранение стиля перевода строк; для новых файлов по умолчанию CRLF
# - Поддержка "\ No newline at end of file"
# - Игнорирование служебных строк git diff (diff --git, index, mode, rename ...)
# - Режимы игнорирования пробелов (--ignore-space-change, --ignore-whitespace)
# - Поиск позиции хунков с fuzz и окном поиска (--fuzz, --max-search)
#
# Использование (Windows):
#   1) Вставкой из буфера:
#        python applydiff_win.py
#        (вставьте unified diff)
#        затем введите на новой строке одиночную точку: .  и нажмите Enter
#        (или Ctrl+Z, затем Enter)
#   2) Из файла:
#        python applydiff_win.py change.diff -p 1
#   3) Через конвейер:
#        type change.diff | python applydiff_win.py --dry-run

import sys
import os
import argparse
import re
from typing import List, Tuple, Optional

HUNK_RE = re.compile(r"^@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@")

# Тип строки хунка: (op, text, has_newline)
HunkLine = Tuple[str, str, bool]

class Hunk:
    def __init__(self, ostart, ocnt, nstart, ncnt, lines: List[HunkLine]):
        self.ostart = int(ostart)
        self.ocnt = int(ocnt) if ocnt is not None else 1
        self.nstart = int(nstart)
        self.ncnt = int(ncnt) if ncnt is not None else 1
        self.lines = lines

class FilePatch:
    def __init__(self, src: Optional[str], dst: Optional[str]):
        self.src = src
        self.dst = dst
        self.hunks: List[Hunk] = []

    @property
    def is_delete(self):
        return (self.dst or '').strip() == '/dev/null'

    @property
    def is_create(self):
        return (self.src or '').strip() == '/dev/null'

SKIP_PREFIXES = (
    'diff --git', 'index ', 'new file mode', 'deleted file mode', 'old mode', 'new mode',
    'similarity index', 'rename from', 'rename to', 'copy from', 'copy to'
)


def normalize_path(raw: Optional[str], strip: Optional[int]) -> Optional[str]:
    if raw is None:
        return None
    raw = raw.strip()
    if raw == '/dev/null':
        return '/dev/null'
    if '\t' in raw:
        raw = raw.split('\t', 1)[0]
    path = raw
    if strip is None:
        if path.startswith('a/') or path.startswith('b/'):
            path = path.split('/', 1)[1]
    else:
        for _ in range(strip):
            if '/' in path:
                path = path.split('/', 1)[1]
            else:
                path = ''
                break
    return path


def parse_diff(text: str) -> List[FilePatch]:
    lines = text.splitlines(keepends=False)
    patches: List[FilePatch] = []
    i = 0
    current: Optional[FilePatch] = None
    while i < len(lines):
        line = lines[i]
        if line.startswith(SKIP_PREFIXES):
            i += 1
            continue
        if line.startswith('Binary files ') or line.startswith('GIT binary patch'):
            raise ValueError('Бинарные патчи не поддерживаются')
        if line.startswith('--- '):
            src = line[4:]
            i += 1
            while i < len(lines) and not lines[i].startswith('+++ '):
                if lines[i].startswith(SKIP_PREFIXES) or lines[i].strip() == '':
                    i += 1
                    continue
                break
            if i >= len(lines) or not lines[i].startswith('+++ '):
                raise ValueError('Повреждённый diff: отсутствует +++ после ---')
            dst = lines[i][4:]
            current = FilePatch(src, dst)
            patches.append(current)
            i += 1
            while i < len(lines):
                if lines[i].startswith('@@ '):
                    m = HUNK_RE.match(lines[i])
                    if not m:
                        raise ValueError(f'Повреждённый заголовок хунка: {lines[i]}')
                    ostart, ocnt, nstart, ncnt = m.groups()
                    i += 1
                    h_lines: List[HunkLine] = []
                    last_index = -1
                    while i < len(lines):
                        l = lines[i]
                        if l.startswith('@@ ') or l.startswith('--- '):
                            break
                        if l.startswith(' ') or l.startswith('+') or l.startswith('-'):
                            h_lines.append((l[0], l[1:], True))
                            last_index = len(h_lines) - 1
                        elif l.startswith('\\ No newline at end of file'):
                            if last_index >= 0:
                                op, txt, _ = h_lines[last_index]
                                h_lines[last_index] = (op, txt, False)
                        else:
                            h_lines.append((' ', l, True))
                            last_index = len(h_lines) - 1
                        i += 1
                    current.hunks.append(Hunk(ostart, ocnt, nstart, ncnt, h_lines))
                elif lines[i].startswith('diff ') or lines[i].startswith(SKIP_PREFIXES):
                    i += 1
                elif lines[i].startswith('--- '):
                    break
                else:
                    i += 1
        else:
            i += 1
    return patches


def detect_eol_from_lines(orig_lines: List[str]) -> Optional[str]:
    for s in orig_lines:
        if s.endswith('\r\n'):
            return '\r\n'
        if s.endswith('\n'):
            return '\n'
        if s.endswith('\r'):
            return '\r'
    return None


def choose_new_file_eol(policy: str) -> str:
    if policy == 'lf':
        return '\n'
    if policy == 'crlf':
        return '\r\n'
    if policy == 'cr':
        return '\r'
    return '\r\n'  # Windows по умолчанию


def split_content_and_nl(s: str):
    if s.endswith('\r\n'):
        return s[:-2], True
    if s.endswith('\n'):
        return s[:-1], True
    if s.endswith('\r'):
        return s[:-1], True
    return s, False

class CmpMode:
    NONE = 0
    SPACE_CHANGE = 1
    WHITESPACE = 2


def normalize_for_cmp(s: str, mode: int) -> str:
    s = s.replace('\r', '')
    if mode == CmpMode.NONE:
        return s
    if mode == CmpMode.WHITESPACE:
        return ''.join(ch for ch in s if not ch.isspace())
    out = []
    prev_space = False
    for ch in s:
        if ch.isspace():
            if not prev_space:
                out.append(' ')
                prev_space = True
        else:
            out.append(ch)
            prev_space = False
    return ''.join(out).strip()


def hunk_matches_at(orig_lines: List[str], start_idx: int, h_lines: List[HunkLine], cmp_mode: int):
    idx = start_idx
    for op, txt, _has_nl in h_lines:
        if op == '+':
            continue
        if idx >= len(orig_lines):
            return False, start_idx
        content, _ = split_content_and_nl(orig_lines[idx])
        if normalize_for_cmp(content, cmp_mode) != normalize_for_cmp(txt, cmp_mode):
            return False, start_idx
        idx += 1
    return True, idx


def reduce_hunk_lines(h_lines: List[HunkLine], drop_left_ctx: int, drop_right_ctx: int) -> List[HunkLine]:
    if drop_left_ctx == 0 and drop_right_ctx == 0:
        return h_lines
    ctx_idx = [i for i, (op, _, _) in enumerate(h_lines) if op == ' ']
    to_drop = set()
    for k in range(min(drop_left_ctx, len(ctx_idx))):
        to_drop.add(ctx_idx[k])
    for k in range(1, min(drop_right_ctx, len(ctx_idx)) + 1):
        to_drop.add(ctx_idx[-k])
    return [hl for j, hl in enumerate(h_lines) if j not in to_drop]


def apply_hunks_to_lines(orig_lines: List[str], hunks: List[Hunk], eol_new_file: str, cmp_mode: int, fuzz: int, max_search: Optional[int]) -> List[str]:
    out: List[str] = []
    in_pos = 0
    eol = detect_eol_from_lines(orig_lines) or eol_new_file

    for h in hunks:
        header_pos = max(h.ostart - 1, 0)
        variants = [(0, 0)]
        for f in range(1, max(0, fuzz) + 1):
            for dl in range(0, f + 1):
                dr = f - dl
                variants.append((dl, dr))

        placed = False
        chosen_start = None
        chosen_end_after = None
        chosen_lines: List[HunkLine] = []

        start_search = in_pos
        stop_search = len(orig_lines)
        if max_search is not None:
            start_search = max(in_pos, header_pos - max_search)
            stop_search = min(len(orig_lines), header_pos + max_search)

        for dl, dr in variants:
            reduced = reduce_hunk_lines(h.lines, dl, dr)
            candidates = []
            if header_pos >= start_search and header_pos <= stop_search:
                candidates.append(header_pos)
            for cand in range(start_search, stop_search + 1):
                if cand == header_pos:
                    continue
                candidates.append(cand)
            for cand in candidates:
                ok, end_after = hunk_matches_at(orig_lines, cand, reduced, cmp_mode)
                if ok and cand >= in_pos:
                    placed = True
                    chosen_start = cand
                    chosen_end_after = end_after
                    chosen_lines = reduced
                    break
            if placed:
                break

        if not placed:
            raise ValueError('Не удалось сопоставить хунк (контекст слишком изменился)')

        while in_pos < chosen_start:
            out.append(orig_lines[in_pos])
            in_pos += 1

        idx = in_pos
        for op, txt, has_nl in chosen_lines:
            if op == ' ':
                out.append(orig_lines[idx])
                idx += 1
            elif op == '-':
                idx += 1
            elif op == '+':
                out.append(txt + (eol if has_nl else ''))
            else:
                raise ValueError(f'Неизвестная операция хунка: {op}')
        in_pos = idx

    while in_pos < len(orig_lines):
        out.append(orig_lines[in_pos])
        in_pos += 1

    return out


def read_text_source(diff_path: Optional[str]) -> str:
    if diff_path:
        with open(diff_path, 'r', encoding='utf-8') as f:
            return f.read()
    # Интерактивный ввод: Windows-дружественно — завершаем точкой / EOF / END
    try:
        is_tty = sys.stdin.isatty()
    except Exception:
        is_tty = False
    if is_tty:
        print('Вставьте unified diff ниже. Для завершения введите на новой строке: .  (точка) и нажмите Enter.\nАльтернатива: Ctrl+Z, затем Enter.', file=sys.stderr)
        buf = []
        while True:
            try:
                line = input()
            except EOFError:
                break
            # Сентинелы завершения
            if line in ('.', 'EOF', 'END'):
                break
            buf.append(line + '\n')
        return ''.join(buf)
    # Не TTY — читаем как есть (pipe)
    return sys.stdin.read()


def main():
    if os.name != 'nt':
        print('Этот вариант утилиты рассчитан на Windows (os.name == "nt").', file=sys.stderr)
        return 2

    script_dir = os.path.dirname(os.path.abspath(sys.argv[0]))

    ap = argparse.ArgumentParser(description='Применить unified diff к файлам в папке (Windows, интерактивная вставка текста).')
    ap.add_argument('diff', nargs='?', help='Файл с diff. Если не задан, можно вставить текст вручную.')
    ap.add_argument('-p', '--strip', type=int, default=None, help='Отбросить N компонентов пути (как patch -pN). По умолчанию авто a/ b/.')
    ap.add_argument('--dry-run', action='store_true', help='Сухой прогон: только проверка применимости, без записи файлов.')
    ap.add_argument('--root', default=script_dir, help='Корень применения. По умолчанию: папка, где лежит скрипт.')
    ap.add_argument('--eol', choices=['auto', 'lf', 'crlf', 'cr'], default='crlf', help='Перевод строк для новых файлов (по умолчанию CRLF).')
    ap.add_argument('--ignore-space-change', action='store_true', help='Игнорировать различия в количестве пробелов.')
    ap.add_argument('--ignore-whitespace', action='store_true', help='Игнорировать пробелы полностью при сопоставлении.')
    ap.add_argument('--fuzz', type=int, default=2, help='Допустимый fuzz (отброс контекста) при поиске позиции хунка.')
    ap.add_argument('--max-search', type=int, default=None, help='Ограничить окно поиска позиции хунка (в строках).')

    args = ap.parse_args()

    text = read_text_source(args.diff)

    try:
        patches = parse_diff(text)
    except Exception as e:
        print(f'Ошибка разбора diff: {e}', file=sys.stderr)
        return 1

    if not patches:
        print('Патчи не найдены. Убедитесь, что вы вставили unified diff и завершили ввод точкой (.) или Ctrl+Z, Enter.', file=sys.stderr)
        return 1

    class CmpMode:
        NONE = 0
        SPACE_CHANGE = 1
        WHITESPACE = 2

    cmp_mode = CmpMode.NONE
    if args.ignore_whitespace:
        cmp_mode = CmpMode.WHITESPACE
    elif args.ignore_space_change:
        cmp_mode = CmpMode.SPACE_CHANGE

    failures = 0
    for fp in patches:
        src = normalize_path(fp.src, args.strip)
        dst = normalize_path(fp.dst, args.strip)

        if fp.is_delete:
            target = src
            op = 'delete'
        elif fp.is_create:
            target = dst
            op = 'create'
        else:
            target = dst
            op = 'modify'

        if not target:
            print('[-] Пропуск патча без применимого пути (возможно, /dev/null и слишком большой -p).')
            continue

        full_path = os.path.join(args.root, target)

        if op == 'delete':
            if not os.path.exists(full_path):
                print(f'[skip] {target}: уже отсутствует')
                continue
            if args.dry_run:
                print(f'[dry-run] будет удалён {target}')
            else:
                os.remove(full_path)
                print(f'[ok] удалён {target}')
            continue

        if os.path.exists(full_path):
            with open(full_path, 'r', encoding='utf-8', newline='') as f:
                orig_lines = f.read().splitlines(keepends=True)
        else:
            orig_lines = []
            if not args.dry_run:
                os.makedirs(os.path.dirname(full_path) or '.', exist_ok=True)

        try:
            new_lines = apply_hunks_to_lines(
                orig_lines,
                fp.hunks,
                eol_new_file=choose_new_file_eol(args.eol if args.eol != 'auto' else 'crlf'),
                cmp_mode=cmp_mode,
                fuzz=args.fuzz,
                max_search=args.max_search,
            )
        except Exception as e:
            failures += 1
            print(f'[fail] {target}: {e}', file=sys.stderr)
            continue

        if args.dry_run:
            print(f'[dry-run] будет записан {target} ({len(orig_lines)} → {len(new_lines)} строк)')
        else:
            with open(full_path, 'w', encoding='utf-8', newline='') as f:
                f.writelines(new_lines)
            print(f'[ok] {op} {target} ({len(orig_lines)} → {len(new_lines)} строк)')

    return 0 if failures == 0 else 1


if __name__ == '__main__':
    sys.exit(main())

```

## entropy_main.js

```javascript
// ============================================
// entropy_main.js - Harmonic Entropy App
// Uses audio-lib.js primitives directly
// ============================================

// ------------------ Audio State ------------------
let audioCtx = null;
let synths = [null, null];
let filters = [null, null];
let analysers = [null, null];
let reverbNode = null;

const baseFrequency = 440;
const audioParams = {
  type: "sawtooth",
  filterFrequency: 1000,
  filterType: "lowpass",
  attack: 0.05,
  release: 0.2,
  sustain: 0.5,
};

let noteIndicators = [
  { noteIndex: 0, x: null, opacity: 0 },
  { noteIndex: 1, x: 0, opacity: 0 },
];

let isMouseDown = false;
let tonicTimeout = null;

// ------------------ Chart State ------------------
let chartRenderer = null;
let entropyCalc = null;

// ------------------ Audio Functions ------------------
async function initAudio() {
  if (audioCtx) return;
  
  audioCtx = AudioLib.Utils.initAudio();
  
  // Reverb (shared)
  reverbNode = audioCtx.createConvolver();
  reverbNode.buffer = AudioLib.Utils.createImpulse(audioCtx, 1.0, 2.0);
  const reverbMix = audioCtx.createGain();
  reverbMix.gain.value = 0.3;
  reverbNode.connect(reverbMix);
  reverbMix.connect(audioCtx.destination);
  
  // Two independent synths
  for (let i = 0; i < 2; i++) {
    synths[i] = new AudioLib.Synth(audioCtx, {
      type: audioParams.type,
      envelope: {
        attack: audioParams.attack,
        release: audioParams.release,
      }
    });
    
    filters[i] = audioCtx.createBiquadFilter();
    filters[i].type = audioParams.filterType;
    filters[i].frequency.value = audioParams.filterFrequency;
    
    analysers[i] = audioCtx.createAnalyser();
    analysers[i].fftSize = 256;
    
    // Chain: Synth -> Filter -> Analyser -> Destination
    //                       \-> Reverb
    synths[i].connect(filters[i]);
    filters[i].connect(analysers[i]);
    filters[i].connect(reverbNode);
    analysers[i].connect(audioCtx.destination);
  }
}

function centsToFrequency(cents) {
  return AudioLib.Utils.centsToFrequency(cents, baseFrequency);
}

function playNote(noteIndex, frequency) {
  if (!synths[noteIndex]) return;
  synths[noteIndex].noteOn(0, frequency, audioParams.sustain);
}

function stopNote(noteIndex) {
  if (!synths[noteIndex] || !audioCtx) return;
  synths[noteIndex].noteOff(0, audioCtx.currentTime);
}

function setNoteFrequency(noteIndex, frequency) {
  if (!synths[noteIndex]) return;
  synths[noteIndex].setFrequency(0, frequency, 0.01);
}

function getAnalyserLevel(noteIndex) {
  const analyser = analysers[noteIndex];
  if (!analyser) return 0;
  
  const dataArray = new Uint8Array(analyser.frequencyBinCount);
  analyser.getByteTimeDomainData(dataArray);
  
  let level = 0;
  for (let i = 0; i < dataArray.length; i++) {
    level += Math.abs(dataArray[i] - 128);
  }
  level = dataArray.length > 0 ? level / dataArray.length : 0;
  return Math.min(1, Math.max(0, level / 40));
}

function updateVisualization() {
  let needsRedraw = false;
  
  for (let i = 0; i < 2; i++) {
    const newOpacity = getAnalyserLevel(i);
    if (Math.abs(noteIndicators[i].opacity - newOpacity) > 0.01) {
      noteIndicators[i].opacity = newOpacity;
      needsRedraw = true;
    }
  }
  
  if ((needsRedraw || isMouseDown) && chartRenderer) {
    chartRenderer.setNoteIndicators(noteIndicators);
    chartRenderer.requestDraw();
  }
  
  requestAnimationFrame(updateVisualization);
}

// ------------------ Entropy Helpers ------------------
function setStatus(msg) {
  const el = document.getElementById('status');
  if (el) el.textContent = msg;
}

function applyInversion(series, invert) {
  if (!Array.isArray(series) || !invert) return series;
  return series.map(p => ({ x: p.x, y: -p.y, label: p.label }));
}

// ------------------ Main ------------------
window.addEventListener("DOMContentLoaded", () => {
  const canvas = document.getElementById("heChart");
  chartRenderer = new ChartRenderer(canvas);
  
  if (typeof UnifiedEntropyCalculator !== 'undefined') {
    entropyCalc = new UnifiedEntropyCalculator();
  } else {
    console.error("UnifiedEntropyCalculator not found");
    return;
  }

  const invertCheckbox = document.getElementById('invertCheck');
  const modeSelect = document.getElementById('modeSelect');
  const HEPlotDiv = document.getElementById("HEPlotDiv");

  // ------------------ Plot Update ------------------
  async function updatePlot() {
    if (!entropyCalc) return;

    const N = parseInt(document.getElementById("textN").value) || 3000;
    const mincents = parseFloat(document.getElementById("textmin").value) * 1200;
    const maxcents = parseFloat(document.getElementById("textmax").value) * 1200;
    const sVal = parseFloat(document.getElementById("sliders").value);
    const aVal = parseFloat(document.getElementById("slidera").value);
    const mode = modeSelect.value;
    const invert = invertCheckbox.checked;

    setStatus('computing...');

    await entropyCalc.generateRatios({ N, method: mode });

    const curveRaw = entropyCalc.calculateCurve({
      mincents, maxcents, s: sVal, a: aVal, res: 0.5
    });

    const minima = entropyCalc.findExtrema(curveRaw, 0.001);
    const annotationsRaw = entropyCalc.annotateExtrema(minima, 15);

    const curve = applyInversion(curveRaw, invert);
    const annotations = applyInversion(annotationsRaw, invert);

    chartRenderer.plotHE(curve, annotations, invert);
    setStatus(`${mode}: ${curve.length} pts, ${entropyCalc.ratios.length} ratios`);
  }

  // ------------------ Mouse Interaction ------------------
  function getXValueFromEvent(event) {
    if (!chartRenderer?.currentView) return null;
    const rect = chartRenderer.canvas.getBoundingClientRect();
    const clickX = event.clientX - rect.left;
    const { paddingLeft, paddingRight } = chartRenderer.options;
    const graphWidth = rect.width - paddingLeft - paddingRight;
    if (graphWidth <= 0) return null;
    
    const normalizedX = Math.max(0, Math.min(1, (clickX - paddingLeft) / graphWidth));
    const { xMin, xMax } = chartRenderer.currentView;
    return xMin + normalizedX * (xMax - xMin);
  }

  HEPlotDiv.addEventListener("mousedown", async (event) => {
    if (event.button !== 0) return;
    
    await initAudio();
    
    const xValue = getXValueFromEvent(event);
    if (xValue === null) return;

    isMouseDown = true;
    document.body.classList.add("dragging");

    // Stop any playing notes
    stopNote(0);
    stopNote(1);
    if (tonicTimeout) {
      clearTimeout(tonicTimeout);
      tonicTimeout = null;
    }

    // Play note at cursor
    noteIndicators[0].x = xValue;
    noteIndicators[0].opacity = 1;
    playNote(0, centsToFrequency(xValue));

    // Reset tonic indicator
    noteIndicators[1].x = 0;
    noteIndicators[1].opacity = 0;

    // Schedule tonic with delay
    const delay = parseFloat(document.getElementById("noteDelay").value) * 1000;
    tonicTimeout = setTimeout(() => {
      playNote(1, baseFrequency);
      noteIndicators[1].opacity = 1;
      chartRenderer.requestDraw();
      tonicTimeout = null;
    }, delay);

    chartRenderer.setNoteIndicators(noteIndicators);
    chartRenderer.requestDraw();
  });

  document.addEventListener("mousemove", (event) => {
    if (!isMouseDown) return;
    
    const xValue = getXValueFromEvent(event);
    if (xValue === null) return;

    noteIndicators[0].x = xValue;
    setNoteFrequency(0, centsToFrequency(xValue));

    chartRenderer.setNoteIndicators(noteIndicators);
    chartRenderer.requestDraw();
  });

  document.addEventListener("mouseup", (event) => {
    if (event.button !== 0 || !isMouseDown) return;

    isMouseDown = false;
    document.body.classList.remove("dragging");

    stopNote(0);
    stopNote(1);

    if (tonicTimeout) {
      clearTimeout(tonicTimeout);
      tonicTimeout = null;
    }

    noteIndicators[0].x = null;
    noteIndicators[0].opacity = 0;
    noteIndicators[1].opacity = 0;

    chartRenderer.setNoteIndicators(noteIndicators);
    chartRenderer.requestDraw();
  });

  // ------------------ UI Controls ------------------
  modeSelect.addEventListener("change", updatePlot);
  invertCheckbox.addEventListener("change", updatePlot);

  document.getElementById("slidera").addEventListener("input", (e) => {
    document.getElementById("aval").textContent = `Bandwidth (a): ${parseFloat(e.target.value).toFixed(2)}`;
    updatePlot();
  });

  document.getElementById("sliders").addEventListener("input", (e) => {
    document.getElementById("sval").textContent = `Smoothing (s): ${parseFloat(e.target.value).toFixed(2)}%`;
    updatePlot();
  });

  document.getElementById("noteDelay").addEventListener("input", (e) => {
    document.getElementById("noteDelayLabel").textContent = `Note Delay: ${parseFloat(e.target.value).toFixed(2)}s`;
  });

  document.getElementById("textN").addEventListener("change", updatePlot);
  document.getElementById("textmin").addEventListener("change", updatePlot);
  document.getElementById("textmax").addEventListener("change", updatePlot);

  document.querySelectorAll(".stepper-button").forEach((btn) => {
    btn.addEventListener("click", function() {
      const input = document.getElementById(this.dataset.target);
      let val = parseInt(input.value) || 0;
      const step = parseInt(input.step) || 1;
      val += this.classList.contains("minus") ? -step : step;
      
      if (this.dataset.target === "textmin" || this.dataset.target === "textmax") {
        val = Math.max(-2, Math.min(5, val));
      } else if (this.dataset.target === "textN") {
        val = Math.max(10, val);
      }
      
      input.value = val;
      updatePlot();
    });
  });

  // ------------------ Init ------------------
  updatePlot();
  setTimeout(updateVisualization, 200);
});
```

## polyundertonality.js

```javascript
/**
 * polyundertonality.js v0.98
 * Corrected port from Julia. Stores absolute ratios, transforms on display.
 * Depends on: ji-lib.js (global.jiLib, global.Methods)
 */

(function(global) {
    'use strict';

    if (typeof jiLib === 'undefined') {
        throw new Error("polyundertonality.js requires ji-lib.js");
    }

    // ============================================
    // MATH UTILITIES
    // ============================================
    
    const Utils = {
        gcd(a, b) { return jiLib.gcd(a, b); },

        lcm(a, b) {
            if (a === 0 || b === 0) return 0;
            const g = this.gcd(Math.abs(a), Math.abs(b));
            // Correct LCM: |a*b|/gcd = |a|/gcd * |b|
            return Math.abs(a / g) * Math.abs(b);
        },

        arrayLcm(arr) {
            if (arr.length === 0) return 1;
            let res = arr[0];
            for (let i = 1; i < arr.length; i++) {
                res = this.lcm(res, arr[i]);
                if (res > Number.MAX_SAFE_INTEGER) return Number.MAX_SAFE_INTEGER;
            }
            return res;
        },

        // odd_part(n) = n >> trailing_zeros(n)
        oddPart(n) {
            n = Math.abs(Math.round(n));
            if (n === 0) return 0;
            while ((n & 1) === 0) n >>>= 1;
            return n;
        },

        // complex_euler(n) = 1 + sum(e*(p-1) for (p,e) in factor(odd_part(n)))
        complexEuler(n) {
            n = this.oddPart(n);
            if (n <= 1) return 1;
            const factors = jiLib.primeFactors(n);
            let sum = 0;
            for (const pStr in factors) {
                sum += factors[pStr] * (Number(pStr) - 1);
            }
            return 1 + sum;
        },

        // --- RATIO OPERATIONS (integer-preserving) ---
        
        create(num, den) {
            num = Math.round(num);
            den = Math.round(den);
            if (den === 0) return { num: 1, den: 1 };
            const g = this.gcd(Math.abs(num), Math.abs(den));
            const sign = (num * den < 0) ? -1 : 1;
            return { 
                num: sign * Math.abs(Math.round(num / g)), 
                den: Math.abs(Math.round(den / g)) 
            };
        },
        
        // normalize(x) = x * (1//2)^floor(log2(x)) → brings to [1, 2)
        // Uses integer multiplication to preserve exact fractions
        normalize(r) {
            let num = r.num;
            let den = r.den;
            if (num <= 0 || den <= 0) return this.create(1, 1);
            
            // Scale up: multiply num by 2 until num/den >= 1
            while (num < den) { num *= 2; }
            // Scale down: multiply den by 2 until num/den < 2
            while (num >= 2 * den) { den *= 2; }
            
            return this.create(num, den);
        },

        mul(a, b) { return this.create(a.num * b.num, a.den * b.den); },
        div(a, b) { return this.create(a.num * b.den, a.den * b.num); },
        
        // gcd(a/b, c/d) = gcd(a,c) / lcm(b,d)
        fractionGcd(r1, r2) {
            const num = this.gcd(r1.num, r2.num);
            const den = this.lcm(r1.den, r2.den);
            return this.create(num, den);
        },

        toDecimal(r) { return r.num / r.den; }
    };

    // ============================================
    // CORE LOGIC
    // ============================================

    const Logic = {
        
        // system_depth = lcm of odd_part(denominator) for all notes
        systemDepth(scales) {
            const denoms = new Set();
            for (const s of scales) {
                for (const r of s.scale) {
                    denoms.add(Utils.oddPart(r.den));
                }
            }
            if (denoms.size === 0) return 1;
            return Utils.arrayLcm(Array.from(denoms));
        },

        // system_root = reduce(gcd, (odd_rational(n) for all notes))
        // odd_rational(r) = odd_part(num) // odd_part(den)
        getSystemRoot(system) {
            if (!system || system.length === 0) return Utils.create(1, 1);
            
            let allOddNotes = [];
            for (const s of system) {
                for (const r of s.scale) {
                    allOddNotes.push(Utils.create(
                        Utils.oddPart(r.num),
                        Utils.oddPart(r.den)
                    ));
                }
            }

            if (allOddNotes.length === 0) return Utils.create(1, 1);

            // reduce(gcd, ...) - NOT lcm!
            let g = allOddNotes[0];
            for (let i = 1; i < allOddNotes.length; i++) {
                g = Utils.fractionGcd(g, allOddNotes[i]);
            }
            return g;
        },

        // cons_murzin(r) = 1/num + 1/den (for normalized ratio)
        computeConsonance(scale, method) {
            const n = scale.length;
            if (n < 2) return 1.0;
            
            let sum = 0, count = 0;
            const mKey = (method || 'murzin').toLowerCase();
            const calc = (global.Methods?.[mKey]?.calc) || global.Methods.murzin.calc;

            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    const interval = Utils.div(scale[i], scale[j]);
                    const norm = Utils.normalize(interval);
                    sum += calc(norm.num, norm.den);
                    count++;
                }
            }
            return count === 0 ? 0 : sum / count;
        },

        pruneSystem(scales, limit) {
            // Deep copy to avoid mutation
            let current = scales.map(s => ({ root: s.root, scale: s.scale.slice() }));
            let maxIter = 1000;

            while (maxIter-- > 0) {
                const depth = this.systemDepth(current);
                if (depth <= limit) return current;

                const denomsSet = new Set();
                current.forEach(s => {
                    s.scale.forEach(r => denomsSet.add(Utils.oddPart(r.den)));
                });
                
                const denoms = Array.from(denomsSet);
                if (denoms.length === 0) break;

                // Sort by badness: high complex_euler first, then high value
                denoms.sort((a, b) => {
                    const ca = Utils.complexEuler(a);
                    const cb = Utils.complexEuler(b);
                    return (ca !== cb) ? (cb - ca) : (b - a);
                });

                const victim = denoms[0];

                const pruned = current.map(s => ({
                    root: s.root,
                    scale: s.scale.filter(r => Utils.oddPart(r.den) !== victim)
                }));

                current = pruned.filter(s => s.scale.length >= 3);
                if (current.length === 0) break;
            }
            return current;
        },

        crystallize(scale, minCons, method) {
            let current = scale.slice();
            let iter = 0;
            
            while (iter++ < 50) {
                if (current.length <= 4) return current;
                if (this.computeConsonance(current, method) >= minCons) return current;

                let bestCand = null;
                let bestScore = -1;

                for (let i = 0; i < current.length; i++) {
                    const candidate = current.filter((_, x) => x !== i);
                    const score = this.computeConsonance(candidate, method);
                    if (score > bestScore) {
                        bestScore = score;
                        bestCand = candidate;
                    }
                }
                
                if (bestCand) current = bestCand;
                else break;
            }
            return current;
        },

        // normalize_scale(s) = sort!(unique!(normalize.(s)))
        normalizeScale(scaleArr) {
            const map = new Map();
            scaleArr.forEach(r => {
                const n = Utils.normalize(r);
                map.set(`${n.num}/${n.den}`, n);
            });
            return Array.from(map.values())
                .sort((a, b) => Utils.toDecimal(a) - Utils.toDecimal(b));
        },

        uniqueScale(scale) {
            const map = new Map();
            scale.forEach(r => map.set(`${r.num}/${r.den}`, r));
            return Array.from(map.values());
        },

        // Main generator - stores ABSOLUTE ratios (a/n), NO transformation
        generateSystem(limit, poolSize, minCons, consMethod) {
            // 1. Raw generation
            let raw = [];
            for (let a = 1; a <= poolSize; a++) {
                const scale = [];
                for (let n = 1; n <= poolSize; n++) {
                    scale.push(Utils.create(a, n));
                }
                raw.push({ root: a, scale });
            }

            // 2. Prune
            const pruned = this.pruneSystem(raw, limit);

            // 3. Crystallize
            // FIX: Заменили uniqueScale на normalizeScale.
            // Это приведет все дроби к диапазону [1, 2) и уберет дубликаты (2/1 станет 1/1).
            const result = pruned.map(s => ({
                root: s.root,
                scale: this.normalizeScale(this.crystallize(s.scale, minCons, consMethod))
            }));

            return result.filter(s => s.scale.length > 0);
        }
        // generateSystem(limit, poolSize, minCons, consMethod) {
        //     // 1. Raw: scale = [a/1, a/2, a/3, ... a/pool]
        //     let raw = [];
        //     for (let a = 1; a <= poolSize; a++) {
        //         const scale = [];
        //         for (let n = 1; n <= poolSize; n++) {
        //             scale.push(Utils.create(a, n));
        //         }
        //         raw.push({ root: a, scale });
        //     }

        //     // 2. Prune to meet depth limit
        //     const pruned = this.pruneSystem(raw, limit);

        //     // 3. Crystallize each scale, keep absolute values
        //     const result = pruned.map(s => ({
        //         root: s.root,
        //         scale: this.uniqueScale(this.crystallize(s.scale, minCons, consMethod))
        //     }));

        //     return result.filter(s => s.scale.length > 0);
        // }
    };

    // ============================================
    // PUBLIC API
    // ============================================
    
    global.PolyUndertonality = {
        generate: (limit, pool, minCons, method) => 
            Logic.generateSystem(limit, pool, minCons, method),
        getDepth: (system) => Logic.systemDepth(system),
        getSystemRoot: (system) => Logic.getSystemRoot(system),
        normalizeScale: (scale) => Logic.normalizeScale(scale),
        utils: Utils
    };

})(typeof window !== 'undefined' ? window : globalThis);
```

## scales.js

```javascript

window.scalesNamesMap = {
    "{0, 1, 2, 4, 5, 7, 9, 10, 11}":[
        "Chromatic Bebop"
    ],
    "{0, 1, 3, 5, 6, 7, 8, 11}":[
        "Bebop Half-Diminished"
    ],
    "{0, 2, 4, 7, 8, 9}":[
        "Mela Syamalangi",
        "Bebop Major Hexatonic",
        "Raga Ne Elangi"
    ],
    "{0, 2, 3, 4, 5, 7, 9, 10}":[
        "Bebop Minor"
    ],
    "{0, 11, 4, 7}":[
        "Major 7 Chord"
    ],
    "{0, 4, 7}":[
        "Major Triad"
    ],
    "{0, 1, 4, 5, 6, 8, 11}":[
        "Persian",
        "Chromatic Hypolydian Inverse"
    ],
    "{0, 2, 3, 6, 7, 8, 10}":[
        "Hungarian Gypsy"
    ],
    "{0, 2, 3, 5, 6, 8, 9, 11}":[
        "Diminished",
        "Messiaen 2nd mode From",
        "Messiaen 2 Groves",
        "Arabian 1",
        "Auxillary Diminished"
    ],
    "{0, 8, 4}":[
        "Raga Bilwadala",
        "Augmented Chord",
        "Messiaen 3rd Mode",
        "Chord aug (+5)",
        "Messiaen 3rd Mode & Aug",
        "Major Flat 6 (no fifth)"
    ],
    "{0, 3, 4, 5, 7, 10, 11}":[
        "Dorian Chromatic Inverse",
        "Chromatic Dorian Inverse",
        "Mela Chalanata"
    ],
    "{0, 3, 4, 5, 8, 9, 10}":[
        "Chrom. Hypodorian Inverse",
        "Chromatic Hypodorian Inv"
    ],
    "{0, 1, 4, 6, 7, 8, 11}":[
        "Mela Kamavardhani",
        "Chromatic Hypolydian, Pu",
        "Chromatic Hypolydian",
        "Theta Purvi"
    ],
    "{0, 1, 4, 5, 6, 9, 11}":[
        "Chromatic Lydian",
        "Lydian Chromatic"
    ],
    "{0, 9, 4, 7}":[
        "Chord dim7",
        "Diminished 7th Chord",
        "Chord M6",
        "Minor 7th e.g. Am7 = C6",
        "Messiaen 2nd Mode"
    ],
    "{0, 2, 4, 5, 7, 9, 10, 11}":[
        "Bebop Dominant"
    ],
    "{0, 1, 2, 5, 7, 8, 9}":[
        "Chromatic Dorian",
        "Mela Kanakangi",
        "Dorian Chromatic"
    ],
    "{0, 2, 3, 5, 7, 9, 10}":[
        "Dorian, Kafi D to C asc. n",
        "Dorian",
        "Theta Kafi",
        "Mela Kharaharapriya"
    ],
    "{0, 2, 4, 6, 7, 8, 11}":[
        "Mela Latangi",
        "Pelog"
    ],
    "{0, 2, 3, 4, 5, 7, 8, 9, 10}":[
        "Houseini (Greece)"
    ],
    "{0, 2, 3, 5, 6, 7, 8, 9, 10}":[
        "Kiourdi (Greece)"
    ],
    "{0, 2, 3, 4, 7, 8, 10}":[
        "Sabach (Greece)"
    ],
    "{0, 2, 5, 7, 8}":[
        "Han-kumoi (Japan)",
        "Japanese Han-Kumoi",
        "Japanese Sakura"
    ],
    "{0, 2, 4, 5, 8, 9, 11}":[
        "Ionian",
        "Harmonic Major 2"
    ],
    "{0, 2, 4, 5, 7, 8, 11}":[
        "Ethiopian",
        "Mela Sarasangi",
        "Harmonic Major"
    ],
    "{0, 3, 4, 5, 7, 9, 11}":[
        "Houzam (Greece) Raga",
        "Greek Houzam",
        "Mela Sulini",
        "Raga Saildesakshi"
    ],
    "{0, 1, 4, 5, 7, 8, 11}":[
        "Hungarian Folk or Byzanti",
        "Theta Bhairav",
        "Double Harmonic",
        "Hungarian Folk",
        "Byzantine"
    ],
    "{0, 3, 4, 6, 7, 9, 10}":[
        "Hungarian Major",
        "Hungarian Major Raga Na",
        "Raga Nasamani"
    ],
    "{0, 2, 4, 5, 7, 9, 11}":[
        "Theta Bilaval",
        "Ethiopian 1",
        "Major",
        "Ionian, Major, Bilaval C t",
        "Mela Dhirasankara",
        "Ionian"
    ],
    "{0, 2, 5, 6, 8, 9, 11}":[
        "Japanese Nohkan",
        "Nohkan (Japan)"
    ],
    "{0, 1, 3, 5, 6, 9, 10}":[
        "Locrian Natural Maj 6",
        "Pseudo Turkish",
        "Locrian Natural Maj 6, Ps"
    ],
    "{0, 1, 3, 5, 6, 8, 10}":[
        "Locrian - B to A Ascendin",
        "Locrian",
        "Half Diminished"
    ],
    "{0, 2, 4, 6, 8, 9, 11}":[
        "Hindi IV & V",
        "Lydian Augmented, Hindi",
        "Lydian Augmented"
    ],
    "{0, 2, 4, 6, 7, 8, 10}":[
        "Raga Ratipriya",
        "Lydian Minor",
        "Lydian Minor, Stravinski R",
        "Mela RisA bhapriya"
    ],
    "{0, 2, 4, 5, 6, 7, 9, 10, 11}":[
        "Lydian Mixolydian",
        "Lydian Mixolydian Taishik",
        "Japanese Taishikicho"
    ],
    "{0, 2, 4, 6, 7, 9, 11}":[
        "Lydian, Kalyan F to E asc",
        "Theta Kalyan",
        "Mela Mechakalyani",
        "Lydian"
    ],
    "{0, 10, 4, 7}":[
        "Raga Samudhra Priya",
        "Chord 7th",
        "Major #6 Chord e.g. C7 R",
        "Major b7 Chord e.g. C7 R",
        "Chord m7-5",
        "Raga Mahathi",
        "Chord m7",
        "Raga Multani",
        "Chinese Bi Yu"
    ],
    "{0, 10, 5, 7}":[
        "Messiaen Mode 2-1",
        "Major b7 Suspend 4th Ch",
        "Chord 7sus4",
        "Genus Primum Inverse"
    ],
    "{0, 2, 4, 5, 7, 8, 9}":[
        "Major Bebop Heptatonic",
        "Mela Mararanjani",
        "Bebop Major Heptatonic"
    ],
    "{0, 2, 4, 5, 7, 8, 9, 11}":[
        "Major Bebop",
        "Bebop Major"
    ],
    "{0, 2, 4, 5, 6, 7, 9, 11}":[
        "Major Lydian Genus Diato",
        "Major Lydian",
        "Japanese Ichikosucho"
    ],
    "{0, 2, 4, 5, 7, 8, 10}":[
        "Major Minor",
        "Mela Charukesi",
        "Major Minor, Hindu bVI &",
        "Hindu"
    ],
    "{0, 2, 4, 7, 9}":[
        "Japanese Kumoi",
        "Pentatonic Major",
        "Raga Vijayanagari",
        "Diatonic",
        "Chinese Mongolian",
        "Dorian Pentatonic",
        "Major Pentatonic"
    ],
    "{0, 1, 2, 6, 7, 8, 10}":[
        "Mela Jalarnavam",
        "Mela Jalarnava"
    ],
    "{0, 1, 4, 6, 7, 8, 10}":[
        "Mela Namanararayani",
        "Mela Namanarayani"
    ],
    "{0, 3, 4, 6, 7, 8, 9}":[
        "Mela Sucharitra",
        "Mela Sucaritra"
    ],
    "{0, 2, 3, 4, 6, 7, 8, 10, 11}":[
        "Messiaen 4 according to",
        "Messiaen Mode 3 Inverse"
    ],
    "{0, 3, 4, 5, 6, 9, 10, 11}":[
        "Messiaen Mode 4 Inverse"
    ],
    "{0, 2, 4, 5, 6, 8, 10, 11}":[
        "Messiaen 7 according to",
        "Messiaen Mode 6 Inverse"
    ],
    "{0, 2, 3, 4, 5, 6, 8, 9, 10, 11}":[
        "Messiaen Mode 7 Inverse"
    ],
    "{0, 1, 4, 5, 8, 9}":[
        "Messiaen Truncated 3",
        "Messiaen Truncated Mod",
        "Six Tone Symmetrical"
    ],
    "{0, 2, 3, 5, 6, 8, 10}":[
        "Half Diminished 2",
        "Minor Locrian",
        "Minor Locrian, Hindi 3 flat"
    ],
    "{0, 2, 3, 5, 7, 9, 11}":[
        "Minor Melodic",
        "Mela Gaurimanohari",
        "Hawaiian 2",
        "Melodic Minor (Ascend)"
    ],
    "{0, 2, 3, 5, 7}":[
        "Minor Pentachord",
        "Minor Pentachord Chad G"
    ],
    "{0, 2, 3, 4, 5, 6, 7, 9, 10, 11}":[
        "All except C# and G# - 1#",
        "Minor Pentatonic with Le",
        "Minor Pentatonic Lead"
    ],
    "{0, 2, 5, 6, 7, 10, 11}":[
        "Chromatic Mixolydian Inv",
        "Mixolydian Chrom. Inverse"
    ],
    "{0, 2, 4, 5, 7, 9, 10}":[
        "Mela Harikambhoji",
        "Dominant 7th",
        "Mixolydian, Khamaj G to",
        "Theta Khamaj",
        "Mixolydian"
    ],
    "{0, 2, 3, 5, 7, 8, 10}":[
        "Aeolian",
        "Mela NatA bhairavi",
        "Theta Asavari",
        "Ethiopian 3",
        "Aeolian Natural Minor, As",
        "Natural Minor"
    ],
    "{0, 2, 4, 6, 7, 9, 10}":[
        "Mela Vaschaspati",
        "Overtone",
        "Lydian bVIIth, Overtone,",
        "Lydian Dominant",
        "Hindi IV & bVII"
    ],
    "{0, 1, 3, 7, 10}":[
        "Raga Rukmangi, Pelog 2",
        "Raga Rukmangi",
        "Pelog 2"
    ],
    "{0, 3, 5, 7, 10}":[
        "Mixolydian Pentatonic",
        "Raga Jayakauns",
        "Blues Pentatonic Minor, H",
        "Raga Nata",
        "Blues V",
        "Pentatonic Minor"
    ],
    "{0, 1, 2, 4, 7, 8, 9}":[
        "Phrygian Chrom. Inverse",
        "Messiaen Mode 4-2",
        "Chromatic Phrygian Invers"
    ],
    "{0, 3, 4, 5, 8, 10, 11}":[
        "Phrygian Chromatic"
    ],
    "{0, 1, 4, 5, 7, 8, 10}":[
        "Phrygian Dominant, Doric",
        "Phrygian Dominant",
        "Jewish AhA ba RA b Ba",
        "Spanish Gypsy",
        "Dorico Flamenco"
    ],
    "{0, 1, 3, 4, 5, 7, 8, 10}":[
        "Phrygian Major",
        "Phrygian Major, Flamenc",
        "Flamenco"
    ],
    "{0, 1, 3, 5, 7, 8, 10}":[
        "Mela Hanumattodi",
        "Phrygian, Bhairavi E to D",
        "Theta Bhairavi",
        "Neopolitan Minor 2",
        "Phrygian"
    ],
    "{0, 2, 3, 5, 9}":[
        "Raga Abhogi",
        "Raga A bhogi"
    ],
    "{0, 2, 5, 7, 8, 11}":[
        "Raga Bhinna Pancama (I",
        "Raga Bhinna Pancama",
        "Raga Padi"
    ],
    "{0, 2, 4, 7, 8}":[
        "Raga Bhupeshwari",
        "Raga Syamalam",
        "Raga Bhupeshwari, Janas",
        "Japanese Hirajoshi"
    ],
    "{0, 3, 5, 8, 11}":[
        "Romanian Bacovia",
        "Raga Bhinna Shadja",
        "Raga Chandrakauns Kirav",
        "Raga Chand. Kiravani"
    ],
    "{0, 3, 5, 9, 11}":[
        "Raga Chandrakauns Mode",
        "Raga Chandrakauns"
    ],
    "{0, 1, 4, 6, 9, 11}":[
        "Raga Hamsanandi",
        "Raga Hamsanandi, Puriya"
    ],
    "{0, 3, 6, 8, 10}":[
        "Raga Harikauns",
        "Raga Harikauns ??"
    ],
    "{0, 1, 4, 5, 7, 9}":[
        "Raga Kalavati",
        "Raga Kalavati, Ragamali"
    ],
    "{0, 3, 4, 6, 7, 9, 11}":[
        "Mela Kosalam",
        "Raga Kuksumak",
        "Raga Kuksumakaram",
        "Lydian 2"
    ],
    "{0, 4, 7, 9, 11}":[
        "Raga Mamata",
        "Raga Mamata Maj"
    ],
    "{0, 2, 3, 5, 7, 9, 10, 11}":[
        "Raga Mian Ki Malhar, Ba",
        "Raga Mian Ki Malhar"
    ],
    "{0, 1, 2, 6, 7}":[
        "Raga Nabhomani",
        "Raga NA bhomani"
    ],
    "{0, 2, 4, 5, 7, 11}":[
        "Raga Nalinakanti",
        "Raga Nalinakanti, Kedara"
    ],
    "{0, 5, 7, 9, 11}":[
        "Raga Puruhutika",
        "Raga Puruhutika, Purvaho"
    ],
    "{0, 1, 4, 7, 8}":[
        "Balinese",
        "Raga Reva",
        "Pelog 1",
        "Raga Reva, Revagupti"
    ],
    "{0, 1, 6, 7, 8}":[
        "Raga Saugandhini, Yashr",
        "Raga Saugandhini"
    ],
    "{0, 2, 4, 5, 7, 10}":[
        "Raga Siva Kambhoji",
        "Raga Siva Kambhoji, Viv"
    ],
    "{0, 4, 7, 9, 10}":[
        "Raga Valaji - Thrit",
        "Raga Valaji",
        "Chord 7\/6",
        "Raga Madhakauns"
    ],
    "{0, 1, 4, 5, 8, 10}":[
        "Raga VasantA bhairavi",
        "Raga Rudra Pancama",
        "Raga Vasantabhairavi"
    ],
    "{0, 2, 5, 7, 9}":[
        "Japanese Ritusen",
        "Ritusen Japan, Scottish P",
        "Example of Slendro (sam",
        "Scottish Pentatonic"
    ],
    "{0, 1, 4, 6, 7, 9, 10}":[
        "Purvi bV",
        "Romanian Major",
        "Mela Ramapriya"
    ],
    "{0, 2, 4, 5, 7, 9}":[
        "Scottish Hexatonic",
        "Scottish Hexatonic Arezzo"
    ],
    "{0, 1, 4, 6, 7, 9, 11}":[
        "Marva Thaat",
        "Theta Marva",
        "Mela Gamanasrama",
        "Marva or Marvi"
    ],
    "{0, 2, 3, 5, 7, 8, 9, 11}":[
        "Zirafkend (Arabia)",
        "Arabian Zirafkend"
    ],
    "{0, 3, 4, 5, 7, 9, 10}":[
        "Rock 'n Roll",
        "Raga Nandkauns",
        "Rock'n Roll",
        "Mela Vagadhisvari"
    ],
    "{0, 1, 3, 4, 5, 7, 9, 10}":[
        "JG Octatonic all 3b",
        "Octatonic JG",
        "JG Octatonic"
    ],
    "{0, 1, 3, 5, 6, 7, 9, 11}":[
        "Messiaen 6th mode From",
        "Messiaen 3 Brown",
        "Messiaen 3 according to"
    ],
    "{0, 1, 2, 3, 6, 7, 8, 9}":[
        "Messiaen Mode 4 (all flats",
        "Messiaen Mode 4 (1b3#\u2019s)",
        "Messiaen Mode 4 (all shar"
    ],
    "{0, 1, 2, 3, 5, 6, 7, 8, 9, 11}":[
        "Messiaen Mode 7"
    ],
    "{0, 2, 3, 4, 7, 9, 10}":[
        "Minor Bebop Heptatonic",
        "Bebop Minor Heptatonic",
        "Minor Bebop"
    ],
    "{0, 1, 2, 3, 5, 7, 8, 10}":[
        "Phrygian Aeolian 2b 4b 6",
        "Phrygian Aeolian",
        "Phrygian Aeolian 3b1#"
    ],
    "{0, 2, 4, 6, 9, 10}":[
        "Prometheus"
    ],
    "{0, 4, 6, 7, 9, 10}":[
        "Raga Vutari"
    ],
    "{0, 10, 5}":[
        "Sanagari (Japan)"
    ],
    "{0, 2, 4, 6, 8, 10}":[
        "whole tone #\u2019s in 12edo)",
        "whole tone b\u2019s in 12edo)",
        "Whole tone alternate",
        "Whole-Tone, Anhemitonic",
        "Whole Tone"
    ],
    "{0, 10, 3}":[
        "Ute Tritone (North Americ",
        "Ute Tritone? (North Ameri",
        "Ute Tritone"
    ],
    "{0, 2, 3, 5, 7, 8, 10, 11}":[
        "Utility Minor (as 9\/89\/5 9n",
        "Utility minor 14\/38911121",
        "Utility Minor"
    ],
    "{0, 1, 6, 7}":[
        "Messiaen Mode 2",
        "Messiaen Mode 2-4",
        "Messiaen Truncated Mod"
    ],
    "{0, 1, 2, 5, 6, 7, 8, 11}":[
        "Messiaen 5 according to",
        "Messiaen Mode 4-1",
        "Messiaen Mode 4",
        "Messiaen Mode 4?"
    ],
    "{0, 1, 2, 6, 7, 8}":[
        "Messiaen Mode 5 (dupe 8",
        "Messiaen Mode 5 (dupe o",
        "Messiaen 5th Groves",
        "Messiaen 5th mode From"
    ],
    "{0, 3, 4, 5, 8}":[
        "Center-Cluster PentaMirror",
        "Centered PentaMirror"
    ],
    "{0, 1, 2, 3, 5, 7, 9, 10}":[
        "Jewish Adonai Malakh",
        "Adonai Malakh (Israel)"
    ],
    "{0, 1, 3, 4}":[
        "Alternating TetraMirror",
        "Alternate TetraMirror"
    ],
    "{0, 3, 5, 6, 7, 10, 11}":[
        "Blues with Leading Tone",
        "Blues Leading Tone"
    ],
    "{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}":[
        "ChromatiC D ecaMirror",
        "Chromatic DecaMirror all"
    ],
    "{0, 1, 2, 3, 5, 7, 8, 9, 10}":[
        "Diatonic Dorian Chrom.",
        "Chromatic Diatonic Doria"
    ],
    "{0, 1, 2, 3, 4, 5, 6}":[
        "Chromatic HeptaMirror #\u2019s",
        "Chromatic HeptaMirror"
    ],
    "{0, 1, 2, 4, 6, 7, 10}":[
        "Mixolydian Chromatic 2",
        "Chromatic Mixolydian"
    ],
    "{0, 1, 2, 5, 6, 7, 10}":[
        "Mixolydian Chromatic 1",
        "Chromatic Mixolydian"
    ],
    "{0, 1, 3, 5, 6, 9}":[
        "Phrygian Double Hex.",
        "Double-Phrygian Hexatoni"
    ],
    "{0, 2, 3, 5, 7, 8, 9, 10, 11}":[
        "Full Minor",
        "Full Minor all flats"
    ],
    "{0, 1, 2, 3, 5, 7, 8, 11}":[
        "Harmonic Neapolitan Min",
        "Harm. Neapolitan Minor"
    ],
    "{0, 9, 3, 5}":[
        "Major b7 Chord e.g. F7",
        "Major b7 Chord"
    ],
    "{0, 1, 3, 4, 5, 6, 9, 10}":[
        "Maqam Shadd'arA ban",
        "Maqam Shadd'araban"
    ],
    "{0, 2, 3, 5, 6, 8, 10, 11}":[
        "Messiaen 2 according to",
        "Messiaen 2 Brown"
    ],
    "{0, 2, 5, 6, 8, 11}":[
        "Messiaen Mode 2",
        "Messiaen Mode 2-3"
    ],
    "{0, 1, 4, 5, 6, 8, 9, 10}":[
        "Messiaen 3nd mode From",
        "Messiaen Mode 1b3#\u2019s"
    ],
    "{0, 1, 2, 4, 6, 7, 8, 10}":[
        "Messiaen Mode 6",
        "Messiaen Mode 6-2"
    ],
    "{0, 1, 2, 3, 4, 6, 7, 8, 9, 10}":[
        "Messiaen Mode 7-2",
        "Messiaen Mode 7"
    ],
    "{0, 4, 5, 7, 10}":[
        "Mixolydian Pentatonic??",
        "Mixolydian Pentatonic"
    ],
    "{0, 1, 2, 4, 6, 8, 9}":[
        "Neapolitan Minor Mode (a",
        "Neapolitan Minor 2"
    ],
    "{0, 4, 5, 7, 9, 10, 11}":[
        "Raga Madhuri 11\/489101",
        "Raga Madhuri"
    ],
    "{0, 1, 3, 4, 5, 7, 8, 10, 11}":[
        "Moorish Phrygian"
    ],
    "{0, 10, 3, 6}":[
        "Messiaen Truncated"
    ],
    "{0, 1, 2, 3, 6}":[
        "Blues Pentacluster"
    ],
    "{0, 1, 2, 4, 5, 6, 7, 9, 10}":[
        "Youlan (China)"
    ],
    "{0, 9, 3, 6}":[
        "Diminished 7th Chord, 3 S",
        "Messiaen 2nd Mode"
    ],
    "{0, 5, 7}":[
        "Raga Sarvarsi",
        "Chord sus4"
    ],
    "{0, 10, 3, 7}":[
        "Minor Seventh Chord e.g.",
        "Bi Yu (China)"
    ],
    "{0, 9, 2, 6}":[
        "Major b7 Chord 2",
        "Major b7 Chord e.g. D7"
    ],
    "{0, 2, 3, 4, 5, 7, 8, 9, 10, 11}":[
        "Major & Minor mixed",
        "All except C# and F# - 1#"
    ],
    "{0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11}":[
        "All except A - 6th all flat",
        "All except A 6th all sharp"
    ],
    "{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}":[
        "All except B - 7 all flat",
        "Chromatic UndecaMirror"
    ],
    "{0, 3, 5, 6, 11}":[
        "Blues #V (as 7\/346\/8 in 12",
        "Blues#V (all b\u2019s) 9\/25678\/"
    ],
    "{0, 6}":[
        "Sharp Fourth",
        "Flat Fifth Interval"
    ],
    "{0, 8}":[
        "Flat Sixth Interval",
        "Sharp Fifth Interval"
    ],
    "{0, 3}":[
        "Flattened Third interval",
        "Sharp Second interval"
    ],
    "{0, 10}":[
        "Flat Seventh Interval",
        "Sharp Sixth Interval"
    ],
    "{0, 11}":[
        "Major Seventh Interval",
        "Flat Octave Interval"
    ],
    "{0, 7}":[
        "Fifth Interval",
        "Chord 5th (power)"
    ],
    "{0, 10, 11}":[
        "Sharp Sixth and Seventh",
        "Flat Seventh and Seventh"
    ],
    "{0, 1, 2, 4, 5, 7, 8, 9, 11}":[
        "Chromatic Permuted Diat",
        "Diatonic Dorian Perm."
    ],
    "{0, 2, 3, 4, 7, 9}":[
        "Blues Major",
        "Blues Dorian Hex (all b\u2019s)"
    ],
    "{0, 8, 2, 6}":[
        "Messiaen Trunc. Mode 6",
        "Messiaen Truncated Mod"
    ],
    "{0, 4, 5, 7, 8, 9}":[
        "Raga Saravati (b6)"
    ],
    "{0, 1, 2, 3, 5}":[
        "Blues PentaCluster 3b\u2019s",
        "Blues PentaCluster 2b\u2019s 1#"
    ],
    "{0, 2, 5, 7, 10}":[
        "Raga Gauri",
        "Japanese Iwato",
        "Pentatonic Neutral",
        "Japanese Kokin-Joshi",
        "Egyptian",
        "Raga Desh"
    ],
    "{0, 1, 3, 6, 7}":[
        "Japanese Pentachord",
        "Javanese Pentachord"
    ],
    "{0, 1, 4, 7, 9, 10}":[
        "Raga Malayamarutam",
        "Mela Sadvidhamargini",
        "Todi bVII"
    ],
    "{0, 2, 4, 6, 8, 11}":[
        "Eskimo Hexatonic"
    ],
    "{0, 2, 4, 7, 9, 11}":[
        "Lydian Hexatonic",
        "Hawaiian 1",
        "Lydian Diminished",
        "Mela Dharmavati",
        "Raga Ranjani"
    ],
    "{0, 3, 5, 8, 10}":[
        "Raga Malkauns",
        "Raga Chandrakauns Kafi",
        "Blues Pentatonic Minor, H",
        "Raga Khamaji Durga"
    ],
    "{0, 1, 4, 5, 8, 11}":[
        "Raga Vasanta",
        "Raga Sohini"
    ],
    "{0, 1, 4, 6, 7, 10}":[
        "Raga Mandari",
        "Raga Indupriya"
    ],
    "{0, 2, 4, 5, 8, 11}":[
        "Raga Hamsa Vinodini",
        "Raga Sarasanana"
    ],
    "{0, 2, 5, 7, 8, 10}":[
        "Raga Navamanohari",
        "Raga Phenadyuti"
    ],
    "{0, 2, 5, 7, 9, 11}":[
        "Raga Jivantika",
        "Raga Nagagandhari"
    ],
    "{0, 2, 5, 8, 11}":[
        "Raga Kshanika",
        "Raga Priyadharshini"
    ],
    "{0, 3, 5, 7, 8, 11}":[
        "Raga Paraju",
        "Raga Takka"
    ],
    "{0, 3, 5, 7, 8}":[
        "Raga Kokil Pancham",
        "Raga Zilaf"
    ],
    "{0, 3, 5, 7, 9, 10}":[
        "Raga Khamas",
        "Raga Manohari"
    ],
    "{0, 4, 7, 8, 10}":[
        "Raga Shailaja",
        "Raga Harikauns"
    ],
    "{0, 8, 2, 5}":[
        "Raga Lavangi",
        "Raga Haripriya"
    ],
    "{0, 1, 4, 7, 8, 10}":[
        "Raga Kalagada",
        "Mela Bhavapriya",
        "Raga Kashyapi"
    ],
    "{0, 1, 3, 4, 6, 7, 9, 10}":[
        "Blues Diminished",
        "Messiaen Mode 2, Auxillar",
        "Half-Diminished, Symmetr"
    ],
    "{0, 2, 4, 7, 8, 11}":[
        "Mela Simhendramadhyama",
        "Hungarian Minor",
        "Takemitsu Tree Line 1",
        "Raga Latika"
    ],
    "{0, 2, 4, 7, 8, 10}":[
        "Raga Trimurti",
        "Hungarian Gypsy",
        "Mela Sanmukhapriya",
        "Takemitsu Tree Line 2"
    ],
    "{0, 1, 3, 4, 6, 8, 10}":[
        "Super Locrian",
        "Hindi 5 flats",
        "Lydian Augmented or Hin",
        "Diminished Whole Tone"
    ],
    "{0, 2, 3, 5, 7, 8, 11}":[
        "Mohammedan",
        "Mela Kiravani",
        "Harmonic Minor"
    ],
    "{0, 1, 3, 5, 7, 9, 11}":[
        "Neapolitan Major",
        "Mela Kokilapriya"
    ],
    "{0, 1, 3, 5, 7, 8, 11}":[
        "Neapolitan Minor",
        "Mela Dhenuka"
    ],
    "{0, 2, 4, 7, 9, 10}":[
        "Raga Manavi",
        "Mela Hemavati",
        "Roumanian Minor",
        "Gnossiennes"
    ],
    "{0, 1, 4, 7, 8, 11}":[
        "Theta Todi",
        "Mela Subhapantuvarali",
        "Raga Bauli",
        "Lydian Chromatic Inverse"
    ],
    "{0, 1, 3, 5, 7, 9, 10}":[
        "Javanese",
        "Mela Natakapriya",
        "Jazz Minor Inverse"
    ],
    "{0, 2, 4, 7}":[
        "Eskimo Tetratonic",
        "Harm. Min. Tetrachord",
        "Chord 2"
    ],
    "{0, 3, 5, 7, 11}":[
        "Ionian Pentatonic",
        "Raga Nata, Madhuranjan",
        "Raga Gambhiranata"
    ],
    "{0, 1, 3, 5, 7, 10}":[
        "Honchoshi Plagal Form",
        "Raga Gandharavam"
    ],
    "{0, 1, 4, 5, 7, 8, 9}":[
        "Gypsy Hexatonic",
        "Mela Gayakapriya"
    ],
    "{0, 1, 4, 5, 7, 9, 10}":[
        "Harmonic Minor Inverse",
        "Mela Chakravakam"
    ],
    "{0, 1, 4, 5, 7, 9, 11}":[
        "Mela Suryakantam",
        "Bhairubahar Thaat"
    ],
    "{0, 2, 3, 5, 7, 10}":[
        "Minor Hexatonic",
        "Raga Sindhura Kafi"
    ],
    "{0, 2, 3, 6, 7, 9, 11}":[
        "Mela Nitimati",
        "Lydian Diminished"
    ],
    "{0, 2, 4, 5, 6, 8, 10}":[
        "Arabian 2",
        "Major Locrian"
    ],
    "{0, 2, 5, 6, 8, 9, 10}":[
        "Gypsy Hexatonic 1",
        "Raga Kalakanti"
    ],
    "{0, 2, 5, 7, 9, 10}":[
        "Mixolydian Hexatonic",
        "Raga Rasavali"
    ],
    "{0, 2, 5, 8, 10}":[
        "Raga Guhamanohari",
        "Chaio"
    ],
    "{0, 3, 5, 7, 10, 11}":[
        "Messiaen Mode 5 Inv",
        "Raga Tilang"
    ],
    "{0, 3, 5, 7, 8, 10}":[
        "Raga Kamalamanohari",
        "Phrygian Hexatonic"
    ],
    "{0, 4, 6, 7, 10}":[
        "Chinese",
        "Raga Malashri"
    ],
    "{0, 10, 4, 6}":[
        "Chord 7-5",
        "Messiaen Truncated Mod"
    ],
    "{0, 2, 4, 7, 10}":[
        "Raga Simharava",
        "Raga Hamsadhvani",
        "Raga Kumurdaki",
        "Raga Amarasenapriya",
        "Dominant Pentatonic"
    ],
    "{0, 11, 5, 6}":[
        "Messiaen Mode 2",
        "Messiaen Truncated Mod"
    ],
    "{0, 3, 5, 6, 7, 10}":[
        "Blues Minor"
    ],
    "{0, 1, 2, 5, 6, 7, 9}":[
        "Hypophrygian Inverse",
        "Chromatic Hypophrygian I"
    ],
    "{0, 1, 4, 6, 7}":[
        "Balinese Pentatonic",
        "Balinese Pentachord"
    ],
    "{0, 3, 4, 7, 9, 11}":[
        "Lydian b3 Hexatonic"
    ],
    "{0, 3, 5, 7, 9}":[
        "Minor 6th Added",
        "Raga Mand"
    ],
    "{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}":[
        "Chromatic"
    ],
    "{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11}":[
        "All except Bb - 7b all shar"
    ],
    "{0, 1, 2, 3, 4, 5, 6, 7, 8}":[
        "Chromatic NonaMirror"
    ],
    "{0, 1, 2, 3, 4, 5, 6, 7, 9, 10, 11}":[
        "All except G# - 5#"
    ],
    "{0, 1, 2, 3, 4, 5, 6, 7}":[
        "Chromatic OctaMirror"
    ],
    "{0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11}":[
        "All 12 notes except D -2 -"
    ],
    "{0, 1, 2, 3, 4, 5, 7, 8, 10, 11}":[
        "Raga Sindi Bhairavi"
    ],
    "{0, 1, 2, 3, 4, 5, 7, 8, 9, 10, 11}":[
        "All except F# - 4#"
    ],
    "{0, 1, 2, 3, 4, 5, 7, 8, 9, 10}":[
        "All except F# and B - 4#"
    ],
    "{0, 1, 2, 3, 4, 5}":[
        "Chromatic HexaMirror"
    ],
    "{0, 1, 2, 3, 4, 6, 7, 8, 9, 10, 11}":[
        "All except F - 4"
    ],
    "{0, 1, 2, 3, 4, 6, 7, 8, 9, 11}":[
        "All except F and Bb - 4 an"
    ],
    "{0, 1, 2, 3, 4, 6, 7, 9, 10, 11}":[
        "Pan Diminished Blues"
    ],
    "{0, 1, 2, 3, 4}":[
        "Chromatic PentaMirror"
    ],
    "{0, 1, 2, 3, 5, 6, 7, 8, 10, 11}":[
        "All except E and A - 3 and"
    ],
    "{0, 1, 2, 3, 5, 6, 7, 8, 9, 10, 11}":[
        "All except E - 3"
    ],
    "{0, 1, 2, 3, 5, 6, 7, 8, 9, 10}":[
        "All except E and B - 3 an"
    ],
    "{0, 1, 2, 3, 5, 6, 7, 8, 9}":[
        "untitled Nonatonic 1"
    ],
    "{0, 1, 2, 3, 6, 7, 8, 11}":[
        "Hungarian Minor b2"
    ],
    "{0, 1, 2, 3}":[
        "Chromatic TetraMirror"
    ],
    "{0, 1, 2, 4, 5, 6, 7, 8, 10, 11}":[
        "Symmetrical Decatonic"
    ],
    "{0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11}":[
        "All except Eb - 3b"
    ],
    "{0, 1, 2, 4, 5, 6, 7, 8, 9, 11}":[
        "All except Eb and Bb - 3b"
    ],
    "{0, 1, 2, 4, 5, 6, 7, 9, 10, 11}":[
        "All except Eb and Ab -3b"
    ],
    "{0, 1, 2, 4, 5, 6, 8, 9, 10}":[
        "Messiaen Mode 3"
    ],
    "{0, 1, 2, 4, 6, 7, 8, 10, 11}":[
        "Symmetrical Nonatonic"
    ],
    "{0, 1, 2, 4, 7, 8, 11}":[
        "Hungarian Minor b2"
    ],
    "{0, 1, 2, 4, 7}":[
        "Blues Pentacluster"
    ],
    "{0, 1, 2, 5, 6, 7, 10, 11}":[
        "Mela Tanarupi"
    ],
    "{0, 1, 2, 5, 6}":[
        "Oriental Pentacluster"
    ],
    "{0, 1, 2, 5, 7, 10, 11}":[
        "Mela Tanarupi"
    ],
    "{0, 1, 2, 5, 7, 8, 10}":[
        "Mela Ratnangi"
    ],
    "{0, 1, 2, 5, 7, 8, 11}":[
        "Mela Ganamurti"
    ],
    "{0, 1, 2, 5, 7, 9, 10}":[
        "Mela Vanaspati"
    ],
    "{0, 1, 2, 5, 7, 9, 11}":[
        "Mela Manavati"
    ],
    "{0, 1, 2, 5, 8, 9}":[
        "Raga Suddha Mukhari"
    ],
    "{0, 1, 2, 6, 7, 10, 11}":[
        "Mela Raghupriya"
    ],
    "{0, 1, 2, 6, 7, 10}":[
        "Raga Vijayasri"
    ],
    "{0, 1, 2, 6, 7, 11}":[
        "Raga Vijayasri"
    ],
    "{0, 1, 2, 6, 7, 8, 11}":[
        "Mela Jhalavarali"
    ],
    "{0, 1, 2, 6, 7, 8, 9}":[
        "Mela Salaga"
    ],
    "{0, 1, 2, 6, 7, 9, 10}":[
        "Mela Navanitam"
    ],
    "{0, 1, 2, 6, 7, 9, 11}":[
        "Mela Pavani"
    ],
    "{0, 1, 2, 6, 7, 9}":[
        "Raga Chandrajyoti"
    ],
    "{0, 1, 2, 8, 11}":[
        "Raga Kumarapriya"
    ],
    "{0, 1, 2, 8, 9}":[
        "Raga Putrika"
    ],
    "{0, 1, 2}":[
        "Chromatic TriMirror"
    ],
    "{0, 1, 3, 4, 5, 6, 7, 8, 10, 11}":[
        "All except D and A - 2 and"
    ],
    "{0, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11}":[
        "All except D -2"
    ],
    "{0, 1, 3, 4, 5, 6, 7, 9, 10}":[
        "untitled Nonatonic 2"
    ],
    "{0, 1, 3, 4, 5, 6, 8, 10}":[
        "Spanish 8 tone"
    ],
    "{0, 1, 3, 4, 5, 6, 8, 9, 10, 11}":[
        "All except D and G - 2 an"
    ],
    "{0, 1, 3, 4, 5, 7, 8, 9, 11}":[
        "Genus Chromaticum"
    ],
    "{0, 1, 3, 4, 5}":[
        "Spanish Pentacluster"
    ],
    "{0, 1, 3, 4, 6, 7, 9, 11}":[
        "Shostakovich"
    ],
    "{0, 1, 3, 4, 6, 8, 10, 11}":[
        "Magen A bot 1"
    ],
    "{0, 1, 3, 4, 6, 8, 9, 11}":[
        "Magen Abot (Israel)"
    ],
    "{0, 1, 3, 4, 6, 8, 9}":[
        "Ultra Locrian"
    ],
    "{0, 1, 3, 4, 7, 8, 10}":[
        "Indian, Phrygian dim 4th"
    ],
    "{0, 1, 3, 4, 7, 9}":[
        "Blues Dorian Hexatonic"
    ],
    "{0, 1, 3, 5, 6, 10}":[
        "Honchoshi Plagal Form"
    ],
    "{0, 1, 3, 5, 6, 7, 10}":[
        "Blues Phrygian"
    ],
    "{0, 1, 3, 5, 6, 7, 8, 10}":[
        "Phrygian Locrian"
    ],
    "{0, 1, 3, 5, 6, 8, 10, 11}":[
        "Prokofiev"
    ],
    "{0, 1, 3, 5, 6, 8, 9}":[
        "Locrian b B7"
    ],
    "{0, 1, 3, 5, 6}":[
        "Locrian PentaMirror"
    ],
    "{0, 1, 3, 5, 7, 10, 11}":[
        "Mela Rupavati"
    ],
    "{0, 1, 3, 5, 7, 8, 9}":[
        "Mela Senavati"
    ],
    "{0, 1, 3, 5, 7, 8}":[
        "Raga Simantini"
    ],
    "{0, 1, 3, 5, 8, 10}":[
        "Ritsu"
    ],
    "{0, 1, 3, 5, 8, 11}":[
        "Raga Viyogavarali"
    ],
    "{0, 1, 3, 5, 8}":[
        "Raga Chitthakarshini"
    ],
    "{0, 1, 3, 5}":[
        "Phrygian Tetrachord"
    ],
    "{0, 1, 3, 6, 7, 10, 11}":[
        "Mela Divamani"
    ],
    "{0, 1, 3, 6, 7, 8, 10, 11}":[
        "Neveseri (Greece)"
    ],
    "{0, 1, 3, 6, 7, 8, 10}":[
        "Mela Bhavapriya"
    ],
    "{0, 1, 3, 6, 7, 8, 11}":[
        "Chromatic Lydian Inverse,"
    ],
    "{0, 1, 3, 6, 7, 8, 9}":[
        "Mela Gavambohdi"
    ],
    "{0, 1, 3, 6, 7, 9, 10}":[
        "Todi bVII Mela Sadvidha"
    ],
    "{0, 1, 3, 6, 7, 9}":[
        "Messiaen Truncated Mod"
    ],
    "{0, 1, 3, 6, 8, 10, 11}":[
        "Enigmatic Minor"
    ],
    "{0, 1, 3, 6, 8, 10}":[
        "Raga Bhavani"
    ],
    "{0, 1, 3, 6, 8, 11}":[
        "Raga Gujari Todi"
    ],
    "{0, 1, 3, 6, 8}":[
        "Raga Chhaya Todi"
    ],
    "{0, 1, 3, 7, 8, 10}":[
        "Raga Kashyapi"
    ],
    "{0, 1, 3, 7, 8}":[
        "Balinese, Pelog 1"
    ],
    "{0, 1, 3, 7, 9, 10}":[
        "Raga Salagavarali"
    ],
    "{0, 1, 3}":[
        "Phrygian Trichord"
    ],
    "{0, 1, 4, 5, 11}":[
        "Raga Megharanji"
    ],
    "{0, 1, 4, 5, 6, 7, 8, 11}":[
        "Raga Ramkali"
    ],
    "{0, 1, 4, 5, 6, 7, 9, 11}":[
        "Raga Bhatiyar"
    ],
    "{0, 1, 4, 5, 6, 8, 10, 11}":[
        "Enigmatic"
    ],
    "{0, 1, 4, 5, 6, 8, 10}":[
        "Oriental 3"
    ],
    "{0, 1, 4, 5, 6, 9, 10, 11}":[
        "Oriental 2"
    ],
    "{0, 1, 4, 5, 6, 9, 10}":[
        "Oriental 1"
    ],
    "{0, 1, 4, 5, 7, 10, 11}":[
        "Mela Hatakambari"
    ],
    "{0, 1, 4, 5, 7, 11}":[
        "Raga Gaula"
    ],
    "{0, 1, 4, 5, 7, 8, 10, 11}":[
        "Maqam Hijaz"
    ],
    "{0, 1, 4, 5, 7, 8, 9, 11}":[
        "Raga Saurashtra"
    ],
    "{0, 1, 4, 5, 7, 8}":[
        "Raga Malahari"
    ],
    "{0, 1, 4, 5, 8, 10, 11}":[
        "Enigmatic Descending"
    ],
    "{0, 1, 4, 5, 8}":[
        "Raga Megharanjani"
    ],
    "{0, 1, 4, 5, 9, 10}":[
        "Raga Rudra Pancama"
    ],
    "{0, 1, 4, 5, 9, 11}":[
        "Raga Vasanta, Chayavati"
    ],
    "{0, 1, 4, 6, 7, 10, 11}":[
        "Mela Visvambhari"
    ],
    "{0, 1, 4, 6, 7, 11}":[
        "Raga Mandari, Gamakakri"
    ],
    "{0, 1, 4, 6, 7, 8, 9}":[
        "Mela Dhavalambari"
    ],
    "{0, 1, 4, 6, 7, 8}":[
        "Raga Dhavalangam"
    ],
    "{0, 1, 4, 6, 8, 10, 11}":[
        "Enigmatic Ascending"
    ],
    "{0, 1, 4, 6, 8, 9}":[
        "Raga Hejjajji"
    ],
    "{0, 1, 4, 6, 9, 10}":[
        "Prometheus Neapolitan"
    ],
    "{0, 1, 4, 7, 10, 11}":[
        "Mela Divamani"
    ],
    "{0, 1, 4, 7, 10}":[
        "Raga Manaranjani"
    ],
    "{0, 1, 4, 7, 8, 10, 11}":[
        "Greek Neveseri"
    ],
    "{0, 1, 4, 7, 8, 9}":[
        "Mela Gavambohdi"
    ],
    "{0, 1, 4, 7, 9}":[
        "Messiaen Truncated 2"
    ],
    "{0, 1, 4, 7}":[
        "Japanese Pentachord"
    ],
    "{0, 1, 5, 6, 10}":[
        "Iwato Japan"
    ],
    "{0, 1, 5, 6, 7, 11}":[
        "Messiaen Mode 5"
    ],
    "{0, 1, 5, 6, 8, 9, 10}":[
        "Gipsy Hexatonic, Raga Ka"
    ],
    "{0, 1, 5, 7, 10}":[
        "Kokin-Joshi, Soft Ascend J"
    ],
    "{0, 1, 5, 7, 11}":[
        "Raga Gauri"
    ],
    "{0, 1, 5, 7, 8, 10}":[
        "Raga Phenadyuti"
    ],
    "{0, 1, 5, 7, 8, 11}":[
        "Raga Padi"
    ],
    "{0, 1, 5, 7, 8, 9}":[
        "Raga Kalakanthi"
    ],
    "{0, 1, 5, 7, 8}":[
        "Japanese, Sakura Pentato"
    ],
    "{0, 1, 5, 7, 9, 10}":[
        "Raga Rasavali"
    ],
    "{0, 1, 5, 7, 9, 11}":[
        "Raga Jivantika"
    ],
    "{0, 1, 5, 7, 9}":[
        "Altered Pentatonic"
    ],
    "{0, 1, 5, 8, 11}":[
        "Raga Kshanika"
    ],
    "{0, 1, 5, 8}":[
        "Raga Lavangi)"
    ],
    "{0, 1, 6, 7, 11}":[
        "Raga Multani"
    ],
    "{0, 1, 7, 8, 11}":[
        "Raga Deshgaur"
    ],
    "{0, 1}":[
        "Sharp one interval"
    ],
    "{0, 2, 10, 3}":[
        "Warao Minor Trichord"
    ],
    "{0, 11, 4, 6}":[
        "Raga Nigamagamini"
    ],
    "{0, 2, 10, 5}":[
        "Major add 9 e.g. Bb add9"
    ],
    "{0, 2, 11, 6}":[
        "Raga Sumukam"
    ],
    "{0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}":[
        "All except C# - 1#"
    ],
    "{0, 2, 3, 4, 5, 6, 7, 8, 9, 11}":[
        "Pan Lydian"
    ],
    "{0, 2, 3, 4, 5, 6, 7, 9, 10}":[
        "Blues Enneatonic"
    ],
    "{0, 2, 3, 4, 5, 7, 9, 10, 11}":[
        "Raga Ramdasi Malhar"
    ],
    "{0, 2, 3, 4, 6, 7, 8, 9, 11}":[
        "Nine Tone"
    ],
    "{0, 2, 3, 4, 6, 7, 9, 10}":[
        "Lydian Dim b7"
    ],
    "{0, 2, 3, 4, 6, 7, 9, 11}":[
        "Lydian b3"
    ],
    "{0, 2, 3, 4, 7, 8, 9}":[
        "Chromatic Hypodorian"
    ],
    "{0, 2, 3, 5, 6, 7, 10}":[
        "Blues Modified"
    ],
    "{0, 2, 3, 5, 6, 7, 8, 11}":[
        "Algerian"
    ],
    "{0, 2, 3, 5, 6, 7, 9, 10}":[
        "Blues Octatonic"
    ],
    "{0, 2, 3, 5, 6, 8, 11}":[
        "Locrian 2"
    ],
    "{0, 2, 3, 5, 6, 9, 10}":[
        "Dorian b5"
    ],
    "{0, 2, 3, 5, 6, 9}":[
        "Pyramid Hexatonic"
    ],
    "{0, 2, 3, 5, 7, 10, 11}":[
        "Mela Varunapriya"
    ],
    "{0, 2, 3, 5, 7, 11}":[
        "Raga Sindhura Kafi"
    ],
    "{0, 2, 3, 5, 7, 8, 9, 10}":[
        "Dorian Aeolian"
    ],
    "{0, 2, 3, 5, 7, 8, 9}":[
        "Mela Jhankaradhvani"
    ],
    "{0, 2, 3, 5, 7, 9}":[
        "Raga Suddha Bangala"
    ],
    "{0, 2, 3, 5, 8, 10}":[
        "Raga Bagesri"
    ],
    "{0, 2, 3, 5, 8, 11}":[
        "Raga Ghantana"
    ],
    "{0, 2, 3, 5, 8}":[
        "Raga Audva Tukhari"
    ],
    "{0, 2, 3, 5, 9, 10}":[
        "Raga Bagesri, Sriranjani"
    ],
    "{0, 2, 3, 5}":[
        "Dorian Tetrachord"
    ],
    "{0, 2, 3, 6, 7, 10}":[
        "Raga Simharava"
    ],
    "{0, 2, 3, 6, 7, 11}":[
        "Raga Amarasenapriya"
    ],
    "{0, 2, 3, 6, 7, 8, 10, 11}":[
        "Minor Gypsy"
    ],
    "{0, 2, 3, 6, 7, 8, 11}":[
        "Hungarian Minor"
    ],
    "{0, 2, 3, 6, 7, 8, 9, 10}":[
        "Raga Cintamani"
    ],
    "{0, 2, 3, 6, 7, 8, 9}":[
        "Mela Syamalangi"
    ],
    "{0, 2, 3, 6, 7, 8}":[
        "Raga Syamalam"
    ],
    "{0, 2, 3, 6, 7, 9, 10}":[
        "Romanian, Gnossiennes"
    ],
    "{0, 2, 3, 6, 7, 9}":[
        "Raga Vijayanagari"
    ],
    "{0, 2, 3, 6, 8, 10}":[
        "Takemitsu Tree Line Mod"
    ],
    "{0, 2, 3, 6, 8, 11}":[
        "Takemitsu Tree Line Mod"
    ],
    "{0, 2, 3, 6, 8, 9}":[
        "Raga Neelangi"
    ],
    "{0, 2, 3, 6, 9, 11}":[
        "Raga Ranjani, Rangini"
    ],
    "{0, 2, 3, 6}":[
        "Harmonic Minor Tetrachor"
    ],
    "{0, 2, 3, 7, 8, 10}":[
        "Raga Trimurti"
    ],
    "{0, 2, 3, 7, 8}":[
        "Hirajoshi Japan"
    ],
    "{0, 2, 3, 7, 9, 10}":[
        "Raga Manavi"
    ],
    "{0, 2, 3, 7, 9, 11}":[
        "Hawaiian"
    ],
    "{0, 2, 3, 7, 9}":[
        "Dorian Pentatonic, Kumoi"
    ],
    "{0, 2, 3}":[
        "Minor Trichord"
    ],
    "{0, 2, 4, 5, 6, 7}":[
        "Raga Dipak"
    ],
    "{0, 2, 4, 5, 6, 9, 10}":[
        "Mixolydian b5"
    ],
    "{0, 2, 4, 5, 7, 10, 11}":[
        "Mela Nagananadini"
    ],
    "{0, 2, 4, 5, 7, 8, 9, 10, 11}":[
        "Raga Pahadi"
    ],
    "{0, 2, 4, 5, 7}":[
        "Major Pentachord"
    ],
    "{0, 2, 4, 5, 8, 10, 11}":[
        "Raga Ragesri"
    ],
    "{0, 2, 4, 5, 8, 10}":[
        "Raga Nattaikurinji"
    ],
    "{0, 2, 4, 5, 8, 9, 10}":[
        "Mixolydian Augmented"
    ],
    "{0, 2, 4, 5, 9, 10, 11}":[
        "Raga Ragesri"
    ],
    "{0, 2, 4, 5, 9, 10}":[
        "Raga Rageshri, Nattaikuri"
    ],
    "{0, 2, 4, 5, 9, 11}":[
        "Raga Hamsa Vinodini"
    ],
    "{0, 2, 4, 5}":[
        "Major Tetrachord"
    ],
    "{0, 2, 4, 6, 11}":[
        "Raga Kumurdaki"
    ],
    "{0, 2, 4, 6, 7, 10, 11}":[
        "Mela Citrambari"
    ],
    "{0, 2, 4, 6, 7, 10}":[
        "Raga Caturangini"
    ],
    "{0, 2, 4, 6, 7, 11}":[
        "Raga Caturangini"
    ],
    "{0, 2, 4, 6, 7, 8, 9}":[
        "Mela Kantamani"
    ],
    "{0, 2, 4, 6, 7, 9, 10, 11}":[
        "Lydian Dominant + natura"
    ],
    "{0, 2, 4, 6, 7, 9}":[
        "Raga Yamuna Kalyani"
    ],
    "{0, 2, 4, 6, 7}":[
        "Lydian Pentachord"
    ],
    "{0, 2, 4, 6, 8, 10, 11}":[
        "Leading Whole-Tone"
    ],
    "{0, 2, 4, 6, 8, 9}":[
        "Eskimo Hexatonic 2"
    ],
    "{0, 2, 4, 6, 9, 11}":[
        "Raga Mrunganandana"
    ],
    "{0, 2, 4, 6, 9}":[
        "Kung"
    ],
    "{0, 2, 4, 6}":[
        "Whole-Tone Tetramirror"
    ],
    "{0, 2, 4, 7, 10, 11}":[
        "Mela Nitimati"
    ],
    "{0, 2, 4, 7, 11}":[
        "Raga Hamsadhvani"
    ],
    "{0, 2, 4, 7, 8, 9, 10}":[
        "Raga Cintamani"
    ],
    "{0, 2, 4}":[
        "Do Re Mi"
    ],
    "{0, 2, 5, 6, 7, 10}":[
        "Messiaen Mode 5"
    ],
    "{0, 2, 5, 7, 10, 11}":[
        "Raga Megh"
    ],
    "{0, 2, 5, 7, 11}":[
        "Raga Desh"
    ],
    "{0, 2, 5, 7, 8, 9}":[
        "Raga Kalakanthi"
    ],
    "{0, 2, 5, 7, 9, 10, 11}":[
        "Raga Sorati"
    ],
    "{0, 2, 5, 7}":[
        "Major Suspended 4th Cho"
    ],
    "{0, 2, 5, 9, 10}":[
        "Oriental Raga Guhamano"
    ],
    "{0, 2, 5, 9, 11}":[
        "Raga Rasranjani"
    ],
    "{0, 2, 6, 7, 10, 11}":[
        "Raga Malarani"
    ],
    "{0, 2, 6, 7, 10}":[
        "Raga Vaijayanti"
    ],
    "{0, 2, 6, 7, 11}":[
        "Raga Vaijayanti"
    ],
    "{0, 2, 6, 7, 8, 10}":[
        "Raga Jaganmohanam"
    ],
    "{0, 2, 6, 7, 9, 10}":[
        "Raga Sarasvati"
    ],
    "{0, 2, 6, 7, 9, 11}":[
        "Raga Nishadi"
    ],
    "{0, 2, 6, 7, 9}":[
        "Raga Shri Kalyan"
    ],
    "{0, 2, 6, 9, 11}":[
        "Raga Shubravarni"
    ],
    "{0, 2, 6}":[
        "Chord sus2"
    ],
    "{0, 2, 7, 9, 10}":[
        "Raga Matha Kokila"
    ],
    "{0, 2}":[
        "Do Re Wholetone or Larg"
    ],
    "{0, 3, 4, 5, 6, 8, 10}":[
        "Spanish Heptatonic"
    ],
    "{0, 3, 4, 5, 7, 10}":[
        "Raga Bhanumanjari"
    ],
    "{0, 3, 4, 5, 7, 8, 10}":[
        "Mela Ragavardhani"
    ],
    "{0, 3, 4, 5, 7, 8, 11}":[
        "Mela Gangeyabhusani"
    ],
    "{0, 3, 4, 5, 7, 8, 9}":[
        "Mela Yagapriya"
    ],
    "{0, 3, 4, 5, 9, 11}":[
        "Messiaen Mode 2"
    ],
    "{0, 3, 4, 6, 7, 10, 11}":[
        "Mela Rasikapriya"
    ],
    "{0, 3, 4, 6, 7, 10}":[
        "Raga Rasamanjari"
    ],
    "{0, 3, 4, 6, 7, 11}":[
        "Raga Rasamanjari"
    ],
    "{0, 3, 4, 6, 7, 8, 10}":[
        "Mela Jhotisvarupini"
    ],
    "{0, 3, 4, 6, 7, 8, 11}":[
        "Mela Dhatuvardhani"
    ],
    "{0, 3, 4, 6, 8, 11}":[
        "Augmented"
    ],
    "{0, 3, 4, 6, 8, 9, 11}":[
        "Aeolian Flat b3 b5 b6"
    ],
    "{0, 3, 4, 7, 8, 11}":[
        "Augmented, Messiaen Tr"
    ],
    "{0, 3, 4, 7, 9}":[
        "Raga Mohanangi"
    ],
    "{0, 3, 5, 6, 10}":[
        "Raga Jayakauns"
    ],
    "{0, 3, 5, 6, 7, 11}":[
        "Blues Minor Maj7"
    ],
    "{0, 3, 5, 6, 7, 9, 10}":[
        "Blues Heptatonic"
    ],
    "{0, 3, 5, 6, 9, 11}":[
        "Messiaen Mode 2-2"
    ],
    "{0, 3, 5, 7, 8, 9}":[
        "Raga Saravati"
    ],
    "{0, 3, 5, 7, 9, 10, 11}":[
        "Raga Madhuri"
    ],
    "{0, 3, 5, 7, 9, 11}":[
        "Genus Secundum"
    ],
    "{0, 3, 5, 9, 10}":[
        "Raga Chandrakauns Kafi,"
    ],
    "{0, 3, 6, 10, 11}":[
        "Half Diminished plus b8"
    ],
    "{0, 3, 6, 7, 10, 11}":[
        "Raga Jivantini, Gaurikriya"
    ],
    "{0, 3, 6, 7, 10}":[
        "Raga Samudhra Priya"
    ],
    "{0, 3, 6, 7, 11}":[
        "Raga Multani?"
    ],
    "{0, 3, 6, 7, 9, 10}":[
        "Raga Madhakauns"
    ],
    "{0, 3, 6}":[
        "Diminished Chord"
    ],
    "{0, 3, 7, 8, 10}":[
        "Raga Shailaja"
    ],
    "{0, 3, 7}":[
        "Minor Triad e.g. Cm"
    ],
    "{0, 4, 5, 6, 10, 11}":[
        "Messiaen Mode 5 Inverse"
    ],
    "{0, 4, 5, 7, 10, 11}":[
        "Raga Tilang, Savitri"
    ],
    "{0, 4, 5, 7, 11}":[
        "Ionian Pentatonic Raga G"
    ],
    "{0, 4, 5, 7, 8, 10}":[
        "Raga Kamalamanohari (I"
    ],
    "{0, 4, 5, 7, 8, 11}":[
        "Raga Paraju Simhavahin"
    ],
    "{0, 4, 5, 7, 8}":[
        "Raga Zilaf,"
    ],
    "{0, 4, 5, 7, 9, 10}":[
        "Raga Khamas, Baduhari"
    ],
    "{0, 4, 5, 7, 9, 11}":[
        "Genus Secundum"
    ],
    "{0, 4, 5, 7, 9}":[
        "Raga Mand"
    ],
    "{0, 4, 5, 8, 11}":[
        "Romanian Bacovia"
    ],
    "{0, 4, 5, 9, 10}":[
        "Raga Khamaji Durga"
    ],
    "{0, 4, 5, 9, 11}":[
        "Raga Bhinna Shadja, Hin"
    ],
    "{0, 4, 6, 7, 10, 11}":[
        "Raga Vijayavasanta"
    ],
    "{0, 4, 6, 7, 11}":[
        "Raga Malashri & C"
    ],
    "{0, 4, 6, 7, 8, 10}":[
        "Raga Jyoti"
    ],
    "{0, 4, 6, 7, 9}":[
        "Raga Dhavalashri"
    ],
    "{0, 4, 6, 9, 11}":[
        "Raga Hindol"
    ],
    "{0, 4, 6}":[
        "Chord -5 (b5)"
    ],
    "{0, 4, 7, 10, 11}":[
        "Raga Jivantini"
    ],
    "{0, 4}":[
        "Major Third Interval"
    ],
    "{0, 5, 7, 8, 11}":[
        "Raga Devaranjani"
    ],
    "{0, 5}":[
        "Fourth"
    ],
    "{0, 6, 7}":[
        "Raga Ongkari"
    ],
    "{0, 8, 10, 3}":[
        "Major add 9 e.g. Ab add9"
    ],
    "{0, 8, 10, 4}":[
        "Chord 7+5"
    ],
    "{0, 8, 11, 4}":[
        "Chord M7+5"
    ],
    "{0, 8, 3, 6}":[
        "Major Dominant b7 Chord"
    ],
    "{0, 8, 3}":[
        "Major Triad e.g. Ab"
    ],
    "{0, 8, 4, 7}":[
        "Major Dominant b7"
    ],
    "{0, 8, 5}":[
        "Minor Triad e.g. Fm"
    ],
    "{0, 9, 2, 5}":[
        "Minor 7th e.g. Dm7 = F6"
    ],
    "{0, 9, 4}":[
        "Minor Triad e.g. Am Raga"
    ],
    "{0, 9, 5, 7}":[
        "Major add 9 e.g. F add9"
    ],
    "{0, 9, 5}":[
        "Major Triad e.g. F"
    ],
    "{0, 9}":[
        "Major Sixth Interval"
    ],
    "{0}":[
        "Unison"
    ]
}
```

## Заметки.md

```markdown
## lib/style_reference
  - Сделать инпуты как в harmonics.

## lib/generate_modes
  - Проверить, как оно проверяет консонантность. Для всего строя, или по отношению к новой ноте
  - Проверить, как работает с ограничением глубины.

## 2 Harmonic Series
  - Стабилизировано

## 3 Entropy
  - Разобраться с предустановками, например сглаживание нужно побольше а ширина полосы поменьше (а при bandwidth=1 график пропадает)
  - Новый интерфейс

## 5 Urmavi scale
  - Попробовать с умбральной гармонией (LCM+GCD)
  - Добавить все методы консонанса
  - Четвертьтоны обрабатывать отдельно, они не должны схлопываться до *реальных* полутонов
  - Скрытие неактивных подписей и выделение активных
  - Подписи сделать чуть пониже, не матчатся с кривыми

## 6 Circle of Fifth 
  - Обновить интерфейс, возможно звук

## 6 Tonnezt
  - Сделать нормальный интерфейс
  - Починить тормоза
  - Переделать на JI-соотношения и звук (два режима)

## 8 JI keyboard
  - Добавить динамику
  - Исправить проигрывание миди (оно точно сломано?)
  - Причесать параметры по умолчанию и интерфейс.

## 9 Polyundertonality
  - Переписать на новую логику Umbral Harmony.
  - Конфликтует задание параметров в инпутах (должно быть главным) и в строчке `p: { pool:32, limit:45, cons:0.35, meth:'murzin', view:'local', freq:261.6, oct:{} },`
  - Для баса и якоря сделать визуализацию теоретически рассчитанной частоты и нормализованной.
  - Заглушить обертоны для высоких якорей, или делать нормализацию, или изменить звук. Можно просто делать бас на октаву-две ниже тонального звука, а якорь - выше.
  - Переделать интерфейс
```

