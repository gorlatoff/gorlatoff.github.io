<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Интерактивный график гармонической энтропии с аудио</title>
  <style>
    :root {
      --bg-color: #121212;
      --surface-color: #1E1E1E;
      --primary-color: #BB86FC;
      --secondary-color: #03DAC6;
      --text-primary: rgba(255,255,255,0.87);
      --text-secondary: rgba(255,255,255,0.6);
      --surface-overlay: rgba(255,255,255,0.05);
      --border-color: rgba(255,255,255,0.1);
    }
    body {
      background: var(--bg-color);
      color: var(--text-primary);
      font-family: 'Roboto', sans-serif;
      margin: 0;
      padding: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    /* Общий контейнер графика и панели */
    #appContainer {
      width: 90%;
      max-width: 1000px;
      display: flex; /* Use flexbox for better layout control */
      flex-direction: column;
      height: 80vh; /* Example height, adjust as needed */
    }
    /* Область для графика HE (и для взаимодействия с аудио) */
    #HEPlotDiv {
      position: relative; /* Needed for absolute positioning of canvas? Maybe not needed */
      flex-grow: 1; /* Allow the plot div to grow and fill available space */
      width: 100%;
      /* height: 50vh; Remove fixed height, let flexbox handle it */
      border-radius: 8px;
      overflow: hidden; /* Important: canvas should not overflow */
      background: var(--surface-color);
      padding: 0; /* Remove padding here, handle padding inside ChartRenderer */
      box-sizing: border-box;
      cursor: pointer; /* Указываем, что область графика интерактивна для аудио */
      display: flex; /* Ensure canvas can fill this container */
    }
    #heChart {
      display: block; /* Remove extra space below canvas */
      width: 100%; /* Make canvas fill the container width */
      height: 100%; /* Make canvas fill the container height */
    }
    /* Панель управления – общая для HE и аудио */
    #controls {
      background: var(--surface-color);
      border-radius: 12px;
      padding: 16px 24px;
      margin: 20px 0 0 0; /* Adjust margin */
      width: 100%;
      box-shadow: 0 4px 12px rgba(0,0,0,0.25);
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
      flex-shrink: 0; /* Prevent controls from shrinking */
      box-sizing: border-box; /* Include padding in width */
    }
    .controls-column-left,
    .controls-column-right {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .controlrow {
      display: grid;
      grid-template-columns: 0.8fr 2fr;
      align-items: center;
      gap: 12px;
    }
    .label {
      color: var(--text-secondary);
      font-size: 14px;
      text-align: right;
      padding-right: 8px;
    }
    .input-group {
      display: flex;
      align-items: center;
      flex: 1;
      max-width: 180px;
    }
    .textinput {
      background: var(--surface-overlay);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
      padding: 12px;
      border-radius: 8px;
      font-size: 14px;
      width: 100%;
      height: 44px;
      box-sizing: border-box;
      transition: all 0.3s ease;
    }
    .textinput:focus {
      border-color: var(--primary-color);
      outline: none;
      box-shadow: 0 0 0 2px rgba(187,134,252,0.2);
    }
    .stepper-button {
      background: var(--surface-color);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      width: 32px;
      height: 44px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .stepper-button:hover {
      background-color: var(--surface-overlay);
      border-color: var(--primary-color);
    }
    .slider-container {
      height: 44px;
      display: flex;
      align-items: center;
      min-width: 180px;
      width: 100%;
    }
    .slider {
      -webkit-appearance: none;
      width: 100%;
      height: 2px;
      background: var(--border-color);
      border-radius: 1px;
      outline: none;
      padding: 0;
    }
    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      background: var(--primary-color);
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.2s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .slider::-webkit-slider-thumb:hover {
      transform: scale(1.1);
    }
    .slider::-webkit-slider-thumb:active {
      transform: scale(0.95);
    }
    @media (max-width: 600px) {
      #appContainer {
          height: 70vh; /* Adjust height for smaller screens */
      }
      #controls {
        grid-template-columns: 1fr;
        padding: 12px 16px;
        gap: 16px;
      }
      .controlrow {
        grid-template-columns: 1fr 2fr;
        gap: 8px;
      }
      .label {
        font-size: 13px;
        padding-right: 4px;
      }
      .input-group,
      .slider-container {
        max-width: none;
      }
      .textinput,
      .stepper-button {
        height: 48px;
      }
    }
      /* Add cursor style for dragging */
      body.dragging, body.dragging * { cursor: grabbing !important; }
  </style>
</head>
<body>
  <div id="appContainer">
    <!-- График HE + область для интерактивного управления аудио -->
    <div id="HEPlotDiv">
      <canvas id="heChart"></canvas>
    </div>
    <!-- Панель управления (общая для графика и аудио) -->
    <div id="controls">
      <div class="controls-column-left">
        <div class="controlrow">
          <span class="label">N:</span>
          <div class="input-group">
            <input id="textN" type="number" class="textinput" value="3000" placeholder="Maximum ratio (N)" />
          </div>
        </div>
        <div class="controlrow">
          <span class="label">Min cents:</span>
          <div class="input-group">
            <button class="stepper-button minus" data-target="textmin">-</button>
            <input id="textmin" type="number" class="textinput" value="0" placeholder="Min (octaves)" step="1" />
            <button class="stepper-button plus" data-target="textmin">+</button>
          </div>
        </div>
        <div class="controlrow">
          <span class="label">Max cents:</span>
          <div class="input-group">
            <button class="stepper-button minus" data-target="textmax">-</button>
            <input id="textmax" type="number" class="textinput" value="1" placeholder="Max (octaves)" step="1" />
            <button class="stepper-button plus" data-target="textmax">+</button>
          </div>
        </div>
      </div>
      <div class="controls-column-right">
        <div class="controlrow">
          <span class="label" id="aval">Bandwidth (a): 2.4</span>
          <div class="slider-container">
            <input type="range" id="slidera" class="slider" min="1" max="4" step="0.001" value="2.4" />
          </div>
        </div>
        <div class="controlrow">
          <span class="label" id="sval">Smoothing (s): 1.25%</span>
          <div class="slider-container">
            <input type="range" id="sliders" class="slider" min="0.5" max="2.1" step="0.001" value="1.25" />
          </div>
        </div>
        <!-- Контрол для задержки нот -->
        <div class="controlrow">
           <span class="label" id="noteDelayLabel">Note Delay: 0.15s</span>
          <div class="slider-container">
            <input type="range" id="noteDelay" class="slider" min="0" max="0.3" step="0.0001" value="0.15" />
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    /* =================================
         КЛАССЫ ДЛЯ ГРАФИКА HE
       ================================= */
    class HarmonicEntropyCalculator {
      static instance = null;
      constructor() {
        if (HarmonicEntropyCalculator.instance) { return HarmonicEntropyCalculator.instance; }
        this.ratios = [];
        this.oldN = null;
        HarmonicEntropyCalculator.instance = this;
      }
      filterRatios() {
        const tolerance = 10;
        let ratioObjs = this.ratios.map(ratio => {
          const [p, q] = ratio;
          const cent = 1200 * HarmonicEntropyCalculator.log2(p / q);
          const consonance = (1 / p) + (1 / q);
          return { p, q, cent, consonance };
        });
        ratioObjs.sort((a, b) => b.consonance - a.consonance);
        const selected = [];
        for (const r of ratioObjs) {
          if (!selected.some(s => Math.abs(s.cent - r.cent) < tolerance)) {
            selected.push(r);
          }
        }
        selected.sort((a, b) => a.cent - b.cent);
        this.ratios = selected.map(r => [r.p, r.q]);
      }
      findLocalMinima(HE, threshold = 0.005) {
        const maxima = [];
        for (let i = 6; i < HE.length - 6; i++) {
          const dyPrev = HE[i].y - HE[i - 6].y;
          const dyNext = HE[i + 6].y - HE[i].y;
          if (dyPrev > threshold && dyNext < -threshold) {
            maxima.push({ x: HE[i].x, y: HE[i].y, strength: Math.abs(dyPrev) + Math.abs(dyNext) });
          }
        }
        return maxima.sort((a, b) => b.strength - a.strength);
      }
      findClosestHEPoint(HE, cent) {
        let low = 0, high = HE.length - 1, mid;
        while (low <= high) {
          mid = Math.floor((low + high) / 2);
          if (HE[mid].x < cent) { low = mid + 1; }
          else if (HE[mid].x > cent) { high = mid - 1; }
          else { return HE[mid]; }
        }
        if (high < 0) return HE[0];
        if (low >= HE.length) return HE[HE.length - 1];
        return (Math.abs(HE[low].x - cent) < Math.abs(HE[high].x - cent)) ? HE[low] : HE[high];
      }
      findRatiosAtMinima(HE, minima) {
        const minimaXSet = new Set(minima.map(m => m.x));
        const ratiosToDisplay = [];
        for (const [p, q] of this.ratios) {
          const cent = 1200 * HarmonicEntropyCalculator.log2(p / q);
          const closestPoint = this.findClosestHEPoint(HE, cent);
          if (minimaXSet.has(closestPoint.x)) {
            ratiosToDisplay.push({ x: cent, y: closestPoint.y, label: `${p}/${q}` });
          }
        }
        return ratiosToDisplay;
      }
      static log2(x) { return Math.log(x) / Math.log(2); }
      static gcd(x, y) { while (y !== 0) { [x, y] = [y, x % y]; } return x; }
      convolve(olda, oldb) {
        const a = [...olda], b = [...oldb];
        const len = a.length;
        let minlen = 1;
        while (minlen < len) minlen *= 2;
        a.push(...new Array(minlen - len).fill(0));
        b.push(...new Array(minlen - len).fill(0));
        const f_a = new FFT(minlen), f_b = new FFT(minlen);
        f_a.forward(a); f_b.forward(b);
        const real = new Array(minlen), imag = new Array(minlen);
        for (let i = 0; i < minlen; i++) {
          real[i] = f_a.real[i] * f_b.real[i] - f_a.imag[i] * f_b.imag[i];
          imag[i] = f_a.real[i] * f_b.imag[i] + f_a.imag[i] * f_b.real[i];
        }
        const f_out = new FFT(minlen);
        f_out.real = real; f_out.imag = imag;
        const result = f_out.inverse();
        return result.slice(0, len);
      }
      calculateHarmonicEntropy(HEinfo) {
        const { a, s, mincents, maxcents } = HEinfo;
        const scents = 1200 * HarmonicEntropyCalculator.log2(s + 1);
        const padding = Math.round(3 * scents);
        const min = mincents - padding;
        const max = maxcents + padding;
        const res = 1;
        const alpha = a === 1 ? 1.001 : a;
        const arraySize = Math.floor((max - min) / res) + 1;
        if (arraySize > 1000000) {
          console.error("Array size too large, aborting calculation");
          return [];
        }
        const k = new Array(arraySize).fill(0);
        const ak = new Array(arraySize).fill(0);
        for (const ratio of this.ratios) {
          const rcent = 1200 * HarmonicEntropyCalculator.log2(ratio[0] / ratio[1]);
          if (rcent < min || rcent > max) continue;
          const rcompl = Math.sqrt(ratio[0] * ratio[1]);
          if (rcent === Math.round(rcent)) {
            const index = Math.floor((rcent - min) / res);
            k[index] += 1 / rcompl;
            ak[index] += 1 / Math.pow(rcompl, alpha);
          } else {
            const clow = Math.ceil(rcent) - rcent;
            const chigh = rcent - Math.floor(rcent);
            const index = Math.floor((rcent - min) / res);
            k[index] += (1 / rcompl) * clow;
            k[index + 1] += (1 / rcompl) * chigh;
            ak[index] += (1 / Math.pow(rcompl, alpha)) * clow;
            ak[index + 1] += (1 / Math.pow(rcompl, alpha)) * chigh;
          }
        }
        let minlen = 1;
        while (minlen < 2 * k.length) minlen *= 2;
        k.push(...new Array(minlen - k.length).fill(0));
        ak.push(...new Array(minlen - ak.length).fill(0));
        const g = new Array(minlen), ag = new Array(minlen);
        let g_sum = 0;
        for (let i = 0; i < minlen; i++) {
          const c = i * res + min;
          const gval = (1 / (scents * 2 * Math.PI)) * (
            Math.exp(-((c - min) ** 2) / (2 * scents * scents)) +
            Math.exp(-((c - (minlen * res + min)) ** 2) / (2 * scents * scents))
          );
          g[i] = gval; g_sum += gval;
        }
        for (let i = 0; i < g.length; i++) {
          g[i] /= g_sum;
          ag[i] = Math.pow(g[i], alpha);
        }
        const ent = this.convolve(ak, ag);
        const nrm = this.convolve(k, g);
        const paddingPoints = padding / res;
        const result = [];
        const epsilon = 1e-10;
        for (let i = arraySize - paddingPoints - 1; i >= paddingPoints; i--) {
          const x = i * res + min;
          const entVal = ent[i] + epsilon;
          const nrmVal = nrm[i] + epsilon;
          const y = (1 / (1 - alpha)) * Math.log(entVal / Math.pow(nrmVal, alpha));
          result[i - paddingPoints] = { x: x, y: -y };
        }
        HEinfo.res = 1;
        return result;
      }
      preCalcRatios(HEinfo) {
        if (HEinfo.N !== this.oldN) {
          this.ratios = [];
          this.oldN = HEinfo.N;
          let n = HEinfo.N;
          const processRatios = () => {
            if (n > 0) {
              const start = performance.now();
              do {
                for (let i = 1; i <= Math.floor(Math.sqrt(n)); i++) {
                  if (n % i === 0 && HarmonicEntropyCalculator.gcd(i, n / i) === 1) {
                    this.ratios.push([i, n / i]);
                    if (n / i !== i) this.ratios.push([n / i, i]);
                  }
                }
              } while (--n >= 0 && performance.now() - start < 50);
              requestAnimationFrame(processRatios);
            } else {
              this.filterRatios();
              setTimeout(() => this.plotHE(HEinfo), 1);
            }
          };
          setTimeout(processRatios, 25);
        } else {
          this.plotHE(HEinfo);
        }
      }

      plotHE(HEinfo) {
        const HE = this.calculateHarmonicEntropy(HEinfo);
         if (!HE || HE.length === 0) {
             console.warn("No HE data to plot.");
             // Optionally clear the chart or show a message
             if (chartRenderer) {
                 chartRenderer.setData([]);
                 chartRenderer.setAnnotations([]);
             }
             return;
         }
        const minima = this.findLocalMinima(HE);
        const annotations = this.findRatiosAtMinima(HE, minima);
        const canvas = document.getElementById('heChart');
        if (!chartRenderer) {
            chartRenderer = new ChartRenderer(canvas);
        }
        chartRenderer.setData(HE);
        chartRenderer.setAnnotations(annotations);
        // Ensure note indicators are redrawn with the new data scale if needed
        chartRenderer.setNoteIndicators(activeNoteIndicators);
      }
    }

    class ChartRenderer {
        constructor(canvas, options = {}) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.data = [];
            this.annotations = [];
            this.options = {
                paddingTop: 20,
                paddingBottom: 30, // Increased for X labels
                paddingLeft: 40,   // Increased for Y labels
                paddingRight: 20,
                gridColor: 'rgba(255,255,255,0.05)',
                textColor: 'rgba(255,255,255,0.6)',
                annotationColor: '#BB86FC',
                lineColor: '#FFFFFF',
                lineWidth: 1.5,
                noteIndicatorColor1: 'rgba(30, 144, 255, 1)',
                noteIndicatorColor2: 'rgba(255, 100, 0, 1)',
                ...options
            };
            this.currentView = { xMin: 0, xMax: 1200, yMin: 0, yMax: 1 };
            this.noteIndicators = [];
            this.isDrawing = false;
            this.drawRequestScheduled = false;

            this.resizeObserver = new ResizeObserver(entries => {
                 const entry = entries[0];
                 if (entry && entry.contentRect) {
                      this.requestDraw(); // Schedule a draw on resize
                 }
            });

             if (this.canvas.parentElement) {
                this.resizeObserver.observe(this.canvas.parentElement);
             } else {
                 console.error("Canvas parent element not found for ResizeObserver.");
             }

            // Initial resize and draw call
            this.resizeAndDraw(); // <<< This line requires the method below
        }

        // **** ADD THIS METHOD ****
        resizeAndDraw() {
            // Ensures the canvas bitmap is sized correctly based on its container
            this.resizeCanvas();
            // Performs the actual drawing operation onto the correctly sized canvas
            this.draw();
        }
        // **** END OF ADDED METHOD ****


        setAnnotations(annotations) {
            this.annotations = annotations;
            this.requestDraw();
        }

        setNoteIndicators(indicators) {
            this.noteIndicators = indicators;
            // No direct draw needed here, draw() will use the latest state.
            // If indicators need immediate redraw without other triggers, call requestDraw().
        }

        resizeCanvas() {
            const parent = this.canvas.parentElement;
            if (!parent) return false;

            const cssWidth = parent.clientWidth;
            const cssHeight = parent.clientHeight;

            if (cssWidth === 0 || cssHeight === 0) {
                // Canvas is likely hidden or container has no size yet
                if (this.canvas.width !== 0 || this.canvas.height !== 0) {
                     // If it previously had size, clear it
                     this.canvas.width = 0;
                     this.canvas.height = 0;
                     return true; // Indicate change happened (to zero size)
                }
                return false; // Already zero size
            }

            // Check if canvas bitmap size needs update (match CSS size exactly)
            if (this.canvas.width !== cssWidth || this.canvas.height !== cssHeight) {
                this.canvas.width = cssWidth;
                this.canvas.height = cssHeight;
                // No need to set style width/height if using CSS w:100%/h:100%
                this.ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform (important!)
                return true; // Indicate resize happened
            }
            return false; // No resize needed
        }

        setData(data) {
            this.data = data;
            this.autoScale();
            this.requestDraw();
        }

        autoScale() {
            if (this.data.length === 0) {
                this.currentView = { xMin: 0, xMax: 1200, yMin: 0, yMax: 1 };
                return;
            }
            let xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity;
            this.data.forEach(point => {
                if (!Number.isFinite(point.x) || !Number.isFinite(point.y)) return;
                xMin = Math.min(xMin, point.x);
                xMax = Math.max(xMax, point.x);
                yMin = Math.min(yMin, point.y);
                yMax = Math.max(yMax, point.y);
            });

             if (xMin === Infinity) {
                  this.currentView = { xMin: 0, xMax: 1200, yMin: 0, yMax: 1 };
                  return;
             }
             if (xMin === xMax) {
                 xMin -= 100;
                 xMax += 100;
             }
             if (yMin === yMax) {
                 yMin -= 0.5;
                 yMax += 0.5;
             }

            const xRange = xMax - xMin;
            const yRange = yMax - yMin;
            const xPadding = xRange * 0.01;
            const yPadding = yRange * 0.05;

            this.currentView.xMin = xMin - xPadding;
            this.currentView.xMax = xMax + xPadding;
            this.currentView.yMin = Math.floor((yMin - yPadding) * 10) / 10;
            this.currentView.yMax = Math.ceil((yMax + yPadding) * 10) / 10;
        }

        requestDraw() {
            if (!this.drawRequestScheduled) {
                this.drawRequestScheduled = true;
                requestAnimationFrame(() => {
                    this.draw();
                    this.drawRequestScheduled = false;
                });
            }
        }

        draw() {
            if (this.isDrawing) return;
            this.isDrawing = true;

            // Resize canvas bitmap if needed BEFORE drawing
            const resized = this.resizeCanvas();

            // If canvas has no size (e.g., hidden), stop drawing
             if (this.canvas.width === 0 || this.canvas.height === 0) {
                  this.isDrawing = false;
                  return;
             }

            const { ctx, options, canvas } = this;
            const { width: canvasWidth, height: canvasHeight } = canvas;

            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            const graphAreaX = options.paddingLeft;
            const graphAreaY = options.paddingTop;
            const graphAreaWidth = canvasWidth - options.paddingLeft - options.paddingRight;
            const graphAreaHeight = canvasHeight - options.paddingTop - options.paddingBottom;

            if (graphAreaWidth <= 0 || graphAreaHeight <= 0) {
                this.isDrawing = false;
                return;
            }

            const { xMin, xMax, yMin, yMax } = this.currentView;
            const xRange = xMax - xMin;
            const yRange = yMax - yMin;

            if (!xRange || !yRange || !Number.isFinite(xMin) || !Number.isFinite(xMax) || !Number.isFinite(yMin) || !Number.isFinite(yMax)) {
                console.error("Invalid view range for drawing:", this.currentView);
                this.isDrawing = false;
                return;
            }

            this.drawGrid(ctx, options, graphAreaX, graphAreaY, graphAreaWidth, graphAreaHeight, xMin, xMax, yMin, yMax);
            this.drawDataLine(ctx, options, graphAreaX, graphAreaY, graphAreaWidth, graphAreaHeight, xMin, xMax, yMin, yMax);
            this.drawAnnotations(ctx, options, graphAreaX, graphAreaY, graphAreaWidth, graphAreaHeight, xMin, xMax, yMin, yMax);
            this.drawNoteIndicators(ctx, options, graphAreaX, graphAreaY, graphAreaWidth, graphAreaHeight, xMin, xMax);

            this.isDrawing = false;
        }

        drawGrid(ctx, options, gx, gy, gw, gh, xMin, xMax, yMin, yMax) {
            ctx.lineWidth = 0.5;
            ctx.strokeStyle = options.gridColor;
            ctx.fillStyle = options.textColor;
            ctx.font = '10px Arial';

            const xRange = xMax - xMin;
            const yRange = yMax - yMin;

            // Vertical grid lines
            const xStep = 100;
            const startX = Math.ceil(xMin / xStep) * xStep;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            for (let x = startX; x <= xMax; x += xStep) {
                 if (x < xMin) continue;
                 const screenX = gx + (x - xMin) / xRange * gw;
                 if (!Number.isFinite(screenX)) continue;
                 const sharpX = Math.round(screenX);
                 if (sharpX >= gx && sharpX <= gx + gw) {
                    ctx.beginPath();
                    ctx.moveTo(sharpX, gy);
                    ctx.lineTo(sharpX, gy + gh);
                    ctx.stroke();
                    if (sharpX > gx + 10 && sharpX < gx + gw - 10) {
                        ctx.fillText(x.toFixed(0), sharpX, gy + gh + 4);
                    }
                 }
            }
             ctx.textAlign = 'left';
             ctx.fillText(xMin.toFixed(0), gx, gy + gh + 4);
             ctx.textAlign = 'right';
             ctx.fillText(xMax.toFixed(0), gx + gw, gy + gh + 4);

            // Horizontal grid lines
            const yTargetSteps = Math.max(3, Math.floor(gh / 40));
            const roughYStep = yRange / yTargetSteps;
            let yStep = roughYStep > 0 ? Math.pow(10, Math.floor(Math.log10(roughYStep))) : 0.1;
             const mult = yRange / (yStep * yTargetSteps);
             if (mult > 5) yStep *= 5;
             else if (mult > 2) yStep *= 2;

            const startY = Math.ceil(yMin / yStep) * yStep;
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            for (let y = startY; y <= yMax; y += yStep) {
                 if (y < yMin) continue;
                 const screenY = gy + gh - (y - yMin) / yRange * gh;
                 if (!Number.isFinite(screenY)) continue;
                 const sharpY = Math.round(screenY);
                 if (sharpY >= gy && sharpY <= gy + gh) {
                    ctx.beginPath();
                    ctx.moveTo(gx, sharpY);
                    ctx.lineTo(gx + gw, sharpY);
                    ctx.stroke();
                     if (sharpY > gy + 8 && sharpY < gy + gh - 8) {
                        ctx.fillText(y.toFixed(yStep < 0.1 ? 2 : (yStep < 1 ? 1 : 0)), gx - 5, sharpY);
                     }
                 }
            }
             ctx.textBaseline = 'bottom';
             ctx.fillText(yMin.toFixed(1), gx - 5, gy + gh);
             ctx.textBaseline = 'top';
             ctx.fillText(yMax.toFixed(1), gx - 5, gy);
        }

        drawDataLine(ctx, options, gx, gy, gw, gh, xMin, xMax, yMin, yMax) {
            if (this.data.length < 2) return;

            const xRange = xMax - xMin;
            const yRange = yMax - yMin;

            ctx.beginPath();
            let firstPointDrawn = false;
            for (const p of this.data) {
                if (p.x >= xMin && p.x <= xMax) {
                    const screenX = gx + (p.x - xMin) / xRange * gw;
                    const screenY = gy + gh - (p.y - yMin) / yRange * gh;

                    if (!Number.isFinite(screenX) || !Number.isFinite(screenY)) continue;
                    const clampedY = Math.max(gy, Math.min(gy + gh, screenY));

                    if (!firstPointDrawn) {
                        ctx.moveTo(screenX, clampedY);
                        firstPointDrawn = true;
                    } else {
                        ctx.lineTo(screenX, clampedY);
                    }
                } else if (firstPointDrawn && p.x > xMax) {
                    break;
                }
            }

            if (firstPointDrawn) {
                ctx.strokeStyle = options.lineColor;
                ctx.lineWidth = options.lineWidth;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.stroke();
            }
        }

        drawAnnotations(ctx, options, gx, gy, gw, gh, xMin, xMax, yMin, yMax) {
             if (this.annotations.length === 0) return;

             const xRange = xMax - xMin;
             const yRange = yMax - yMin;

             ctx.fillStyle = options.annotationColor;
             ctx.font = '11px Arial';
             ctx.textAlign = 'center';

             this.annotations.forEach(ann => {
                 if (ann.x >= xMin && ann.x <= xMax && ann.y >= yMin && ann.y <= yMax) {
                     const screenX = gx + (ann.x - xMin) / xRange * gw;
                     const screenY = gy + gh - (ann.y - yMin) / yRange * gh;

                     if (!Number.isFinite(screenX) || !Number.isFinite(screenY)) return;

                     ctx.beginPath();
                     ctx.arc(screenX, screenY, 4, 0, Math.PI * 2);
                     ctx.fill();

                     ctx.fillStyle = options.textColor;
                     ctx.textBaseline = 'top';
                     ctx.fillText(ann.label, screenX, screenY + 6);
                 }
             });
        }

        drawNoteIndicators(ctx, options, gx, gy, gw, gh, xMin, xMax) {
             if (this.noteIndicators.length === 0) return;

             const xRange = xMax - xMin;

             ctx.lineWidth = 2;
             ctx.setLineDash([4, 4]);

             this.noteIndicators.forEach(ind => {
                 if (ind.x === null || ind.x < xMin || ind.x > xMax || ind.opacity <= 0) return;

                 const screenX = gx + (ind.x - xMin) / xRange * gw;
                 if (!Number.isFinite(screenX)) return;

                 const baseColor = ind.noteIndex === 0 ? options.noteIndicatorColor1 : options.noteIndicatorColor2;
                 // Ensure baseColor is rgba format before replacing alpha
                 let colorWithAlpha = baseColor;
                 if (baseColor.startsWith('rgba')) {
                    colorWithAlpha = baseColor.replace(/[\d.]+\)$/, `${ind.opacity.toFixed(2)})`);
                 } else if (baseColor.startsWith('rgb')) {
                    colorWithAlpha = baseColor.replace('rgb', 'rgba').replace(')', `, ${ind.opacity.toFixed(2)})`);
                 }
                 // Add fallback if color format is unexpected (e.g., hex)
                 // else { colorWithAlpha = `rgba(some_default_rgb, ${ind.opacity.toFixed(2)})`; }


                 ctx.strokeStyle = colorWithAlpha;
                 ctx.beginPath();
                 ctx.moveTo(Math.round(screenX), gy);
                 ctx.lineTo(Math.round(screenX), gy + gh);
                 ctx.stroke();
             });

             ctx.setLineDash([]);
         }
    } // End of ChartRenderer class
    class FFT {
      constructor(size) {
        this.size = size;
        this.real = new Float32Array(size);
        this.imag = new Float32Array(size);
      }
      forward(input) {
        const n = this.size;
        this.real.set(input);
        this.imag.fill(0);
        this._transform(this.real, this.imag, n, 1);
      }
      inverse() {
        const n = this.size;
        this._transform(this.real, this.imag, n, -1);
        for (let i = 0; i < n; i++) {
          this.real[i] /= n;
          this.imag[i] /= n;
        }
        return Array.from(this.real);
      }
      _transform(real, imag, n, direction) {
        const nn = n === 1 ? 0 : Math.log2(n);
        if (Math.pow(2, nn) !== n) throw "Размер должен быть степенью двойки";
        for (let i = 0; i < n; i++) {
          const j = this._reverseBits(i, nn);
          if (j > i) {
            [real[i], real[j]] = [real[j], real[i]];
            [imag[i], imag[j]] = [imag[j], imag[i]];
          }
        }
        for (let s = 1; s <= nn; s++) {
          const m = 1 << s;
          const mh = m >> 1;
          for (let k = 0; k < n; k += m) {
            for (let j = 0; j < mh; j++) {
              const kr = k + j;
              const ki = kr + mh;
              const theta = direction * (-2 * Math.PI * j / m);
              const wr = Math.cos(theta);
              const wi = Math.sin(theta);
              const tr = real[ki] * wr - imag[ki] * wi;
              const ti = real[ki] * wi + imag[ki] * wr;
              real[ki] = real[kr] - tr;
              imag[ki] = imag[kr] - ti;
              real[kr] += tr;
              imag[kr] += ti;
            }
          }
        }
      }
      _reverseBits(x, bits) {
        let y = 0;
        for (let i = 0; i < bits; i++) {
          y = (y << 1) | (x & 1);
          x >>= 1;
        }
        return y;
      }
    }

    /* ================================
         АУДИО – интегрировано в область HEPlotDiv
       ================================ */
    let audioContext = null;
    let analysers = [null, null];
    let gainNodes = [null, null];
    let currentNote1 = null;
    let currentNote2 = null;
    const baseFrequency = 440;
    // const semitonesPerOctave = 12; // Not directly used here
    // const octaveRange = 2; // Not directly used here
    // const totalSemitones = semitonesPerOctave * octaveRange; // Not directly used here
    // const centsPerSemitone = 100; // Not directly used here
    // const totalCentsRange = totalSemitones * centsPerSemitone; // Not directly used here
    let isMouseDown = false;

    const audioParams = {
      oscillatorType: 'sawtooth',
      filterFrequency: 1000,
      filterType: 'lowpass',
      gainAttackTime: 0.05, // Slightly faster attack
      gainSustainLevel: 0.5,
      gainReleaseTime: 0.2,
    };

    // Вертикальные индикаторы звука
    let activeNoteIndicators = [
      { noteIndex: 0, x: null, opacity: 0 }, // Movable note
      { noteIndex: 1, x: 0, opacity: 0 }    // Tonic at 0 cents
    ];

    let reverbNode = null;
    let tonicTimeout = null; // Timer for delayed tonic note

    // Добавляем функцию для создания импульсного отклика ревербератора:
    function createImpulseResponse(context, duration, decay) {
      const sampleRate = context.sampleRate;
      const length = sampleRate * duration;
      const impulse = context.createBuffer(2, length, sampleRate);
      for (let channel = 0; channel < impulse.numberOfChannels; channel++) {
        const channelData = impulse.getChannelData(channel);
        for (let i = 0; i < length; i++) {
          channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
      }
      return impulse;
    }

    // Изменённая функция initAudio – инициализируем ревербератор при создании audioContext:
    async function initAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        if (!reverbNode) {
          reverbNode = audioContext.createConvolver();
          // Короткий импульс с длительностью 1.0 сек и затуханием 2.0:
          reverbNode.buffer = createImpulseResponse(audioContext, 1.0, 2.0);
          const reverbMix = audioContext.createGain();
          reverbMix.gain.value = 0.3; // уровень смешивания реверберации
          reverbNode.connect(reverbMix);
          reverbMix.connect(audioContext.destination);
        }
      }
    }

    // Изменённая функция createNote – добавляем отправку сигнала в ревербератор:
    function createNote(frequency, startTime, noteIndex) {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      const filter = audioContext.createBiquadFilter();
      const analyser = audioContext.createAnalyser();
      analyser.fftSize = 256;
      analysers[noteIndex] = analyser;
      gainNodes[noteIndex] = gainNode;
      oscillator.type = audioParams.oscillatorType;
      oscillator.frequency.value = frequency;
      filter.type = audioParams.filterType;
      filter.frequency.value = audioParams.filterFrequency;
      gainNode.gain.setValueAtTime(0, startTime);
      gainNode.gain.linearRampToValueAtTime(audioParams.gainSustainLevel, startTime + audioParams.gainAttackTime);
      oscillator.connect(filter);
      filter.connect(gainNode);
      // Подключаем как "сухой" сигнал к анализатору:
      gainNode.connect(analyser);
      // Отправляем часть сигнала в ревербератор (эффект "wet"):
      gainNode.connect(reverbNode);
      analyser.connect(audioContext.destination);
      return { oscillator, gainNode };
    }
    function centsToFrequency(centsOffset) {
      return baseFrequency * Math.pow(2, centsOffset / 1200);
    }

    // Helper function to stop a note gracefully
    function stopNote(note, stopTime) {
        if (note && note.gainNode && note.gainNode.gain && note.oscillator) {
            // Check oscillator playback state before stopping
            // This might require tracking state, or relying on try/catch if stop throws error
             try {
                note.gainNode.gain.cancelScheduledValues(stopTime);
                note.gainNode.gain.setValueAtTime(note.gainNode.gain.value, stopTime); // Hold current gain
                note.gainNode.gain.linearRampToValueAtTime(0, stopTime + audioParams.gainReleaseTime);
                note.oscillator.stop(stopTime + audioParams.gainReleaseTime);
             } catch (e) {
                 // console.warn("Error stopping note (already stopped?):", e);
                 // Might happen if stop is called multiple times rapidly
             }
        }
    }

    // Update opacity of note indicators based on analyser data
    function updateNoteIndicatorsOpacity() {
      let needsRedraw = false;
      analysers.forEach((analyser, i) => {
        if (!analyser || !activeNoteIndicators[i]) return;
        const dataArray = new Uint8Array(analyser.frequencyBinCount);
        analyser.getByteTimeDomainData(dataArray);
        let level = 0;
        for (let j = 0; j < dataArray.length; j++) {
          level += Math.abs(dataArray[j] - 128); // Sum deviations from midpoint
        }
        level = dataArray.length > 0 ? level / dataArray.length : 0; // Average deviation
        // Map level to opacity (adjust divisor for sensitivity)
        const newOpacity = Math.min(1, Math.max(0, level / 40)); // Lower divisor = more sensitive

        // Only flag for redraw if opacity changes significantly
        if (Math.abs(activeNoteIndicators[i].opacity - newOpacity) > 0.01) {
          activeNoteIndicators[i].opacity = newOpacity;
          needsRedraw = true;
        }
        // Ensure tonic opacity also updates if it's playing
        if (i === 1 && currentNote2 && activeNoteIndicators[i].opacity <= 0.01) {
            activeNoteIndicators[i].opacity = 0; // Snap to zero if very low
            needsRedraw = true;
        }
         if (i === 0 && !currentNote1 && activeNoteIndicators[i].opacity <= 0.01) {
             activeNoteIndicators[i].opacity = 0; // Snap to zero if very low
             needsRedraw = true;
         }

      });

      // Request redraw ONLY if opacity changed OR if mouse is down (to show moving line)
      if ((needsRedraw || isMouseDown) && chartRenderer) {
         // Pass the *updated* indicators to the renderer
         chartRenderer.setNoteIndicators(activeNoteIndicators);
         chartRenderer.requestDraw(); // Use the debounced draw request
      }

      requestAnimationFrame(updateNoteIndicatorsOpacity); // Continue the loop
    }

    // Helper to get X data coordinate (cents) from mouse event
    function getXValueFromEvent(event) {
        if (!chartRenderer || !chartRenderer.currentView) return null;

        const canvas = chartRenderer.canvas; // Use renderer's canvas reference
        const rect = canvas.getBoundingClientRect(); // Get canvas position on screen

        // Calculate click X relative to the canvas element's top-left corner
        // event.clientX works relative to viewport, rect.left is canvas left relative to viewport
        const clickX = event.clientX - rect.left;

        // Use canvas bitmap width (which matches CSS width in our setup)
        const canvasWidth = canvas.width;
        const view = chartRenderer.currentView;
        const padding = chartRenderer.options.paddingLeft;
        const graphAreaWidth = canvasWidth - chartRenderer.options.paddingLeft - chartRenderer.options.paddingRight;

        if (graphAreaWidth <= 0) return null;

        // Calculate click relative to the graph *area* start
        const clickXRelativeToGraph = clickX - padding;

        // Normalize X within the graph area [0, 1], clamping to edges
        const normalizedX = Math.max(0, Math.min(1, clickXRelativeToGraph / graphAreaWidth));

        // Convert normalized X back to data coordinates (cents)
        const xValue = view.xMin + normalizedX * (view.xMax - view.xMin);

        return xValue;
    }

    // --- Event Listeners ---
    const HEPlotDiv = document.getElementById('HEPlotDiv');

    HEPlotDiv.addEventListener('mousedown', async (event) => {
        if (event.button !== 0) return; // Only react to left mouse button

        if (!audioContext) await initAudio();
        if (!chartRenderer) return; // Chart must be ready

        const xValue = getXValueFromEvent(event);
        if (xValue === null) return; // Ignore clicks outside valid area

        isMouseDown = true;
        document.body.classList.add('dragging'); // Add dragging cursor style

        // Stop any existing notes immediately
        const now = audioContext.currentTime;
        stopNote(currentNote1, now);
        stopNote(currentNote2, now);
        if (tonicTimeout) clearTimeout(tonicTimeout); // Clear delayed tonic timer

        // Start the first note (at cursor position)
        activeNoteIndicators[0].x = xValue;
        activeNoteIndicators[0].opacity = 1; // Show immediately at full opacity initially
        const freq1 = centsToFrequency(xValue);
        currentNote1 = createNote(freq1, now, 0);
        currentNote1.oscillator.start(now);

        // Schedule the second note (tonic) with delay
        activeNoteIndicators[1].x = 0; // Tonic is always at 0 cents
        activeNoteIndicators[1].opacity = 0; // Start tonic indicator hidden
        const noteDelaySeconds = parseFloat(document.getElementById('noteDelay').value);

        tonicTimeout = setTimeout(() => {
            // Check if mouse is still down when timer fires
            if (isMouseDown && audioContext) {
                 const tonicStartTime = audioContext.currentTime;
                 const freq2 = baseFrequency; // Tonic frequency
                 currentNote2 = createNote(freq2, tonicStartTime, 1);
                 currentNote2.oscillator.start(tonicStartTime);
                 activeNoteIndicators[1].opacity = 1; // Show tonic indicator
                 if (chartRenderer) chartRenderer.requestDraw(); // Redraw to show tonic line immediately
            }
            tonicTimeout = null; // Clear timer ID
        }, noteDelaySeconds * 1000);

        // Initial draw to show the first note indicator
        chartRenderer.setNoteIndicators(activeNoteIndicators);
        chartRenderer.requestDraw();
    });

    document.addEventListener('mousemove', (event) => { // Listen on document for dragging outside
        if (!isMouseDown || !chartRenderer) return; // Only act if dragging

        const xValue = getXValueFromEvent(event);
        if (xValue === null) {
            // If mouse moves outside valid area while dragging, maybe stop notes? Or just stop moving line?
            // Let's just stop moving the line for now.
            return;
        };

        // Update the position of the first note indicator
        activeNoteIndicators[0].x = xValue;

        // Smoothly change the frequency of the first note
        if (currentNote1 && audioContext) {
            const freq1 = centsToFrequency(xValue);
            // Use setTargetAtTime for smoother frequency changes
            currentNote1.oscillator.frequency.setTargetAtTime(freq1, audioContext.currentTime, 0.01); // 0.01s time constant
        }

        // Request redraw to show the moving indicator line
        chartRenderer.setNoteIndicators(activeNoteIndicators);
        chartRenderer.requestDraw();
    });

    document.addEventListener('mouseup', (event) => { // Listen on document
        if (event.button !== 0 || !isMouseDown) return; // Only react to left mouse button release if dragging

        isMouseDown = false;
        document.body.classList.remove('dragging'); // Remove dragging cursor style

        const now = audioContext ? audioContext.currentTime : 0;

        // Stop both notes
        stopNote(currentNote1, now);
        stopNote(currentNote2, now);
        currentNote1 = null;
        currentNote2 = null;

        // Clear the tonic timer if it hasn't fired yet
        if (tonicTimeout) {
            clearTimeout(tonicTimeout);
            tonicTimeout = null;
        }

        // Hide the first note indicator (set x to null)
        // Opacity will fade out naturally via updateNoteIndicatorsOpacity
        activeNoteIndicators[0].x = null;
        // We can optionally force opacity to 0 here, but letting the analyser handle it is smoother
        // activeNoteIndicators[0].opacity = 0;
        // activeNoteIndicators[1].opacity = 0; // Tonic indicator opacity will also fade via analyser

        // Request a final draw to remove the line if opacity doesn't handle it fast enough
        if (chartRenderer) {
            chartRenderer.setNoteIndicators(activeNoteIndicators);
            chartRenderer.requestDraw();
        }
    });


    /* ================================
         ИНИЦИАЛИЗАЦИЯ ПРИ ЗАГРУЗКЕ
       ================================ */
    let chartRenderer = null; // Ensure renderer is accessible globally

    window.addEventListener('DOMContentLoaded', () => {
      const calculator = new HarmonicEntropyCalculator();

      // Debounce updatePlot to avoid excessive calculations during slider drags
      let debounceTimeout = null;
      function debouncedUpdatePlot(delay = 250) { // 250ms delay
          clearTimeout(debounceTimeout);
          debounceTimeout = setTimeout(() => {
             updatePlot();
          }, delay);
      }

      function updatePlot() {
          console.log("Updating plot..."); // Debug log
          const HEinfo = {
            // Provide default values in case parsing fails
            N: parseInt(document.getElementById("textN").value) || 3000,
            mincents: (parseFloat(document.getElementById("textmin").value) || 0) * 1200,
            maxcents: (parseFloat(document.getElementById("textmax").value) || 1) * 1200,
            s: (parseFloat(document.getElementById("sliders").value) || 1.25) / 100, // Convert percentage
            a: parseFloat(document.getElementById("slidera").value) || 2.4,
            res: 1.0 // Resolution seems fixed in calculation
          };

          // Basic validation
          if (isNaN(HEinfo.mincents) || isNaN(HEinfo.maxcents) || HEinfo.mincents >= HEinfo.maxcents || HEinfo.N <= 0 || HEinfo.s <= 0 || HEinfo.a <= 0) {
            console.error("Invalid HE parameters:", HEinfo);
            // Maybe display an error message to the user?
            return;
          }
          // Check if maxcents is reasonably larger than mincents
           if (HEinfo.maxcents - HEinfo.mincents < 10) { // Require at least 10 cents range
                console.warn("HE range too small:", HEinfo.maxcents - HEinfo.mincents);
                // Optionally provide feedback or prevent calculation
           }


          calculator.preCalcRatios(HEinfo); // Start calculation process
      }

      // --- Setup Event Listeners ---
      document.getElementById("slidera").addEventListener("input", (e) => {
        document.getElementById("aval").textContent = "Bandwidth (a): " + parseFloat(e.target.value).toFixed(2);
        debouncedUpdatePlot(); // Use debounced update for sliders
      });
      document.getElementById("sliders").addEventListener("input", (e) => {
        document.getElementById("sval").textContent = "Smoothing (s): " + parseFloat(e.target.value).toFixed(2) + "%";
        debouncedUpdatePlot(); // Use debounced update for sliders
      });

      // Update label for Note Delay slider immediately on input
      document.getElementById("noteDelay").addEventListener("input", (e) => {
        document.getElementById("noteDelayLabel").textContent = "Note Delay: " + parseFloat(e.target.value).toFixed(2) + "s";
        // No need to updatePlot for note delay change
      });

      // Use 'change' event for text inputs to update plot after user finishes editing
      document.getElementById('textN').addEventListener('change', updatePlot);
      document.getElementById('textmin').addEventListener('change', updatePlot);
      document.getElementById('textmax').addEventListener('change', updatePlot);

      document.querySelectorAll('.stepper-button').forEach(button => {
        button.addEventListener('click', function() {
          const targetInputId = this.dataset.target;
          const inputElement = document.getElementById(targetInputId);
          let currentValue = parseInt(inputElement.value, 10);
          if (isNaN(currentValue)) currentValue = 0; // Handle non-numeric input
          const step = parseInt(inputElement.step, 10) || 1;

          currentValue += this.classList.contains('minus') ? -step : step;

           // Add reasonable limits for min/max octaves if desired
           if (targetInputId === 'textmin' || targetInputId === 'textmax') {
                currentValue = Math.max(-2, Math.min(5, currentValue)); // Example limit: -2 to 5 octaves
           }
           if (targetInputId === 'textN') {
                currentValue = Math.max(10, currentValue); // Minimum N value
           }


          inputElement.value = currentValue;
          updatePlot(); // Update plot immediately on stepper click
        });
      });

      // --- Initial Setup ---
      // Set initial label values from defaults
      document.getElementById("aval").textContent = "Bandwidth (a): " + parseFloat(document.getElementById("slidera").value).toFixed(2);
      document.getElementById("sval").textContent = "Smoothing (s): " + parseFloat(document.getElementById("sliders").value).toFixed(2) + "%";
      document.getElementById("noteDelayLabel").textContent = "Note Delay: " + parseFloat(document.getElementById('noteDelay').value).toFixed(2) + "s";

      // Initial plot calculation
      updatePlot();

      // Start the audio analyser loop after a short delay
      setTimeout(updateNoteIndicatorsOpacity, 200);
    });
  </script>
</body>
</html>