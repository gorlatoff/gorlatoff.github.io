



## Записки о музыкальной арифметике: Путешествие к гармонии через код

Музыка, язык вселенной,  говорит с нами на языке вибраций. С древнейших времен люди стремились расшифровать этот язык,  понять законы гармонии. От Пифагора, экспериментировавшего с монохордом, до современных композиторов, использующих сложные алгоритмы,  —  это путешествие продолжается. В этой статье мы не просто коснемся истории музыкальной теории, но и создадим  инструмент для исследования гармонии — программу на языке Julia,  которая позволит нам генерировать лады,  основанные на  акустических  принципах. Этот метод откроет новые горизонты для музыкального творчества, расширяя границы традиционной тональности.

### I. От монохорда к компьютеру: в поисках идеального строя

История музыки — это  история  поиска  идеального  строя. Каждый  этап  этого  путешествия  — попытка  улучшить  созвучие  нот,  расширить  выразительные  возможности  музыки.

* **Натуральный строй (Урмави, Античность):** Основанный на простых  числовых  соотношениях  частот,  он  обладает  акустической  чистотой,  но  ограничен  в  транспонировании.

* **Кварто-квинтовый строй (Пифагор, Средневековье):**  Позволяет  транспонировать,  но  страдает  от  "волчьих  квинт" — диссонирующих  интервалов.

* **Равномерно темперированный строй (Тоннетц, Новое время):**  Обеспечивает  удобство  модуляции,  но  ценой  потери  акустической  чистоты  и  нюансов  гармонии. Например,  в  нем  интервалы  7/4, 9/5  и  16/9  отображаются  на  одну  и  ту  же  темперированную  ноту (малую  септиму),  хотя  в  натуральном  строе  они  различны.

Наша  цель —  создать  систему,  которая  сочетала  бы  акустическую  чистоту  натурального  строя  с  гибкостью  темперированного.

### II. Физика гармонии:  обертоны и консонанс

Звук  —  это  вибрация. Музыкальный  звук —  это  сложная  вибрация,  состоящая  из  суммы  гармоник,  или  обертонов. Частоты  обертонов  кратны  основной  частоте  звука.

<image alt="иллюстрация с гармониками как отдельными волнами, укладывающимися в основной тон" src="harmonics_waveform.png"></image>

<iframe src="interactive_oscilloscope.html"></iframe> <comment>Интерактивный пример с осциллоскопом</comment>

Консонанс,  или  благозвучие,  двух  нот  зависит  от  совпадения  их  обертонов. Чем  больше  совпадений,  тем  консонантнее  интервал. Если  частоты  двух  нот  относятся  друг  к  другу  как  целые  дроби  *m/n*,  то  процент  совпадения  гармоник  можно  оценить  формулой *1/m + 1/n*.

<image alt="пример с совпадающими гармониками разных нот" src="overlapping_harmonics.png"></image>

<iframe src="harmonics_visualizer.html"></iframe> <comment>Визуализатор гармоник</comment>

Эта  формула  будет  использована  в  коде  для  вычисления  консонанса.
 
## Алхимия гармонии: создаем мажорный лад из математических формул

Музыка — это не просто набор звуков. Это вибрация, резонирующая с нашей душой, универсальный язык, способный передавать эмоции и идеи без слов. С древних времен люди стремились разгадать тайны музыкальной гармонии. Это путешествие привело нас от экспериментов Пифагора с монохордом до современных алгоритмов, способных генерировать гармонические структуры с математической точностью. В этой статье мы  не просто рассмотрим теорию, но и научимся самостоятельно создавать музыкальные лады, используя язык программирования Julia. Этот метод позволит нам  экспериментировать с новыми строями  и  понимать глубинную структуру музыки.

### Шаг 1:  Звук как сумма гармоник

Прежде чем погрузиться в код, давайте вспомним, что музыкальный звук — это не просто одиночная частота, а сложная комбинация колебаний, называемых гармониками или обертонами. Частоты обертонов кратны основной частоте (основному тону).

<iframe src="interactive_oscilloscope.html"></iframe> <comment>Интерактивный пример с осциллоскопом, на котором можно включить разные обертоны с разными формами волны, укладывающимися в основной тон</comment>

### Шаг 2: Математика консонанса

Консонанс, или благозвучие,  связан с совпадением обертонов у разных звуков. Чем больше совпадающих обертонов, тем консонантнее интервал. Это можно выразить математически. Если частоты двух нот относятся друг к другу как целые дроби *m/n*,  то процент совпадающих гармоник можно оценить формулой  *1/m + 1/n*.

<iframe src="harmonics_visualizer.html"></iframe> <comment>Визуализатор гармоник на спектрограмме. Все гармоники кликабельны и звучат, а программа показывает общую тонику для двух звуков</comment>

Эта  формула  ляжет  в  основу  нашей  функции  `consonance`:

```julia
function consonance(ratio::Rational{Int})::Float64
    Float64(denominator(ratio)^-1 + numerator(ratio)^-1)
end
```

### Шаг 3:  Создание фундамента – допустимые интервалы

Теперь  перейдем  к  практике. Первым  шагом  будет  создание  набора  допустимых  интервалов,  из  которых  мы  будем  строить  лады.

```julia
using Combinatorics
using Primes

# Генерация всех возможных интервалов (дробей) до 45/45
base_ratios = Rational{Int}[y // x for (x, y) in combinations(1:45, 2)]
```

Мы  генерируем  все  возможные  дроби,  где  числитель  и  знаменатель  не  превышают  45,  аналогично  тому,  как  Пифагор  экспериментировал  с  разными  делениями  струны  на  монохорде. В  его  экспериментах  длина  струны,  деленная  на  целое  число  или  его  долю,  определяла  высоту  звука.

```julia
# Фильтрация отношений по odd_limit
odd_limit(limit::Int, ratio::Rational{Int}) = numerator(ratio) <= limit && denominator(ratio) <= limit
filtered_by_odd_limit = filter(r -> odd_limit(32, r), base_ratios)

# Фильтрация отношений по prime_limit
prime_limit(ratio::Rational{Int}) = begin
    ispow2(denominator(ratio)) || return false
    factors = Primes.factor(Vector, numerator(ratio))
    count(==(3), factors) <= 4 && count(>=(5), factors) <= 2 && count(>=(7), factors) <= 1
end
filtered_ratios = filter(prime_limit, filtered_by_odd_limit)

```

Затем фильтруем эти дроби,  используя  `odd_limit` и  `prime_limit`.   `odd_limit`  ограничивает  величину  числителя  и  знаменателя (не более 32),  чтобы  избежать  слишком  сложных  соотношений.   `prime_limit`  ограничивает  использование  простых  множителей  в  числителе,  отдавая  предпочтение  интервалам,  близким  к  гармоническому  ряду.   Эти  ограничения  основаны  на  акустических  свойствах  звука  и  нашем  восприятии  консонанса.

```julia
# Нормализация интервалов к октаве и удаление дубликатов
normalize_to_octave(ratio::Rational{Int}) = ratio / (2//1)^floor(Int, log2(ratio))
intervals = unique(normalize_to_octave.(filtered_ratios))

# Вывод таблицы интервалов
println("Допустимые интервалы:")
for interval in intervals
    cents = round(1200 * log2(interval), digits=2)
    name = "" # Здесь нужно добавить названия интервалов
    println("$interval \t $cents ц. \t $name")
end
```
После  фильтрации  мы  нормализуем  интервалы  к  октаве  и  удаляем  дубликаты. Затем  выводим  таблицу  интервалов  с  их  названиями  и  величиной  в  центах. (Заполнение  названий  интервалов  в  таблице  остается  ручной  работой,  так  как  не  все  дроби  соответствуют  стандартным  названиям  интервалов).

### Шаг 4:  Построение ладов:  полный перебор

Теперь,  имея  набор  допустимых  интервалов,  мы  можем  приступить  к  построению  ладов.   Мы  будем  использовать  алгоритм  полного  перебора,  постепенно  увеличивая  число  нот  в  ладу.

```julia
# ... (определение типов данных Scale, ScaleWithConsonance, ScaleDatabase)

function insert_scale!(scales::Vector{ScaleWithConsonance}, new_scale::Scale, consonance_value::Float64)
    # ... (код функции insert_scale! для добавления лада в коллекцию, как описано ранее)
end

function scale_consonance(scale::Scale)::Float64
    # ... (код функции scale_consonance для расчета консонанса лада, как описано ранее)
end

function generate_scales(max_notes::Int=7)::ScaleDatabase
    # ... (инициализация базы данных ладов)

    for n in 2:max_notes
        new_scales = Vector{ScaleWithConsonance}()

        for (_, scale) in scales_db[n-1] #  Берем каждый лад с n-1 нотами
            for interval in intervals     #  Для каждого допустимого интервала
                for base_note in scale #  Для каждой ноты в текущем ладу

                    new_note_up = normalize_to_octave(base_note * interval)
                    new_note_down = normalize_to_octave(base_note / interval)

                     for new_note in [new_note_up, new_note_down]
                        new_scale = sort(unique([scale; new_note]))
                        if length(new_scale) == n # Проверяем, что нота уникальна
                           cons = scale_consonance(new_scale)
                           if cons >= MIN_CONSONANCE
                               insert_scale!(new_scales, new_scale, cons) 
                           end
                        end
                     end
                end
            end
        end
        scales_db[n] = new_scales #  Сохраняем лады с n нотами
    end
    return scales_db
end

const MAX_NOTES = 8 #  Максимальное количество нот в ладу
const MIN_CONSONANCE = 0.3 #  Минимальный консонанс

scales_db = generate_scales(MAX_NOTES)

#  Вывод результатов (код функции print_scales)
```

Алгоритм  начинается  с  унисона (одна  нота)  и  последовательно  строит  лады  с  2, 3, ... , `MAX_NOTES` нотами. На  каждом  шаге  мы  берем  все  найденные  лады  с  `n-1`  нотами  и  пробуем  добавить  к  ним  еще  одну  ноту,  используя  все  допустимые  интервалы.   Мы  умножаем  и  делим  каждую  ноту  в  исходном  ладу  на  каждый  интервал,  нормализуем  результат  к  октаве  и  проверяем,  что  полученная  нота  уникальна. Затем  вычисляем  консонанс  нового  лада  и,  если  он  превышает  `MIN_CONSONANCE`,  добавляем  лад  в  нашу  коллекцию.   **Это  полный  перебор,  который  гарантирует,  что  мы  рассмотрим  все  возможные  варианты  в  пределах  заданных  ограничений.**  Вывод  результатов  покажет  нам  найденные  лады,  отсортированные  по  консонансу. Среди  них  мы  найдем  и  знакомые  нам  мажорный  лад,  мажорное  и  минорные  трезвучия,  и  множество  других.

### III. Строим  математический  фундамент:  допустимые  интервалы

Начнем  с  создания  набора  допустимых  интервалов. Используем  язык  программирования Julia.

```julia
using Combinatorics
using Primes

#  Генерация всех возможных отношений частот (дробей) до 45/45
base_ratios = Rational{Int}[y // x for (x, y) in combinations(1:45, 2)]

#  Фильтрация отношений по odd limit (числитель и знаменатель не больше 32)
odd_limit(limit::Int, ratio::Rational{Int}) = numerator(ratio) <= limit && denominator(ratio) <= limit
filtered_by_odd_limit = filter(r -> odd_limit(32, r), base_ratios)

#  Фильтрация отношений по prime limit (только простые множители 2, 3, 5, 7 с ограничениями)
prime_limit(ratio::Rational{Int}) = begin
    ispow2(denominator(ratio)) || return false
    factors = Primes.factor(Vector, numerator(ratio))
    count(==(3), factors) <= 4 && count(>=(5), factors) <= 2 && count(>=(7), factors) <= 1
end
filtered_ratios = filter(prime_limit, filtered_by_odd_limit)

#  Нормализация интервалов к октаве и удаление дубликатов
normalize_to_octave(ratio::Rational{Int}) = ratio / (2//1)^floor(Int, log2(ratio))
intervals = unique(normalize_to_octave.(filtered_ratios))

#  Вывод таблицы интервалов
println("Допустимые интервалы:")
for interval in intervals
    cents = round(1200 * log2(interval), digits=2)
    name = "" #  Здесь нужно добавить названия интервалов (см. таблицу ниже)
    println("$interval \t $cents ц. \t $name")
end
```

Этот  код  генерирует  все  возможные  дроби  с  числителем  и  знаменателем  не  более  45,  а  затем  фильтрует  их,  используя  `odd_limit`  и  `prime_limit`. `odd_limit`  ограничивает  сложность  дробей,  а  `prime_limit`  отдает  предпочтение  интервалам,  близким  к  гармоническому  ряду.   Результат  —  набор  "допустимых"  интервалов,  из  которых  мы  будем  строить  лады. Затем интервалы нормализуются  к  октаве  и  избавляемся  от  дубликатов.

**Более подробное объяснение prime limit и odd limit:**

Важно не просто привести код, но и объяснить, *почему* мы используем эти ограничения.

- **Odd Limit:** Ограничивая числитель и знаменатель дроби, мы избегаем слишком сложных соотношений частот, которые трудны для восприятия и интонирования. Это также делает вычисления более эффективными. В нашем случае, предел равен 32, что позволяет включить большинство важных музыкальных интервалов.
- **Prime Limit:** Ограничивая набор простых множителей в числителе дроби числами 2, 3, 5 и 7 (с определенными дополнительными ограничениями), мы отдаем предпочтение интервалам, близким к гармоническому ряду. Это обусловлено тем, что гармонический ряд играет фундаментальную роль в нашем восприятии гармонии. Ограничения на количество 3, 5 и 7 в числителе необходимы, чтобы избежать слишком сложных и диссонирующих интервалов.

**Таблица интервалов (пример):**

| Дробь | Центы  | Название интервала            |
| ----- | ------ | ----------------------------- |
| 1//1  | 0      | Унисон                        |
| 3//2  | 701.96 | Квинта                        |
| 5//4  | 386.31 | Большая терция                |
| 7//4  | 968.83 | Малая септима (гармоническая) |
| ...   | ...    | ...                           |

###  IV. Генерация ладов:  полный перебор

Теперь,  вооруженные  набором  допустимых  интервалов,  мы  можем  приступить  к  самой  интересной  части  —  генерации  ладов.

**(Код  функций `insert_scale!`,  `scale_consonance`,  `generate_scales`  и  `print_scales`  приводится  здесь  полностью,  с  комментариями.)**

Алгоритм  полного  перебора,  используемый  в  функции  `generate_scales`,  последовательно  строит  лады,  начиная  с  унисона  и  добавляя  по  одной  ноте  за  раз.   На  каждом  шаге  мы  перебираем  все  допустимые  интервалы  и  все  ноты  в  текущем  ладу,  создавая  новые  ноты  путем  умножения  и  деления. Затем  проверяем  уникальность  новой  ноты,  вычисляем  консонанс  нового  лада  и  добавляем  его  в  базу  данных,  если  он  удовлетворяет  минимальному  порогу  консонанса. 

### V. Исторический экскурс: визуализация строев

Понимание исторического контекста помогает оценить новаторство предлагаемого подхода. Давайте рассмотрим эволюцию музыкальных строев через призму визуализации.

**1. Модальность и натуральный строй (Античность):**

В древности музыка строилась на  модальных ладах,  близких к натуральному строю. Числовые соотношения частот, основанные на простых дробях,  обеспечивали  чистоту созвучий. Визуализировать эти лады можно с помощью схем,  подобных  тем,  что  использовал персидский теоретик Аль-Урвами.

<iframe src="al_urmavi_visualizer.html"></iframe> <comment>Визуализатор ладов в схемах Урмави</comment>

Преимущество натурального строя —  акустическая чистота и выразительность каждого интервала. Например, малая септима может быть представлена как 7/4, 9/5 или 16/9, и эти нюансы можно использовать для создания  богатой  гармонической  палитре.

**2. Пифагоров строй (Средневековье):**

В  Средневековье  получил  распространение  пифагоров  строй,  основанный  на  кварто-квинтовом  круге.

<iframe src="pythagorean_circle_visualizer.html"></iframe> <comment>Визуализатор кварто-квинтового круга</comment>

Математически  этот  строй  можно  представить  через  степени  3/2:

```julia
pythagor = [(3//2)^i for i in -5:5]

for i in -5:5
  println("3//2^$(i) -> $((3//2)^(i))") 
end

# Нормализация к октаве
function normalize_to_octave(ratio::Rational{Int})
    ratio / (2//1)^floor(Int, log2(ratio))
end
pythagor = normalize_to_octave.(pythagor)
println(pythagor)
```

Однако  кварто-квинтовый  круг  содержит  "волчьи  квинты" — диссонирующие  интервалы,  что  ограничивает  гармонические  возможности.

**3. Равномерная темперация (Новое Время):**

Равномерная  темперация,  ставшая  стандартом  в  Новое  время,  решает  проблему  "волчьих  квинт",  но  ценой  потери  акустической  чистоты. Визуализировать  ее  можно  с  помощью  тональной  сетки (Tonnetz).

<iframe src="tonnetz_visualizer.html"></iframe> <comment>Визуализатор Tonnetz</comment>

Математически  тональную  логику  можно  выразить  через  функцию,  генерирующую  мажорные  аккорды:

```julia
major_chord(tonica) = [tonica, tonica*5//4, tonica*3//2]
tonica = 1//1
subdominant_chord = major_chord(tonica * (3//2)^-1)
tonic_chord = major_chord(tonica * (3//2)^0)
dominant_chord = major_chord(tonica * (3//2)^1)
major_scale = vcat(subdominant_chord, tonic_chord, dominant_chord)
```

### VI. Унтертоновая полимодальность: новая философия гармонии

Предлагаемый подход — унтертоновая полимодальность —  сочетает  акустическую  чистоту  с  гибкостью  в  использовании  любых  нот. Идея  заключается  в  том,  что  каждый  голос  может  иметь  свой  лад,  при  этом  все  лады  "привязаны"  к  общей  акустической  тонике. Это  позволяет  использовать  богатую  гармоническую  палитру,  не  теряя  ощущения  тонального  центра.

**Генерация унтертоновых ладов:**

```julia
# ... (код для генерации унтертоновых ладов, как описано ранее)
```

<pre><code>
# Пример сгенерированных ладов (заглушка,  дополнить реальными данными)
[1, 21//20, 7//6, 6//5, 21//16, 7//5, 3//2, 14//9, 7//4, 28//15]
[1, 16//15, 6//5, 4//3, 3//2, 8//5, 16//9]
...
</code></pre>

<iframe src="polymodal_music_example.html"></iframe> <comment>Пример унтертоновой полимодальности в интерактивном приложении</comment>

Эта  система  открывает удивительные возможности для  композиторов. Мы  можем  использовать  любую  ноту,  относя  ее  к  нужному  ладу.   Динамика  развития  гармонии  приобретает  новую  гибкость:  переходы  между  ладами  становятся  более  плавными  и  не  воспринимаются  как  резкие  модуляции. Однако  эта  система  требует  нового  мышления  о  гармонии,  основанного  на  понимании  акустических  соотношений  частот.

### VII. Заключение: Гармония как живое пространство

Мы  совершили  путешествие  от  древних  музыкальных  теорий  до  современных  алгоритмов,  способных  генерировать  гармонические  структуры.   Унтертоновая  полимодальность  предлагает  новый  взгляд  на  гармонию  — не  как  на  жесткий  каркас,  а  как  на  живое  пространство  с  множеством  измерений.   Каждый  лад —  это  своеобразный  "регион"  в  этом  пространстве,  обладающий  своей  уникальной  звуковой  палитрой,  но  связанный  с  другими  регионами  через  общую  акустическую  тонику.   Этот  подход  открывает  новые  возможности  для  музыкального  творчества,  позволяя  композиторам  исследовать  неизведанные  гармонические  миры.

**(В  приложении  приводится  полный  код  программы,  математические  выкладки  и  дополнительные  иллюстрации.)**