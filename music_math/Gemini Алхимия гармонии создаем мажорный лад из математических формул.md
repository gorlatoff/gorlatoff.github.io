## Алхимия гармонии: создаем мажорный лад из математических формул

Музыка — это не просто набор звуков. Это вибрация, резонирующая с нашей душой, универсальный язык, способный передавать эмоции и идеи без слов. С древних времен люди стремились разгадать тайны музыкальной гармонии. Это путешествие привело нас от экспериментов Пифагора с монохордом до современных алгоритмов, способных генерировать гармонические структуры с математической точностью. В этой статье мы  не просто рассмотрим теорию, но и научимся самостоятельно создавать музыкальные лады, используя язык программирования Julia. Этот метод позволит нам  экспериментировать с новыми строями  и  понимать глубинную структуру музыки.

### Шаг 1:  Звук как сумма гармоник

Прежде чем погрузиться в код, давайте вспомним, что музыкальный звук — это не просто одиночная частота, а сложная комбинация колебаний, называемых гармониками или обертонами. Частоты обертонов кратны основной частоте (основному тону).

<iframe src="interactive_oscilloscope.html"></iframe> <comment>Интерактивный пример с осциллоскопом, на котором можно включить разные обертоны с разными формами волны, укладывающимися в основной тон</comment>

### Шаг 2: Математика консонанса

Консонанс, или благозвучие,  связан с совпадением обертонов у разных звуков. Чем больше совпадающих обертонов, тем консонантнее интервал. Это можно выразить математически. Если частоты двух нот относятся друг к другу как целые дроби *m/n*,  то процент совпадающих гармоник можно приблизительно оценить формулой  *1/m + 1/n*.

<iframe src="harmonics_visualizer.html"></iframe> <comment>Визуализатор гармоник на спектрограмме. Все гармоники кликабельны и звучат, а программа показывает общую тонику для двух звуков</comment>

Эта  формула  ляжет  в  основу  нашей  функции  `consonance`:

```julia
function consonance(ratio::Rational{Int})::Float64
    Float64(denominator(ratio)^-1 + numerator(ratio)^-1)
end
```

### Шаг 3:  Создание фундамента – допустимые интервалы

Теперь  перейдем  к  практике. Первым  шагом  будет  создание  набора  допустимых  интервалов,  из  которых  мы  будем  строить  лады.

```julia
using Combinatorics
using Primes

# Генерация всех возможных интервалов (дробей) до 45/45
base_ratios = Rational{Int}[y // x for (x, y) in combinations(1:45, 2)]
```

Мы  генерируем  все  возможные  дроби,  где  числитель  и  знаменатель  не  превышают  45,  аналогично  тому,  как  Пифагор  экспериментировал  с  разными  делениями  струны  на  монохорде. В  его  экспериментах  длина  струны,  деленная  на  целое  число  или  его  долю,  определяла  высоту  звука.

```julia
# Фильтрация отношений по odd_limit
odd_limit(limit::Int, ratio::Rational{Int}) = numerator(ratio) <= limit && denominator(ratio) <= limit
filtered_by_odd_limit = filter(r -> odd_limit(32, r), base_ratios)

# Фильтрация отношений по prime_limit
prime_limit(ratio::Rational{Int}) = begin
    ispow2(denominator(ratio)) || return false
    factors = Primes.factor(Vector, numerator(ratio))
    count(==(3), factors) <= 4 && count(>=(5), factors) <= 2 && count(>=(7), factors) <= 1
end
filtered_ratios = filter(prime_limit, filtered_by_odd_limit)

```

Затем фильтруем эти дроби,  используя  `odd_limit` и  `prime_limit`.   `odd_limit`  ограничивает  величину  числителя  и  знаменателя (не более 32),  чтобы  избежать  слишком  сложных  соотношений.   `prime_limit`  ограничивает  использование  простых  множителей  в  числителе,  отдавая  предпочтение  интервалам,  близким  к  гармоническому  ряду.   Эти  ограничения  основаны  на  акустических  свойствах  звука  и  нашем  восприятии  консонанса.

```julia
# Нормализация интервалов к октаве и удаление дубликатов
normalize_to_octave(ratio::Rational{Int}) = ratio / (2//1)^floor(Int, log2(ratio))
intervals = unique(normalize_to_octave.(filtered_ratios))

# Вывод таблицы интервалов
println("Допустимые интервалы:")
for interval in intervals
    cents = round(1200 * log2(interval), digits=2)
    name = "" # Здесь нужно добавить названия интервалов
    println("$interval \t $cents ц. \t $name")
end
```
После  фильтрации  мы  нормализуем  интервалы  к  октаве  и  удаляем  дубликаты. Затем  выводим  таблицу  интервалов  с  их  названиями  и  величиной  в  центах. (Заполнение  названий  интервалов  в  таблице  остается  ручной  работой,  так  как  не  все  дроби  соответствуют  стандартным  названиям  интервалов).

### Шаг 4:  Построение ладов:  полный перебор

Теперь,  имея  набор  допустимых  интервалов,  мы  можем  приступить  к  построению  ладов.   Мы  будем  использовать  алгоритм  полного  перебора,  постепенно  увеличивая  число  нот  в  ладу.

```julia
# ... (определение типов данных Scale, ScaleWithConsonance, ScaleDatabase)

function insert_scale!(scales::Vector{ScaleWithConsonance}, new_scale::Scale, consonance_value::Float64)
    # ... (код функции insert_scale! для добавления лада в коллекцию, как описано ранее)
end

function scale_consonance(scale::Scale)::Float64
    # ... (код функции scale_consonance для расчета консонанса лада, как описано ранее)
end

function generate_scales(max_notes::Int=7)::ScaleDatabase
    # ... (инициализация базы данных ладов)

    for n in 2:max_notes
        new_scales = Vector{ScaleWithConsonance}()

        for (_, scale) in scales_db[n-1] #  Берем каждый лад с n-1 нотами
            for interval in intervals     #  Для каждого допустимого интервала
                for base_note in scale #  Для каждой ноты в текущем ладу

                    new_note_up = normalize_to_octave(base_note * interval)
                    new_note_down = normalize_to_octave(base_note / interval)

                     for new_note in [new_note_up, new_note_down]
                        new_scale = sort(unique([scale; new_note]))
                        if length(new_scale) == n # Проверяем, что нота уникальна
                           cons = scale_consonance(new_scale)
                           if cons >= MIN_CONSONANCE
                               insert_scale!(new_scales, new_scale, cons) 
                           end
                        end
                     end
                end
            end
        end
        scales_db[n] = new_scales #  Сохраняем лады с n нотами
    end
    return scales_db
end

const MAX_NOTES = 8 #  Максимальное количество нот в ладу
const MIN_CONSONANCE = 0.3 #  Минимальный консонанс

scales_db = generate_scales(MAX_NOTES)

#  Вывод результатов (код функции print_scales)
```

Алгоритм  начинается  с  унисона (одна  нота)  и  последовательно  строит  лады  с  2, 3, ... , `MAX_NOTES` нотами. На  каждом  шаге  мы  берем  все  найденные  лады  с  `n-1`  нотами  и  пробуем  добавить  к  ним  еще  одну  ноту,  используя  все  допустимые  интервалы.   Мы  умножаем  и  делим  каждую  ноту  в  исходном  ладу  на  каждый  интервал,  нормализуем  результат  к  октаве  и  проверяем,  что  полученная  нота  уникальна. Затем  вычисляем  консонанс  нового  лада  и,  если  он  превышает  `MIN_CONSONANCE`,  добавляем  лад  в  нашу  коллекцию.   **Это  полный  перебор,  который  гарантирует,  что  мы  рассмотрим  все  возможные  варианты  в  пределах  заданных  ограничений.**  Вывод  результатов  покажет  нам  найденные  лады,  отсортированные  по  консонансу. Среди  них  мы  найдем  и  знакомые  нам  мажорный  лад,  мажорное  и  минорные  трезвучия,  и  множество  других.